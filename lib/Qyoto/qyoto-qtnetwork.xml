<?xml version="1.0"?>
<doc>
    <assembly>
        <name>qyoto-qtnetwork</name>
    </assembly>
    <members>
        <member name="T:QtNetwork.QAbstractNetworkCache">
            <summary>
            The QAbstractNetworkCache class provides the interface for cache implementations.
            </summary>
            <remarks>
                <para>
                </para>
                <para>QAbstractNetworkCache is the base class for every standard cache that is used be QNetworkAccessManager. QAbstractNetworkCache is an abstract class and cannot be instantiated.</para>
                <para>
                </para>
                <para>See also QNetworkDiskCache.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QAbstractNetworkCache.#ctor(QtCore.QObject)">
            <summary>
                <para>Constructs an abstract network cache with the given parent.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAbstractNetworkCache.CacheSize">
            <summary>
                <para>Returns the current size taken up by the cache. Depending upon the cache implementation this might be disk or memory size.</para>
                <para>In the base class this is a pure virtual function.</para>
                <para>See also clear().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractNetworkCache.Clear">
            <summary>
                <para>Removes all items from the cache. Unless there was failures clearing the cache cacheSize() should return 0 after a call to clear.</para>
                <para>In the base class this is a pure virtual function.</para>
                <para>See also cacheSize() and remove().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractNetworkCache.Data(QtCore.QUrl)">
            <summary>
                <para>Returns the data associated with url.</para>
                <para>It is up to the application that requests the data to delete the QIODevice when done with it.</para>
                <para>If there is no cache for url, the url is invalid, or if there is an internal cache error 0 is returned.</para>
                <para>In the base class this is a pure virtual function.</para>
                <para>See also metaData() and prepare().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractNetworkCache.Insert(QtCore.QIODevice)">
            <summary>
                <para>Inserts the data in device and the prepared meta data into the cache. After this function is called the data and meta data should be retrievable using data() and metaData().</para>
                <para>To cancel a prepared inserted call remove() on the metadata's url.</para>
                <para>In the base class this is a pure virtual function.</para>
                <para>See also prepare() and remove().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractNetworkCache.MetaData(QtCore.QUrl)">
            <summary>
                <para>Returns the meta data for the url url.</para>
                <para>If the url is valid and the cache contains the data for url, a valid QNetworkCacheMetaData is returned.</para>
                <para>In the base class this is a pure virtual function.</para>
                <para>See also updateMetaData() and data().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractNetworkCache.Prepare(QtNetwork.QNetworkCacheMetaData)">
            <summary>
                <para>Returns the device that should be populated with the data for the cache item metaData. When all of the data has been written insert() should be called. If metaData is invalid or the url in the metadata is invalid 0 is returned.</para>
                <para>The cache owns the device and will take care of deleting it when it is inserted or removed.</para>
                <para>To cancel a prepared inserted call remove() on the metadata's url.</para>
                <para>In the base class this is a pure virtual function.</para>
                <para>See also remove(), updateMetaData(), and insert().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractNetworkCache.Remove(QtCore.QUrl)">
            <summary>
                <para>Removes the cache entry for url, returning true if success otherwise false.</para>
                <para>In the base class this is a pure virtual function.</para>
                <para>See also clear() and prepare().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractNetworkCache.UpdateMetaData(QtNetwork.QNetworkCacheMetaData)">
            <summary>
                <para>Updates the cache meta date for the metaData's url to metaData</para>
                <para>If the cache does not contains a cache item for the url then no action is taken.</para>
                <para>In the base class this is a pure virtual function.</para>
                <para>See also metaData() and prepare().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractNetworkCache.Finalize">
            <summary>
                <para>Destroys the cache.</para>
                <para>Any operations that have not been inserted are discarded.</para>
                <para>See also insert().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QAbstractSocket">
            <summary>
            The QAbstractSocket class provides the base functionality common to all socket types.
            </summary>
            <remarks>
                <para>
                </para>
                <para>QAbstractSocket is the base class for QTcpSocket and QUdpSocket and contains all common functionality of these two classes. If you need a socket, you have two options:</para>
                <para>
                </para>
                <para>Instantiate QTcpSocket or QUdpSocket.</para>
                <para>Create a native socket descriptor, instantiate QAbstractSocket, and call setSocketDescriptor() to wrap the native socket.</para>
                <para>
                </para>
                <para>TCP (Transmission Control Protocol) is a reliable, stream-oriented, connection-oriented transport protocol. UDP (User Datagram Protocol) is an unreliable, datagram-oriented, connectionless protocol. In practice, this means that TCP is better suited for continuous transmission of data, whereas the more lightweight UDP can be used when reliability isn't important.</para>
                <para>QAbstractSocket's API unifies most of the differences between the two protocols. For example, although UDP is connectionless, connectToHost() establishes a virtual connection for UDP sockets, enabling you to use QAbstractSocket in more or less the same way regardless of the underlying protocol. Internally, QAbstractSocket remembers the address and port passed to connectToHost(), and functions like read() and write() use these values.</para>
                <para>At any time, QAbstractSocket has a state (returned by state()). The initial state is UnconnectedState. After calling connectToHost(), the socket first enters HostLookupState. If the host is found, QAbstractSocket enters ConnectingState and emits the hostFound() signal. When the connection has been established, it enters ConnectedState and emits connected(). If an error occurs at any stage, error() is emitted. Whenever the state changes, stateChanged() is emitted. For convenience, isValid() returns true if the socket is ready for reading and writing, but note that the socket's state must be ConnectedState before reading and writing can occur.</para>
                <para>Read or write data by calling read() or write(), or use the convenience functions readLine() and readAll(). QAbstractSocket also inherits getChar(), putChar(), and ungetChar() from QIODevice, which work on single bytes. The bytesWritten() signal is emitted when data has been written to the socket (i.e., when the client has read the data). Note that Qt does not limit the write buffer size. You can monitor its size by listening to this signal.</para>
                <para>The readyRead() signal is emitted every time a new chunk of data has arrived. bytesAvailable() then returns the number of bytes that are available for reading. Typically, you would connect the readyRead() signal to a slot and read all available data there. If you don't read all the data at once, the remaining data will still be available later, and any new incoming data will be appended to QAbstractSocket's internal read buffer. To limit the size of the read buffer, call setReadBufferSize().</para>
                <para>To close the socket, call disconnectFromHost(). QAbstractSocket enters QAbstractSocket::ClosingState. After all pending data has been written to the socket, QAbstractSocket actually closes the socket, enters QAbstractSocket::ClosedState, and emits disconnected(). If you want to abort a connection immediately, discarding all pending data, call abort() instead. If the remote host closes the connection, QAbstractSocket will emit error(QAbstractSocket::RemoteHostClosedError), during which the socket state will still be ConnectedState, and then the disconnected() signal will be emitted.</para>
                <para>The port and address of the connected peer is fetched by calling peerPort() and peerAddress(). peerName() returns the host name of the peer, as passed to connectToHost(). localPort() and localAddress() return the port and address of the local socket.</para>
                <para>QAbstractSocket provides a set of functions that suspend the calling thread until certain signals are emitted. These functions can be used to implement blocking sockets:</para>
                <para>
                </para>
                <para>waitForConnected() blocks until a connection has been established.</para>
                <para>waitForReadyRead() blocks until new data is available for reading.</para>
                <para>waitForBytesWritten() blocks until one payload of data has been written to the socket.</para>
                <para>waitForDisconnected() blocks until the connection has closed.</para>
                <para>
                </para>
                <para>We show an example:</para>
                <para>     int numRead = 0, numReadTotal = 0;</para>
                <para>     char buffer[50];</para>
                <para>
                </para>
                <para>     forever {</para>
                <para>         numRead  = socket.read(buffer, 50);</para>
                <para>
                </para>
                <para>         // do whatever with array</para>
                <para>
                </para>
                <para>         numReadTotal += numRead;</para>
                <para>         if (numRead == 0 &amp;&amp; !socket.waitForReadyRead())</para>
                <para>             break;</para>
                <para>     }</para>
                <para>If waitForReadyRead() returns false, the connection has been closed or an error has occurred.</para>
                <para>Programming with a blocking socket is radically different from programming with a non-blocking socket. A blocking socket doesn't require an event loop and typically leads to simpler code. However, in a GUI application, blocking sockets should only be used in non-GUI threads, to avoid freezing the user interface. See the network/fortuneclient and network/blockingfortuneclient examples for an overview of both approaches.</para>
                <para>Note: We discourage the use of the blocking functions together with signals. One of the two possibilities should be used.</para>
                <para>QAbstractSocket can be used with QTextStream and QDataStream's stream operators (operator&lt;&lt;() and operator&gt;&gt;()). There is one issue to be aware of, though: You must make sure that enough data is available before attempting to read it using operator&gt;&gt;().</para>
                <para>
                </para>
                <para>See also QFtp, QNetworkAccessManager, and QTcpServer.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.#ctor(QtNetwork.QAbstractSocket.SocketType,QtCore.QObject)">
            <summary>
                <para>Creates a new abstract socket of type socketType. The parent argument is passed to QObject's constructor.</para>
                <para>See also socketType(), QTcpSocket, and QUdpSocket.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QAbstractSocket.NetworkLayerProtocol">
            <summary>
                <para>This enum describes the network layer protocol values used in Qt.</para>
                <para>See also QHostAddress::protocol().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.NetworkLayerProtocol.IPv4Protocol">
            <summary>
                <para>IPv4</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.NetworkLayerProtocol.IPv6Protocol">
            <summary>
                <para>IPv6</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.NetworkLayerProtocol.UnknownNetworkLayerProtocol">
            <summary>
                <para>Other than IPv4 and IPv6</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QAbstractSocket.SocketError">
            <summary>
                <para>This enum describes the socket errors that can occur.</para>
                <para>See also QAbstractSocket::error().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.AddressInUseError">
            <summary>
                <para>The address specified to QUdpSocket::bind() is already in use and was set to be exclusive.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.ConnectionRefusedError">
            <summary>
                <para>The connection was refused by the peer (or timed out).</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.DatagramTooLargeError">
            <summary>
                <para>The datagram was larger than the operating system's limit (which can be as low as 8192 bytes).</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.HostNotFoundError">
            <summary>
                <para>The host address was not found.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.NetworkError">
            <summary>
                <para>An error occurred with the network (e.g., the network cable was accidentally plugged out).</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.ProxyAuthenticationRequiredError">
            <summary>
                <para>The socket is using a proxy, and the proxy requires authentication.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.ProxyConnectionClosedError">
            <summary>
                <para>The connection to the proxy server was closed unexpectedly (before the connection to the final peer was established) (This value was introduced in 4.5.)</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.ProxyConnectionRefusedError">
            <summary>
                <para>Could not contact the proxy server because the connection to that server was denied (This value was introduced in 4.5.)</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.ProxyConnectionTimeoutError">
            <summary>
                <para>The connection to the proxy server timed out or the proxy server stopped responding in the authentication phase. (This value was introduced in 4.5.)</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.ProxyNotFoundError">
            <summary>
                <para>The proxy address set with setProxy() (or the application proxy) was not found. (This value was introduced in 4.5.)</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.ProxyProtocolError">
            <summary>
                <para>The connection negotiation with the proxy server because the response from the proxy server could not be understood. (This value was introduced in 4.5.)</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.RemoteHostClosedError">
            <summary>
                <para>The remote host closed the connection. Note that the client socket (i.e., this socket) will be closed after the remote close notification has been sent.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.SocketAccessError">
            <summary>
                <para>The socket operation failed because the application lacked the required privileges.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.SocketAddressNotAvailableError">
            <summary>
                <para>The address specified to QUdpSocket::bind() does not belong to the host.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.SocketResourceError">
            <summary>
                <para>The local system ran out of resources (e.g., too many sockets).</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.SocketTimeoutError">
            <summary>
                <para>The socket operation timed out.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.SslHandshakeFailedError">
            <summary>
                <para>The SSL/TLS handshake failed, so the connection was closed (only used in QSslSocket) (This value was introduced in 4.4.)</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.UnfinishedSocketOperationError">
            <summary>
                <para>Used by QAbstractSocketEngine only, The last operation attempted has not finished yet (still in progress in the background). (This value was introduced in 4.4.)</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.UnknownSocketError">
            <summary>
                <para>An unidentified error occurred.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.UnsupportedSocketOperationError">
            <summary>
                <para>The requested socket operation is not supported by the local operating system (e.g., lack of IPv6 support).</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QAbstractSocket.SocketOption">
            <summary>
                <para>This enum represents the options that can be set on a socket. If desired, they can be set after having received the connected() signal from the socket or after having received a new socket from a QTcpServer.</para>
                <para>This enum was introduced or modified in Qt 4.6.</para>
                <para>See also QAbstractSocket::setSocketOption() and QAbstractSocket::socketOption().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketOption.KeepAliveOption">
            <summary>
                <para>Set this to 1 to enable the SO_KEEPALIVE socket option</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketOption.LowDelayOption">
            <summary>
                <para>Try to optimize the socket for low latency. For a QTcpSocket this would set the TCP_NODELAY option and disable Nagle's algorithm. Set this to 1 to enable.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketOption.MulticastLoopbackOption">
            <summary>
                <para>Set this to 1 to enable the IP_MULTICAST_LOOP (multicast loopback) socket option.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketOption.MulticastTtlOption">
            <summary>
                <para>Set this to an integer value to set IP_MULTICAST_TTL (TTL for multicast datagrams) socket option.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QAbstractSocket.SocketState">
            <summary>
                <para>This enum describes the different states in which a socket can be.</para>
                <para>See also QAbstractSocket::state().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketState.BoundState">
            <summary>
                <para>The socket is bound to an address and port (for servers).</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketState.ClosingState">
            <summary>
                <para>The socket is about to close (data may still be waiting to be written).</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketState.ConnectedState">
            <summary>
                <para>A connection is established.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketState.ConnectingState">
            <summary>
                <para>The socket has started establishing a connection.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketState.HostLookupState">
            <summary>
                <para>The socket is performing a host name lookup.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketState.ListeningState">
            <summary>
                <para>For internal use only.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketState.UnconnectedState">
            <summary>
                <para>The socket is not connected.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QAbstractSocket.SocketType">
            <summary>
                <para>This enum describes the transport layer protocol.</para>
                <para>See also QAbstractSocket::socketType().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketType.TcpSocket">
            <summary>
                <para>TCP</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketType.UdpSocket">
            <summary>
                <para>UDP</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketType.UnknownSocketType">
            <summary>
                <para>Other than TCP and UDP</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QAbstractSocket.HostFound">
            <summary>
                <para>This signal is emitted after connectToHost() has been called and the host lookup has succeeded.</para>
                <para>Note: Since Qt 4.6.3 QAbstractSocket may emit hostFound() directly from the connectToHost() call since a DNS result could have been cached.</para>
                <para>See also connected().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QAbstractSocket.Connected">
            <summary>
                <para>This signal is emitted after connectToHost() has been called and a connection has been successfully established.</para>
                <para>Note: On some operating systems the connected() signal may be directly emitted from the connectToHost() call for connections to the localhost.</para>
                <para>See also connectToHost() and disconnected().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QAbstractSocket.Disconnected">
            <summary>
                <para>This signal is emitted when the socket has been disconnected.</para>
                <para>Warning: If you need to delete the sender() of this signal in a slot connected to it, use the deleteLater() function.</para>
                <para>See also connectToHost(), disconnectFromHost(), and abort().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QAbstractSocket.StateChanged">
            <summary>
                <para>This signal is emitted whenever QAbstractSocket's state changes. The socketState parameter is the new state.</para>
                <para>QAbstractSocket::SocketState is not a registered metatype, so for queued connections, you will have to register it with Q_REGISTER_METATYPE() and qRegisterMetaType().</para>
                <para>See also state() and Creating Custom Qt Types.</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QAbstractSocket.ErrorSocketError">
            <summary>
                <para>This signal is emitted after an error occurred. The socketError parameter describes the type of error that occurred.</para>
                <para>QAbstractSocket::SocketError is not a registered metatype, so for queued connections, you will have to register it with Q_DECLARE_METATYPE() and qRegisterMetaType().</para>
                <para>See also error(), errorString(), and Creating Custom Qt Types.</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QAbstractSocket.ProxyAuthenticationRequired">
            <summary>
                <para>This signal can be emitted when a proxy that requires authentication is used. The authenticator object can then be filled in with the required details to allow authentication and continue the connection.</para>
                <para>Note: It is not possible to use a QueuedConnection to connect to this signal, as the connection will fail if the authenticator has not been filled in with new information when the signal returns.</para>
                <para>This function was introduced in Qt 4.3.</para>
                <para>See also QAuthenticator and QNetworkProxy.</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QAbstractSocket.ConnectionClosed">
            <summary>
                <para>Use disconnected() instead.</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QAbstractSocket.DelayedCloseFinished">
            <summary>
                <para>Use disconnected() instead.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAbstractSocket.LocalAddress">
            <summary>
                <para>Returns the host address of the local socket if available; otherwise returns QHostAddress::Null.</para>
                <para>This is normally the main IP address of the host, but can be QHostAddress::LocalHost (127.0.0.1) for connections to the local host.</para>
                <para>Sets the address on the local side of a connection to address.</para>
                <para>You can call this function in a subclass of QAbstractSocket to change the return value of the localAddress() function after a connection has been established. This feature is commonly used by proxy connections for virtual connection settings.</para>
                <para>Note that this function does not bind the local address of the socket prior to a connection (e.g., QUdpSocket::bind()).</para>
                <para>This function was introduced in Qt 4.1.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAbstractSocket.LocalPort">
            <summary>
                <para>Returns the host port number (in native byte order) of the local socket if available; otherwise returns 0.</para>
                <para>Sets the port on the local side of a connection to port.</para>
                <para>You can call this function in a subclass of QAbstractSocket to change the return value of the localPort() function after a connection has been established. This feature is commonly used by proxy connections for virtual connection settings.</para>
                <para>Note that this function does not bind the local port of the socket prior to a connection (e.g., QUdpSocket::bind()).</para>
                <para>This function was introduced in Qt 4.1.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAbstractSocket.PeerAddress">
            <summary>
                <para>Returns the address of the connected peer if the socket is in ConnectedState; otherwise returns QHostAddress::Null.</para>
                <para>Sets the address of the remote side of the connection to address.</para>
                <para>You can call this function in a subclass of QAbstractSocket to change the return value of the peerAddress() function after a connection has been established. This feature is commonly used by proxy connections for virtual connection settings.</para>
                <para>This function was introduced in Qt 4.1.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAbstractSocket.PeerName">
            <summary>
                <para>Returns the name of the peer as specified by connectToHost(), or an empty QString if connectToHost() has not been called.</para>
                <para>Sets the host name of the remote peer to name.</para>
                <para>You can call this function in a subclass of QAbstractSocket to change the return value of the peerName() function after a connection has been established. This feature is commonly used by proxy connections for virtual connection settings.</para>
                <para>This function was introduced in Qt 4.1.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAbstractSocket.PeerPort">
            <summary>
                <para>Returns the port of the connected peer if the socket is in ConnectedState; otherwise returns 0.</para>
                <para>Sets the port of the remote side of the connection to port.</para>
                <para>You can call this function in a subclass of QAbstractSocket to change the return value of the peerPort() function after a connection has been established. This feature is commonly used by proxy connections for virtual connection settings.</para>
                <para>This function was introduced in Qt 4.1.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAbstractSocket.Proxy">
            <summary>
                <para>Returns the network proxy for this socket. By default QNetworkProxy::DefaultProxy is used, which means this socket will query the default proxy settings for the application.</para>
                <para>This function was introduced in Qt 4.1.</para>
                <para>Sets the explicit network proxy for this socket to networkProxy.</para>
                <para>To disable the use of a proxy for this socket, use the QNetworkProxy::NoProxy proxy type:</para>
                <para> socket-&gt;setProxy(QNetworkProxy::NoProxy);</para>
                <para>The default value for the proxy is QNetworkProxy::DefaultProxy, which means the socket will use the application settings: if a proxy is set with QNetworkProxy::setApplicationProxy, it will use that; otherwise, if a factory is set with QNetworkProxyFactory::setApplicationProxyFactory, it will query that factory with type QNetworkProxyQuery::TcpSocket.</para>
                <para>This function was introduced in Qt 4.1.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAbstractSocket.ReadBufferSize">
            <summary>
                <para>Returns the size of the internal read buffer. This limits the amount of data that the client can receive before you call read() or readAll().</para>
                <para>A read buffer size of 0 (the default) means that the buffer has no size limit, ensuring that no data is lost.</para>
                <para>Sets the size of QAbstractSocket's internal read buffer to be size bytes.</para>
                <para>If the buffer size is limited to a certain size, QAbstractSocket won't buffer more than this size of data. Exceptionally, a buffer size of 0 means that the read buffer is unlimited and all incoming data is buffered. This is the default.</para>
                <para>This option is useful if you only read the data at certain points in time (e.g., in a real-time streaming application) or if you want to protect your socket against receiving too much data, which may eventually cause your application to run out of memory.</para>
                <para>Only QTcpSocket uses QAbstractSocket's internal buffer; QUdpSocket does not use any buffering at all, but rather relies on the implicit buffering provided by the operating system. Because of this, calling this function on QUdpSocket has no effect.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAbstractSocket.AtEnd">
            <summary>
                <para>Reimplemented from QIODevice::atEnd().</para>
                <para>Returns true if no more data is currently available for reading; otherwise returns false.</para>
                <para>This function is most commonly used when reading data from the socket in a loop. For example:</para>
                <para>  // This slot is connected to QAbstractSocket::readyRead()</para>
                <para>  void SocketClass::readyReadSlot()</para>
                <para>  {</para>
                <para>      while (!socket.atEnd()) {</para>
                <para>          QByteArray data = socket.read(100);</para>
                <para>          ....</para>
                <para>      }</para>
                <para>  }</para>
                <para>See also bytesAvailable() and readyRead().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAbstractSocket.BytesAvailable">
            <summary>
                <para>Reimplemented from QIODevice::bytesAvailable().</para>
                <para>Returns the number of incoming bytes that are waiting to be read.</para>
                <para>See also bytesToWrite() and read().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAbstractSocket.BytesToWrite">
            <summary>
                <para>Reimplemented from QIODevice::bytesToWrite().</para>
                <para>Returns the number of bytes that are waiting to be written. The bytes are written when control goes back to the event loop or when flush() is called.</para>
                <para>See also bytesAvailable() and flush().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAbstractSocket.CanReadLine">
            <summary>
                <para>Reimplemented from QIODevice::canReadLine().</para>
                <para>Returns true if a line of data can be read from the socket; otherwise returns false.</para>
                <para>See also readLine().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAbstractSocket.Flush">
            <summary>
                <para>This function writes as much as possible from the internal write buffer to the underlying network socket, without blocking. If any data was written, this function returns true; otherwise false is returned.</para>
                <para>Call this function if you need QAbstractSocket to start sending buffered data immediately. The number of bytes successfully written depends on the operating system. In most cases, you do not need to call this function, because QAbstractSocket will start sending data automatically once control goes back to the event loop. In the absence of an event loop, call waitForBytesWritten() instead.</para>
                <para>See also write() and waitForBytesWritten().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAbstractSocket.IsSequential">
            <summary>
                <para>Reimplemented from QIODevice::isSequential().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAbstractSocket.IsValid">
            <summary>
                <para>Returns true if the socket is valid and ready for use; otherwise returns false.</para>
                <para>Note: The socket's state must be ConnectedState before reading and writing can occur.</para>
                <para>See also state().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAbstractSocket.SocketDescriptor">
            <summary>
                <para>Returns the native socket descriptor of the QAbstractSocket object if this is available; otherwise returns -1.</para>
                <para>If the socket is using QNetworkProxy, the returned descriptor may not be usable with native socket functions.</para>
                <para>The socket descriptor is not available when QAbstractSocket is in UnconnectedState.</para>
                <para>See also setSocketDescriptor().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAbstractSocket.socketType">
            <summary>
                <para>Returns the socket type (TCP, UDP, or other).</para>
                <para>See also QTcpSocket and QUdpSocket.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAbstractSocket.State">
            <summary>
                <para>Returns the state of the socket.</para>
                <para>See also error().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.Abort">
            <summary>
                <para>Aborts the current connection and resets the socket. Unlike disconnectFromHost(), this function immediately closes the socket, discarding any pending data in the write buffer.</para>
                <para>See also disconnectFromHost() and close().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.Close">
            <summary>
                <para>Reimplemented from QIODevice::close().</para>
                <para>Closes the I/O device for the socket, disconnects the socket's connection with the host, closes the socket, and resets the name, address, port number and underlying socket descriptor.</para>
                <para>See QIODevice::close() for a description of the actions that occur when an I/O device is closed.</para>
                <para>See also abort().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.ConnectToHost(QtNetwork.QHostAddress,System.UInt16,QtCore.QIODevice.OpenModeFlag)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Attempts to make a connection to address on port port.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.ConnectToHost(System.String,System.UInt16,QtCore.QIODevice.OpenModeFlag)">
            <summary>
                <para>Attempts to make a connection to hostName on the given port.</para>
                <para>The socket is opened in the given openMode and first enters HostLookupState, then performs a host name lookup of hostName. If the lookup succeeds, hostFound() is emitted and QAbstractSocket enters ConnectingState. It then attempts to connect to the address or addresses returned by the lookup. Finally, if a connection is established, QAbstractSocket enters ConnectedState and emits connected().</para>
                <para>At any point, the socket can emit error() to signal that an error occurred.</para>
                <para>hostName may be an IP address in string form (e.g., "43.195.83.32"), or it may be a host name (e.g., "example.com"). QAbstractSocket will do a lookup only if required. port is in native byte order.</para>
                <para>See also state(), peerName(), peerAddress(), peerPort(), and waitForConnected().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.ConnectToHostImplementation(System.String,System.UInt16,QtCore.QIODevice.OpenModeFlag)">
            <summary>
                <para>Contains the implementation of connectToHost().</para>
                <para>Attempts to make a connection to hostName on the given port. The socket is opened in the given openMode.</para>
                <para>This function was introduced in Qt 4.1.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.OnConnected">
            <summary>
                <para>This signal is emitted after connectToHost() has been called and a connection has been successfully established.</para>
                <para>Note: On some operating systems the connected() signal may be directly emitted from the connectToHost() call for connections to the localhost.</para>
                <para>See also connectToHost() and disconnected().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.DisconnectFromHost">
            <summary>
                <para>Attempts to close the socket. If there is pending data waiting to be written, QAbstractSocket will enter ClosingState and wait until all data has been written. Eventually, it will enter UnconnectedState and emit the disconnected() signal.</para>
                <para>See also connectToHost().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.DisconnectFromHostImplementation">
            <summary>
                <para>Contains the implementation of disconnectFromHost().</para>
                <para>This function was introduced in Qt 4.1.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.OnDisconnected">
            <summary>
                <para>This signal is emitted when the socket has been disconnected.</para>
                <para>Warning: If you need to delete the sender() of this signal in a slot connected to it, use the deleteLater() function.</para>
                <para>See also connectToHost(), disconnectFromHost(), and abort().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.Error">
            <summary>
                <para>Returns the type of error that last occurred.</para>
                <para>See also state() and errorString().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.OnError(QtNetwork.QAbstractSocket.SocketError)">
            <summary>
                <para>This signal is emitted after an error occurred. The socketError parameter describes the type of error that occurred.</para>
                <para>QAbstractSocket::SocketError is not a registered metatype, so for queued connections, you will have to register it with Q_DECLARE_METATYPE() and qRegisterMetaType().</para>
                <para>See also error(), errorString(), and Creating Custom Qt Types.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.OnHostFound">
            <summary>
                <para>This signal is emitted after connectToHost() has been called and the host lookup has succeeded.</para>
                <para>Note: Since Qt 4.6.3 QAbstractSocket may emit hostFound() directly from the connectToHost() call since a DNS result could have been cached.</para>
                <para>See also connected().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.OnProxyAuthenticationRequired(QtNetwork.QNetworkProxy,QtNetwork.QAuthenticator)">
            <summary>
                <para>This signal can be emitted when a proxy that requires authentication is used. The authenticator object can then be filled in with the required details to allow authentication and continue the connection.</para>
                <para>Note: It is not possible to use a QueuedConnection to connect to this signal, as the connection will fail if the authenticator has not been filled in with new information when the signal returns.</para>
                <para>This function was introduced in Qt 4.3.</para>
                <para>See also QAuthenticator and QNetworkProxy.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.ReadData(QtCore.Pointer{System.SByte},System.Int64)">
            <summary>
                <para>Reimplemented from QIODevice::readData().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.ReadLineData(QtCore.Pointer{System.SByte},System.Int64)">
            <summary>
                <para>Reimplemented from QIODevice::readLineData().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.SetSocketDescriptor(System.Int32,QtNetwork.QAbstractSocket.SocketState,QtCore.QIODevice.OpenModeFlag)">
            <summary>
                <para>Initializes QAbstractSocket with the native socket descriptor socketDescriptor. Returns true if socketDescriptor is accepted as a valid socket descriptor; otherwise returns false. The socket is opened in the mode specified by openMode, and enters the socket state specified by socketState.</para>
                <para>Note: It is not possible to initialize two abstract sockets with the same native socket descriptor.</para>
                <para>See also socketDescriptor().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.SetSocketError(QtNetwork.QAbstractSocket.SocketError)">
            <summary>
                <para>Sets the type of error that last occurred to socketError.</para>
                <para>See also setSocketState() and setErrorString().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.SetSocketOption(QtNetwork.QAbstractSocket.SocketOption,System.Object)">
            <summary>
                <para>Sets the given option to the value described by value.</para>
                <para>This function was introduced in Qt 4.6.</para>
                <para>See also socketOption().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.SetSocketState(QtNetwork.QAbstractSocket.SocketState)">
            <summary>
                <para>Sets the state of the socket to state.</para>
                <para>See also state().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.socketOption(QtNetwork.QAbstractSocket.SocketOption)">
            <summary>
                <para>Returns the value of the option option.</para>
                <para>This function was introduced in Qt 4.6.</para>
                <para>See also setSocketOption().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.OnStateChanged(QtNetwork.QAbstractSocket.SocketState)">
            <summary>
                <para>This signal is emitted whenever QAbstractSocket's state changes. The socketState parameter is the new state.</para>
                <para>QAbstractSocket::SocketState is not a registered metatype, so for queued connections, you will have to register it with Q_REGISTER_METATYPE() and qRegisterMetaType().</para>
                <para>See also state() and Creating Custom Qt Types.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.WaitForBytesWritten(System.Int32)">
            <summary>
                <para>Reimplemented from QIODevice::waitForBytesWritten().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.WaitForConnected(System.Int32)">
            <summary>
                <para>Waits until the socket is connected, up to msecs milliseconds. If the connection has been established, this function returns true; otherwise it returns false. In the case where it returns false, you can call error() to determine the cause of the error.</para>
                <para>The following example waits up to one second for a connection to be established:</para>
                <para> socket-&gt;connectToHost("imap", 143);</para>
                <para> if (socket-&gt;waitForConnected(1000))</para>
                <para>     qDebug("Connected!");</para>
                <para>If msecs is -1, this function will not time out.</para>
                <para>Note: This function may wait slightly longer than msecs, depending on the time it takes to complete the host lookup.</para>
                <para>Note: Multiple calls to this functions do not accumulate the time. If the function times out, the connecting process will be aborted.</para>
                <para>See also connectToHost() and connected().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.WaitForDisconnected(System.Int32)">
            <summary>
                <para>Waits until the socket has disconnected, up to msecs milliseconds. If the connection has been disconnected, this function returns true; otherwise it returns false. In the case where it returns false, you can call error() to determine the cause of the error.</para>
                <para>The following example waits up to one second for a connection to be closed:</para>
                <para> socket-&gt;disconnectFromHost();</para>
                <para>     if (socket-&gt;state() == QAbstractSocket::UnconnectedState ||</para>
                <para>         socket-&gt;waitForDisconnected(1000))</para>
                <para>         qDebug("Disconnected!");</para>
                <para>If msecs is -1, this function will not time out.</para>
                <para>See also disconnectFromHost() and close().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.WaitForReadyRead(System.Int32)">
            <summary>
                <para>Reimplemented from QIODevice::waitForReadyRead().</para>
                <para>This function blocks until new data is available for reading and the readyRead() signal has been emitted. The function will timeout after msecs milliseconds; the default timeout is 30000 milliseconds.</para>
                <para>The function returns true if the readyRead() signal is emitted and there is new data available for reading; otherwise it returns false (if an error occurred or the operation timed out).</para>
                <para>See also waitForBytesWritten().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.WriteData(System.String,System.Int64)">
            <summary>
                <para>Reimplemented from QIODevice::writeData().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.Finalize">
            <summary>
                <para>Destroys the socket.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QAuthenticator">
            <summary>
            The QAuthenticator class provides an authentication object.
            </summary>
            <remarks>
                <para>
                </para>
                <para>The QAuthenticator class is usually used in the authenticationRequired() and proxyAuthenticationRequired() signals of QNetworkAccessManager and QAbstractSocket. The class provides a way to pass back the required authentication information to the socket when accessing services that require authentication.</para>
                <para>QAuthenticator supports the following authentication methods:</para>
                <para>
                </para>
                <para>Basic</para>
                <para>NTLM version 2</para>
                <para>Digest-MD5</para>
                <para>
                </para>
                <para>
                </para>
                <para>Options</para>
                <para>In addition to the username and password required for authentication, a QAuthenticator object can also contain additional options. The options() function can be used to query incoming options sent by the server; the setOption() function can be used to set outgoing options, to be processed by the authenticator calculation. The options accepted and provided depend on the authentication type (see method()).</para>
                <para>The following tables list known incoming options as well as accepted outgoing options. The list of incoming options is not exhaustive, since servers may include additional information at any time. The list of outgoing options is exhaustive, however, and no unknown options will be treated or sent back to the server.</para>
                <para>
                </para>
                <para>Basic</para>
                <para>
                </para>
                <para>OptionDirectionDescription</para>
                <para>realm	Incoming	Contains the realm of the authentication, the same as realm()</para>
                <para>
                </para>
                <para>The Basic authentication mechanism supports no outgoing options.</para>
                <para>
                </para>
                <para>NTLM version 2</para>
                <para>The NTLM authentication mechanism currently supports no incoming or outgoing options.</para>
                <para>
                </para>
                <para>Digest-MD5</para>
                <para>
                </para>
                <para>OptionDirectionDescription</para>
                <para>realm	Incoming	Contains the realm of the authentication, the same as realm()</para>
                <para>
                </para>
                <para>The Digest-MD5 authentication mechanism supports no outgoing options.</para>
                <para>
                </para>
                <para>See also QSslSocket.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QAuthenticator.#ctor">
            <summary>
                <para>Constructs an empty authentication object</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAuthenticator.#ctor(QtNetwork.QAuthenticator)">
            <summary>
                <para>Constructs a copy of other.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAuthenticator.Password">
            <summary>
                <para>returns the password used for authentication.</para>
                <para>Sets the password used for authentication.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAuthenticator.User">
            <summary>
                <para>returns the user used for authentication.</para>
                <para>Sets the user used for authentication.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAuthenticator.IsNull">
            <summary>
                <para>Returns true if the authenticator is null.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAuthenticator.Options">
            <summary>
                <para>Returns all incoming options set in this QAuthenticator object by parsing the server reply. See QAuthenticator#Options for more information on incoming options.</para>
                <para>This function was introduced in Qt 4.7.</para>
                <para>See also option() and QAuthenticator#Options.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAuthenticator.Realm">
            <summary>
                <para>returns the realm requiring authentication.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAuthenticator.Option(System.String)">
            <summary>
                <para>Returns the value related to option opt if it was set by the server. See QAuthenticator#Options for more information on incoming options. If option opt isn't found, an invalid QVariant will be returned.</para>
                <para>This function was introduced in Qt 4.7.</para>
                <para>See also setOption(), options(), and QAuthenticator#Options.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAuthenticator.SetOption(System.String,System.Object)">
            <summary>
                <para>Sets the outgoing option opt to value value. See QAuthenticator#Options for more information on outgoing options.</para>
                <para>This function was introduced in Qt 4.7.</para>
                <para>See also options(), option(), and QAuthenticator#Options.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAuthenticator.Finalize">
            <summary>
                <para>Destructs the object</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAuthenticator.op_Inequality(QtNetwork.QAuthenticator,QtNetwork.QAuthenticator)">
            <summary>
                <para>Returns true if this authenticator is different from other; otherwise returns false.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAuthenticator.op_Equality(QtNetwork.QAuthenticator,QtNetwork.QAuthenticator)">
            <summary>
                <para>Returns true if this authenticator is identical to other; otherwise returns false.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QFtp">
            <summary>
            The QFtp class provides an implementation of the client side of FTP protocol.
            </summary>
            <remarks>
                <para>
                </para>
                <para>This class provides a direct interface to FTP that allows you to have more control over the requests. However, for new applications, it is recommended to use QNetworkAccessManager and QNetworkReply, as those classes possess a simpler, yet more powerful API.</para>
                <para>The class works asynchronously, so there are no blocking functions. If an operation cannot be executed immediately, the function will still return straight away and the operation will be scheduled for later execution. The results of scheduled operations are reported via signals. This approach depends on the event loop being in operation.</para>
                <para>The operations that can be scheduled (they are called "commands" in the rest of the documentation) are the following: connectToHost(), login(), close(), list(), cd(), get(), put(), remove(), mkdir(), rmdir(), rename() and rawCommand().</para>
                <para>All of these commands return a unique identifier that allows you to keep track of the command that is currently being executed. When the execution of a command starts, the commandStarted() signal with the command's identifier is emitted. When the command is finished, the commandFinished() signal is emitted with the command's identifier and a bool that indicates whether the command finished with an error.</para>
                <para>In some cases, you might want to execute a sequence of commands, e.g. if you want to connect and login to a FTP server. This is simply achieved:</para>
                <para> QFtp *ftp = new QFtp(parent);</para>
                <para> ftp-&gt;connectToHost("ftp.qt.nokia.com");</para>
                <para> ftp-&gt;login();</para>
                <para>In this case two FTP commands have been scheduled. When the last scheduled command has finished, a done() signal is emitted with a bool argument that tells you whether the sequence finished with an error.</para>
                <para>If an error occurs during the execution of one of the commands in a sequence of commands, all the pending commands (i.e. scheduled, but not yet executed commands) are cleared and no signals are emitted for them.</para>
                <para>Some commands, e.g. list(), emit additional signals to report their results.</para>
                <para>Example: If you want to download the INSTALL file from the Qt FTP server, you would write this:</para>
                <para> ftp-&gt;connectToHost("ftp.qt.nokia.com");   // id == 1</para>
                <para> ftp-&gt;login();                             // id == 2</para>
                <para> ftp-&gt;cd("qt");                            // id == 3</para>
                <para> ftp-&gt;get("INSTALL");                      // id == 4</para>
                <para> ftp-&gt;close();                             // id == 5</para>
                <para>For this example the following sequence of signals is emitted (with small variations, depending on network traffic, etc.):</para>
                <para> start(1)</para>
                <para> stateChanged(HostLookup)</para>
                <para> stateChanged(Connecting)</para>
                <para> stateChanged(Connected)</para>
                <para> finished(1, false)</para>
                <para>
                </para>
                <para> start(2)</para>
                <para> stateChanged(LoggedIn)</para>
                <para> finished(2, false)</para>
                <para>
                </para>
                <para> start(3)</para>
                <para> finished(3, false)</para>
                <para>
                </para>
                <para> start(4)</para>
                <para> dataTransferProgress(0, 3798)</para>
                <para> dataTransferProgress(2896, 3798)</para>
                <para> readyRead()</para>
                <para> dataTransferProgress(3798, 3798)</para>
                <para> readyRead()</para>
                <para> finished(4, false)</para>
                <para>
                </para>
                <para> start(5)</para>
                <para> stateChanged(Closing)</para>
                <para> stateChanged(Unconnected)</para>
                <para> finished(5, false)</para>
                <para>
                </para>
                <para> done(false)</para>
                <para>The dataTransferProgress() signal in the above example is useful if you want to show a progress bar to inform the user about the progress of the download. The readyRead() signal tells you that there is data ready to be read. The amount of data can be queried then with the bytesAvailable() function and it can be read with the read() or readAll() function.</para>
                <para>If the login fails for the above example, the signals would look like this:</para>
                <para> start(1)</para>
                <para> stateChanged(HostLookup)</para>
                <para> stateChanged(Connecting)</para>
                <para> stateChanged(Connected)</para>
                <para> finished(1, false)</para>
                <para>
                </para>
                <para> start(2)</para>
                <para> finished(2, true)</para>
                <para>
                </para>
                <para> done(true)</para>
                <para>You can then get details about the error with the error() and errorString() functions.</para>
                <para>For file transfer, QFtp can use both active or passive mode, and it uses passive file transfer mode by default; see the documentation for setTransferMode() for more details about this.</para>
                <para>Call setProxy() to make QFtp connect via an FTP proxy server.</para>
                <para>The functions currentId() and currentCommand() provide more information about the currently executing command.</para>
                <para>The functions hasPendingCommands() and clearPendingCommands() allow you to query and clear the list of pending commands.</para>
                <para>If you are an experienced network programmer and want to have complete control you can use rawCommand() to execute arbitrary FTP commands.</para>
                <para>Warning: The current version of QFtp doesn't fully support non-Unix FTP servers.</para>
                <para>
                </para>
                <para>See also QNetworkAccessManager, QNetworkRequest, QNetworkReply, and FTP Example.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QFtp.#ctor(QtCore.QObject)">
            <summary>
                <para>Constructs a QFtp object with the given parent.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QFtp.Command">
            <summary>
                <para>This enum is used as the return value for the currentCommand() function. This allows you to perform specific actions for particular commands, e.g. in a FTP client, you might want to clear the directory view when a list() command is started; in this case you can simply check in the slot connected to the start() signal if the currentCommand() is List.</para>
                <para>See also currentCommand().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QFtp.Command.Cd">
            <summary>
                <para>Cd() is being executed.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QFtp.Command.Close">
            <summary>
                <para>Close() is being executed.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QFtp.Command.ConnectToHost">
            <summary>
                <para>ConnectToHost() is being executed.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QFtp.Command.Get">
            <summary>
                <para>Get() is being executed.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QFtp.Command.List">
            <summary>
                <para>List() is being executed.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QFtp.Command.Login">
            <summary>
                <para>Login() is being executed.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QFtp.Command.Mkdir">
            <summary>
                <para>Mkdir() is being executed.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QFtp.Command.None">
            <summary>
                <para>No command is being executed.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QFtp.Command.Put">
            <summary>
                <para>Put() is being executed.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QFtp.Command.RawCommand">
            <summary>
                <para>RawCommand() is being executed.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QFtp.Command.Remove">
            <summary>
                <para>Remove() is being executed.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QFtp.Command.Rename">
            <summary>
                <para>Rename() is being executed.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QFtp.Command.Rmdir">
            <summary>
                <para>Rmdir() is being executed.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QFtp.Command.SetProxy">
            <summary>
                <para>Switch proxying on or off.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QFtp.Command.SetTransferMode">
            <summary>
                <para>Set the transfer mode.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QFtp.Error">
            <summary>
                <para>This enum identifies the error that occurred.</para>
                <para>See also error().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QFtp.Error.ConnectionRefused">
            <summary>
                <para>The server refused the connection.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QFtp.Error.HostNotFound">
            <summary>
                <para>The host name lookup failed.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QFtp.Error.NoError">
            <summary>
                <para>No error occurred.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QFtp.Error.NotConnected">
            <summary>
                <para>Tried to send a command, but there is no connection to a server.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QFtp.Error.UnknownError">
            <summary>
                <para>An error other than those specified above occurred.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QFtp.State">
            <summary>
                <para>This enum defines the connection state:</para>
                <para>See also stateChanged() and state().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QFtp.State.Closing">
            <summary>
                <para>The connection is closing down, but it is not yet closed. (The state will be Unconnected when the connection is closed.)</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QFtp.State.Connected">
            <summary>
                <para>Connection to the host has been achieved.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QFtp.State.Connecting">
            <summary>
                <para>An attempt to connect to the host is in progress.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QFtp.State.HostLookup">
            <summary>
                <para>A host name lookup is in progress.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QFtp.State.LoggedIn">
            <summary>
                <para>Connection and user login have been achieved.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QFtp.State.Unconnected">
            <summary>
                <para>There is no connection to the host.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QFtp.TransferMode">
            <summary>
                <para>FTP works with two socket connections; one for commands and another for transmitting data. While the command connection is always initiated by the client, the second connection can be initiated by either the client or the server.</para>
                <para>This enum defines whether the client (Passive mode) or the server (Active mode) should set up the data connection.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QFtp.TransferMode.Active">
            <summary>
                <para>The server connects to the client to transmit its data.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QFtp.TransferMode.Passive">
            <summary>
                <para>The client connects to the server to transmit its data.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QFtp.TransferType">
            <summary>
                <para>This enum identifies the data transfer type used with get and put commands.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QFtp.TransferType.Ascii">
            <summary>
                <para>The data will be transferred in Ascii mode and new line characters will be converted to the local format.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QFtp.TransferType.Binary">
            <summary>
                <para>The data will be transferred in Binary mode.</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QFtp.StateChanged">
            <summary>
                <para>This signal is emitted when the state of the connection changes. The argument state is the new state of the connection; it is one of the State values.</para>
                <para>It is usually emitted in response to a connectToHost() or close() command, but it can also be emitted "spontaneously", e.g. when the server closes the connection unexpectedly.</para>
                <para>See also connectToHost(), close(), state(), and State.</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QFtp.ListInfo">
            <summary>
                <para>This signal is emitted for each directory entry the list() command finds. The details of the entry are stored in i.</para>
                <para>See also list().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QFtp.ReadyRead">
            <summary>
                <para>This signal is emitted in response to a get() command when there is new data to read.</para>
                <para>If you specify a device as the second argument in the get() command, this signal is not emitted; instead the data is written directly to the device.</para>
                <para>You can read the data with the readAll() or read() functions.</para>
                <para>This signal is useful if you want to process the data in chunks as soon as it becomes available. If you are only interested in the complete data, just connect to the commandFinished() signal and read the data then instead.</para>
                <para>See also get(), read(), readAll(), and bytesAvailable().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QFtp.DataTransferProgress">
            <summary>
                <para>This signal is emitted in response to a get() or put() request to indicate the current progress of the download or upload.</para>
                <para>done is the amount of data that has already been transferred and total is the total amount of data to be read or written. It is possible that the QFtp class is not able to determine the total amount of data that should be transferred, in which case total is 0. (If you connect this signal to a QProgressBar, the progress bar shows a busy indicator if the total is 0).</para>
                <para>Warning: done and total are not necessarily the size in bytes, since for large files these values might need to be "scaled" to avoid overflow.</para>
                <para>See also get(), put(), and QProgressBar.</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QFtp.RawCommandReply">
            <summary>
                <para>This signal is emitted in response to the rawCommand() function. replyCode is the 3 digit reply code and detail is the text that follows the reply code.</para>
                <para>See also rawCommand().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QFtp.CommandStarted">
            <summary>
                <para>This signal is emitted when processing the command identified by id starts.</para>
                <para>See also commandFinished() and done().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QFtp.CommandFinished">
            <summary>
                <para>This signal is emitted when processing the command identified by id has finished. error is true if an error occurred during the processing; otherwise error is false.</para>
                <para>See also commandStarted(), done(), error(), and errorString().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QFtp.Done">
            <summary>
                <para>This signal is emitted when the last pending command has finished; (it is emitted after the last command's commandFinished() signal). error is true if an error occurred during the processing; otherwise error is false.</para>
                <para>See also commandFinished(), error(), and errorString().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QFtp.BytesAvailable">
            <summary>
                <para>Returns the number of bytes that can be read from the data socket at the moment.</para>
                <para>See also get(), readyRead(), read(), and readAll().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QFtp.CurrentCommand">
            <summary>
                <para>Returns the command type of the FTP command being executed or None if there is no command being executed.</para>
                <para>See also currentId().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QFtp.CurrentDevice">
            <summary>
                <para>Returns the QIODevice pointer that is used by the FTP command to read data from or store data to. If there is no current FTP command being executed or if the command does not use an IO device, this function returns 0.</para>
                <para>This function can be used to delete the QIODevice in the slot connected to the commandFinished() signal.</para>
                <para>See also get() and put().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QFtp.CurrentId">
            <summary>
                <para>Returns the identifier of the FTP command that is being executed or 0 if there is no command being executed.</para>
                <para>See also currentCommand().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QFtp.error">
            <summary>
                <para>Returns the last error that occurred. This is useful to find out what went wrong when receiving a commandFinished() or a done() signal with the error argument set to true.</para>
                <para>If you start a new command, the error status is reset to NoError.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QFtp.ErrorString">
            <summary>
                <para>Returns a human-readable description of the last error that occurred. This is useful for presenting a error message to the user when receiving a commandFinished() or a done() signal with the error argument set to true.</para>
                <para>The error string is often (but not always) the reply from the server, so it is not always possible to translate the string. If the message comes from Qt, the string has already passed through tr().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QFtp.HasPendingCommands">
            <summary>
                <para>Returns true if there are any commands scheduled that have not yet been executed; otherwise returns false.</para>
                <para>The command that is being executed is not considered as a scheduled command.</para>
                <para>See also clearPendingCommands(), currentId(), and currentCommand().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QFtp.state">
            <summary>
                <para>Returns the current state of the object. When the state changes, the stateChanged() signal is emitted.</para>
                <para>See also State and stateChanged().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QFtp.Abort">
            <summary>
                <para>Aborts the current command and deletes all scheduled commands.</para>
                <para>If there is an unfinished command (i.e. a command for which the commandStarted() signal has been emitted, but for which the commandFinished() signal has not been emitted), this function sends an ABORT command to the server. When the server replies that the command is aborted, the commandFinished() signal with the error argument set to true is emitted for the command. Due to timing issues, it is possible that the command had already finished before the abort request reached the server, in which case, the commandFinished() signal is emitted with the error argument set to false.</para>
                <para>For all other commands that are affected by the abort(), no signals are emitted.</para>
                <para>If you don't start further FTP commands directly after the abort(), there won't be any scheduled commands and the done() signal is emitted.</para>
                <para>Warning: Some FTP servers, for example the BSD FTP daemon (version 0.3), wrongly return a positive reply even when an abort has occurred. For these servers the commandFinished() signal has its error flag set to false, even though the command did not complete successfully.</para>
                <para>See also clearPendingCommands().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QFtp.Cd(System.String)">
            <summary>
                <para>Changes the working directory of the server to dir.</para>
                <para>The function does not block and returns immediately. The command is scheduled, and its execution is performed asynchronously. The function returns a unique identifier which is passed by commandStarted() and commandFinished().</para>
                <para>When the command is started the commandStarted() signal is emitted. When it is finished the commandFinished() signal is emitted.</para>
                <para>See also commandStarted() and commandFinished().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QFtp.ClearPendingCommands">
            <summary>
                <para>Deletes all pending commands from the list of scheduled commands. This does not affect the command that is being executed. If you want to stop this as well, use abort().</para>
                <para>See also hasPendingCommands() and abort().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QFtp.Close">
            <summary>
                <para>Closes the connection to the FTP server.</para>
                <para>The stateChanged() signal is emitted when the state of the connecting process changes, e.g. to Closing, then Unconnected.</para>
                <para>The function does not block and returns immediately. The command is scheduled, and its execution is performed asynchronously. The function returns a unique identifier which is passed by commandStarted() and commandFinished().</para>
                <para>When the command is started the commandStarted() signal is emitted. When it is finished the commandFinished() signal is emitted.</para>
                <para>See also stateChanged(), commandStarted(), and commandFinished().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QFtp.OnCommandFinished(System.Int32,System.Boolean)">
            <summary>
                <para>This signal is emitted when processing the command identified by id has finished. error is true if an error occurred during the processing; otherwise error is false.</para>
                <para>See also commandStarted(), done(), error(), and errorString().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QFtp.OnCommandStarted(System.Int32)">
            <summary>
                <para>This signal is emitted when processing the command identified by id starts.</para>
                <para>See also commandFinished() and done().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QFtp.ConnectToHost(System.String,System.UInt16)">
            <summary>
                <para>Connects to the FTP server host using port port.</para>
                <para>The stateChanged() signal is emitted when the state of the connecting process changes, e.g. to HostLookup, then Connecting, then Connected.</para>
                <para>The function does not block and returns immediately. The command is scheduled, and its execution is performed asynchronously. The function returns a unique identifier which is passed by commandStarted() and commandFinished().</para>
                <para>When the command is started the commandStarted() signal is emitted. When it is finished the commandFinished() signal is emitted.</para>
                <para>See also stateChanged(), commandStarted(), and commandFinished().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QFtp.OnDataTransferProgress(System.Int64,System.Int64)">
            <summary>
                <para>This signal is emitted in response to a get() or put() request to indicate the current progress of the download or upload.</para>
                <para>done is the amount of data that has already been transferred and total is the total amount of data to be read or written. It is possible that the QFtp class is not able to determine the total amount of data that should be transferred, in which case total is 0. (If you connect this signal to a QProgressBar, the progress bar shows a busy indicator if the total is 0).</para>
                <para>Warning: done and total are not necessarily the size in bytes, since for large files these values might need to be "scaled" to avoid overflow.</para>
                <para>See also get(), put(), and QProgressBar.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QFtp.OnDone(System.Boolean)">
            <summary>
                <para>This signal is emitted when the last pending command has finished; (it is emitted after the last command's commandFinished() signal). error is true if an error occurred during the processing; otherwise error is false.</para>
                <para>See also commandFinished(), error(), and errorString().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QFtp.Get(System.String,QtCore.QIODevice,QtNetwork.QFtp.TransferType)">
            <summary>
                <para>Downloads the file file from the server.</para>
                <para>If dev is 0, then the readyRead() signal is emitted when there is data available to read. You can then read the data with the read() or readAll() functions.</para>
                <para>If dev is not 0, the data is written directly to the device dev. Make sure that the dev pointer is valid for the duration of the operation (it is safe to delete it when the commandFinished() signal is emitted). In this case the readyRead() signal is not emitted and you cannot read data with the read() or readAll() functions.</para>
                <para>If you don't read the data immediately it becomes available, i.e. when the readyRead() signal is emitted, it is still available until the next command is started.</para>
                <para>For example, if you want to present the data to the user as soon as there is something available, connect to the readyRead() signal and read the data immediately. On the other hand, if you only want to work with the complete data, you can connect to the commandFinished() signal and read the data when the get() command is finished.</para>
                <para>The data is transferred as Binary or Ascii depending on the value of type.</para>
                <para>The function does not block and returns immediately. The command is scheduled, and its execution is performed asynchronously. The function returns a unique identifier which is passed by commandStarted() and commandFinished().</para>
                <para>When the command is started the commandStarted() signal is emitted. When it is finished the commandFinished() signal is emitted.</para>
                <para>commandFinished()</para>
                <para>See also readyRead(), dataTransferProgress(), and commandStarted().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QFtp.List(System.String)">
            <summary>
                <para>Lists the contents of directory dir on the FTP server. If dir is empty, it lists the contents of the current directory.</para>
                <para>The listInfo() signal is emitted for each directory entry found.</para>
                <para>The function does not block and returns immediately. The command is scheduled, and its execution is performed asynchronously. The function returns a unique identifier which is passed by commandStarted() and commandFinished().</para>
                <para>When the command is started the commandStarted() signal is emitted. When it is finished the commandFinished() signal is emitted.</para>
                <para>See also listInfo(), commandStarted(), and commandFinished().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QFtp.OnListInfo(QtNetwork.QUrlInfo)">
            <summary>
                <para>This signal is emitted for each directory entry the list() command finds. The details of the entry are stored in i.</para>
                <para>See also list().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QFtp.Login(System.String,System.String)">
            <summary>
                <para>Logs in to the FTP server with the username user and the password password.</para>
                <para>The stateChanged() signal is emitted when the state of the connecting process changes, e.g. to LoggedIn.</para>
                <para>The function does not block and returns immediately. The command is scheduled, and its execution is performed asynchronously. The function returns a unique identifier which is passed by commandStarted() and commandFinished().</para>
                <para>When the command is started the commandStarted() signal is emitted. When it is finished the commandFinished() signal is emitted.</para>
                <para>See also commandStarted() and commandFinished().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QFtp.Mkdir(System.String)">
            <summary>
                <para>Creates a directory called dir on the server.</para>
                <para>The function does not block and returns immediately. The command is scheduled, and its execution is performed asynchronously. The function returns a unique identifier which is passed by commandStarted() and commandFinished().</para>
                <para>When the command is started the commandStarted() signal is emitted. When it is finished the commandFinished() signal is emitted.</para>
                <para>See also commandStarted() and commandFinished().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QFtp.Put(QtCore.QByteArray,System.String,QtNetwork.QFtp.TransferType)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Writes a copy of the given data to the file called file on the server. The progress of the upload is reported by the dataTransferProgress() signal.</para>
                <para>The data is transferred as Binary or Ascii depending on the value of type.</para>
                <para>The function does not block and returns immediately. The command is scheduled, and its execution is performed asynchronously. The function returns a unique identifier which is passed by commandStarted() and commandFinished().</para>
                <para>When the command is started the commandStarted() signal is emitted. When it is finished the commandFinished() signal is emitted.</para>
                <para>Since this function takes a copy of the data, you can discard your own copy when this function returns.</para>
                <para>See also dataTransferProgress(), commandStarted(), and commandFinished().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QFtp.Put(QtCore.QIODevice,System.String,QtNetwork.QFtp.TransferType)">
            <summary>
                <para>Reads the data from the IO device dev, and writes it to the file called file on the server. The data is read in chunks from the IO device, so this overload allows you to transmit large amounts of data without the need to read all the data into memory at once.</para>
                <para>The data is transferred as Binary or Ascii depending on the value of type.</para>
                <para>Make sure that the dev pointer is valid for the duration of the operation (it is safe to delete it when the commandFinished() is emitted).</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QFtp.RawCommand(System.String)">
            <summary>
                <para>Sends the raw FTP command command to the FTP server. This is useful for low-level FTP access. If the operation you wish to perform has an equivalent QFtp function, we recommend using the function instead of raw FTP commands since the functions are easier and safer.</para>
                <para>The function does not block and returns immediately. The command is scheduled, and its execution is performed asynchronously. The function returns a unique identifier which is passed by commandStarted() and commandFinished().</para>
                <para>When the command is started the commandStarted() signal is emitted. When it is finished the commandFinished() signal is emitted.</para>
                <para>See also rawCommandReply(), commandStarted(), and commandFinished().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QFtp.OnRawCommandReply(System.Int32,System.String)">
            <summary>
                <para>This signal is emitted in response to the rawCommand() function. replyCode is the 3 digit reply code and detail is the text that follows the reply code.</para>
                <para>See also rawCommand().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QFtp.Read(QtCore.Pointer{System.SByte},System.Int64)">
            <summary>
                <para>Reads maxlen bytes from the data socket into data and returns the number of bytes read. Returns -1 if an error occurred.</para>
                <para>See also get(), readyRead(), bytesAvailable(), and readAll().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QFtp.ReadAll">
            <summary>
                <para>Reads all the bytes available from the data socket and returns them.</para>
                <para>See also get(), readyRead(), bytesAvailable(), and read().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QFtp.OnReadyRead">
            <summary>
                <para>This signal is emitted in response to a get() command when there is new data to read.</para>
                <para>If you specify a device as the second argument in the get() command, this signal is not emitted; instead the data is written directly to the device.</para>
                <para>You can read the data with the readAll() or read() functions.</para>
                <para>This signal is useful if you want to process the data in chunks as soon as it becomes available. If you are only interested in the complete data, just connect to the commandFinished() signal and read the data then instead.</para>
                <para>See also get(), read(), readAll(), and bytesAvailable().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QFtp.Remove(System.String)">
            <summary>
                <para>Deletes the file called file from the server.</para>
                <para>The function does not block and returns immediately. The command is scheduled, and its execution is performed asynchronously. The function returns a unique identifier which is passed by commandStarted() and commandFinished().</para>
                <para>When the command is started the commandStarted() signal is emitted. When it is finished the commandFinished() signal is emitted.</para>
                <para>See also commandStarted() and commandFinished().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QFtp.Rename(System.String,System.String)">
            <summary>
                <para>Renames the file called oldname to newname on the server.</para>
                <para>The function does not block and returns immediately. The command is scheduled, and its execution is performed asynchronously. The function returns a unique identifier which is passed by commandStarted() and commandFinished().</para>
                <para>When the command is started the commandStarted() signal is emitted. When it is finished the commandFinished() signal is emitted.</para>
                <para>See also commandStarted() and commandFinished().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QFtp.Rmdir(System.String)">
            <summary>
                <para>Removes the directory called dir from the server.</para>
                <para>The function does not block and returns immediately. The command is scheduled, and its execution is performed asynchronously. The function returns a unique identifier which is passed by commandStarted() and commandFinished().</para>
                <para>When the command is started the commandStarted() signal is emitted. When it is finished the commandFinished() signal is emitted.</para>
                <para>See also commandStarted() and commandFinished().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QFtp.SetProxy(System.String,System.UInt16)">
            <summary>
                <para>Enables use of the FTP proxy on host host and port port. Calling this function with host empty disables proxying.</para>
                <para>QFtp does not support FTP-over-HTTP proxy servers. Use QNetworkAccessManager for this.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QFtp.SetTransferMode(QtNetwork.QFtp.TransferMode)">
            <summary>
                <para>Sets the current FTP transfer mode to mode. The default is QFtp::Passive.</para>
                <para>See also QFtp::TransferMode.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QFtp.OnStateChanged(System.Int32)">
            <summary>
                <para>This signal is emitted when the state of the connection changes. The argument state is the new state of the connection; it is one of the State values.</para>
                <para>It is usually emitted in response to a connectToHost() or close() command, but it can also be emitted "spontaneously", e.g. when the server closes the connection unexpectedly.</para>
                <para>See also connectToHost(), close(), state(), and State.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QFtp.Finalize">
            <summary>
                <para>Destructor.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.Global.QVersion">
            <summary>
                <para>Returns the version number of Qt at run-time as a string (for example, "4.1.2"). This may be a different version than the version the application was compiled against.</para>
                <para>See also QT_VERSION_STR.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.Global.Qrand">
            <summary>
                <para>Thread-safe version of the standard C++ rand() function.</para>
                <para>Returns a value between 0 and RAND_MAX (defined in &lt;cstdlib&gt; and &lt;stdlib.h&gt;), the next number in the current sequence of pseudo-random integers.</para>
                <para>Use qsrand() to initialize the pseudo-random number generator with a seed value.</para>
                <para>This function was introduced in Qt 4.2.</para>
                <para>See also qsrand().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.Write(QtCore.QDataStream,QtNetwork.QHostAddress)">
            <summary>
                <para>Writes host address address to the stream out and returns a reference to the stream.</para>
                <para>See also Serializing Qt Data Types.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.Write(QtCore.QDataStream,QtNetwork.QNetworkCacheMetaData)">
            <summary>
                <para>Writes metaData to the out stream.</para>
                <para>This function was introduced in Qt 4.5.</para>
                <para>See also Serializing Qt Data Types.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.Write(QtCore.QDataStream,System.Collections.Generic.List{System.String})">
            <summary>
                <para>Writes the given string list to the specified out stream.</para>
                <para>See also Serializing Qt Data Types.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.Read(QtCore.QDataStream,QtNetwork.QHostAddress)">
            <summary>
                <para>Reads a host address into address from the stream in and returns a reference to the stream.</para>
                <para>See also Serializing Qt Data Types.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.Read(QtCore.QDataStream,QtNetwork.QNetworkCacheMetaData)">
            <summary>
                <para>Reads a QNetworkCacheMetaData from the stream in into metaData.</para>
                <para>This function was introduced in Qt 4.5.</para>
                <para>See also Serializing Qt Data Types.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.Read(QtCore.QDataStream,System.Collections.Generic.List{System.String})">
            <summary>
                <para>Reads a string list from the given in stream into the specified list.</para>
                <para>See also Serializing Qt Data Types.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.QAcos(System.Double)">
            <summary>
                <para>Returns the arccosine of v as an angle in radians. Arccosine is the inverse operation of cosine.</para>
                <para>See also qAtan(), qAsin(), and qCos().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.QAsin(System.Double)">
            <summary>
                <para>Returns the arcsine of v as an angle in radians. Arcsine is the inverse operation of sine.</para>
                <para>See also qSin(), qAtan(), and qAcos().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.QAtan(System.Double)">
            <summary>
                <para>Returns the arctangent of v as an angle in radians. Arctangent is the inverse operation of tangent.</para>
                <para>See also qTan(), qAcos(), and qAsin().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.QAtan2(System.Double,System.Double)">
            <summary>
                <para>Returns the arctangent of a point specified by the coordinates x and y. This function will return the angle and its direction.</para>
                <para>See also qAtan().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.QCeil(System.Double)">
            <summary>
                <para>Return the ceiling of the value v.</para>
                <para>The ceiling is the smallest integer that is not less than v. For example, if v is 41.2, then the ceiling is 42.</para>
                <para>See also qFloor().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.QCos(System.Double)">
            <summary>
                <para>Returns the cosine of an angle v in radians.</para>
                <para>See also qSin() and qTan().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.QExp(System.Double)">
            <summary>
                <para>Returns the exponential function of e to the power of v.</para>
                <para>See also qLn().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.QFloor(System.Double)">
            <summary>
                <para>Return the floor of the value v.</para>
                <para>The floor is the largest integer that is not greater than v. For example, if v is 41.2, then the floor is 41.</para>
                <para>See also qCeil().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.QFuzzyCompare(System.Double,System.Double)">
            <summary>
                <para>Compares the floating point value p1 and p2 and returns true if they are considered equal, otherwise false.</para>
                <para>Note that comparing values where either p1 or p2 is 0.0 will not work. The solution to this is to compare against values greater than or equal to 1.0.</para>
                <para>         // Instead of comparing with 0.0</para>
                <para>                 qFuzzyCompare(0.0,1.0e-200); // This will return false</para>
                <para>         // Compare adding 1 to both values will fix the problem</para>
                <para>                 qFuzzyCompare(1 + 0.0, 1 + 1.0e-200); // This will return true</para>
                <para>The two numbers are compared in a relative way, where the exactness is stronger the smaller the numbers are.</para>
                <para>Note: This function is thread-safe.</para>
                <para>This function was introduced in Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.QFuzzyCompare(System.Single,System.Single)">
            <summary>
                <para>Compares the floating point value p1 and p2 and returns true if they are considered equal, otherwise false.</para>
                <para>The two numbers are compared in a relative way, where the exactness is stronger the smaller the numbers are.</para>
                <para>Note: This function is thread-safe.</para>
                <para>This function was introduced in Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.QHash(QtCore.QBitArray)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.QHash(QtCore.QChar)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.QHash(QtCore.QByteArray)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.QHash(System.UInt32)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.QHash(System.Char)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.QHash(System.Byte)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.QHash(System.Int16)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.QHash(NativeLong)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.QHash(System.UInt16)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.QHash(System.Int64)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.QHash(System.UInt64)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.QHash(System.Int32)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.QHash(System.String)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.QHash(NativeULong)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.QInstallMsgHandler(QtNetwork.Global.ActionQtMsgTypeString)">
            <summary>
                <para>Installs a Qt message handler which has been defined previously. Returns a pointer to the previous message handler (which may be 0).</para>
                <para>The message handler is a function that prints out debug messages, warnings, critical and fatal error messages. The Qt library (debug mode) contains hundreds of warning messages that are printed when internal errors (usually invalid function arguments) occur. Qt built in release mode also contains such warnings unless QT_NO_WARNING_OUTPUT and/or QT_NO_DEBUG_OUTPUT have been set during compilation. If you implement your own message handler, you get total control of these messages.</para>
                <para>The default message handler prints the message to the standard output under X11 or to the debugger under Windows. If it is a fatal message, the application aborts immediately.</para>
                <para>Only one message handler can be defined, since this is usually done on an application-wide basis to control debug output.</para>
                <para>To restore the message handler, call qInstallMsgHandler(0).</para>
                <para>Example:</para>
                <para> #include &lt;qapplication.h&gt;</para>
                <para> #include &lt;stdio.h&gt;</para>
                <para> #include &lt;stdlib.h&gt;</para>
                <para>
                </para>
                <para> void myMessageOutput(QtMsgType type, const char *msg)</para>
                <para> {</para>
                <para>     switch (type) {</para>
                <para>     case QtDebugMsg:</para>
                <para>         fprintf(stderr, "Debug: %s\\n", msg);</para>
                <para>         break;</para>
                <para>     case QtWarningMsg:</para>
                <para>         fprintf(stderr, "Warning: %s\\n", msg);</para>
                <para>         break;</para>
                <para>     case QtCriticalMsg:</para>
                <para>         fprintf(stderr, "Critical: %s\\n", msg);</para>
                <para>         break;</para>
                <para>     case QtFatalMsg:</para>
                <para>         fprintf(stderr, "Fatal: %s\\n", msg);</para>
                <para>         abort();</para>
                <para>     }</para>
                <para> }</para>
                <para>
                </para>
                <para> int main(int argc, char **argv)</para>
                <para> {</para>
                <para>     qInstallMsgHandler(myMessageOutput);</para>
                <para>     QApplication app(argc, argv);</para>
                <para>     ...</para>
                <para>     return app.exec();</para>
                <para> }</para>
                <para>See also qDebug(), qWarning(), qCritical(), qFatal(), QtMsgType, and Debugging Techniques.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.QLn(System.Double)">
            <summary>
                <para>Returns the natural logarithm of v. Natural logarithm uses base e.</para>
                <para>See also qExp().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.QPow(System.Double,System.Double)">
            <summary>
                <para>Returns the value of x raised to the power of y. That is, x is the base and y is the exponent.</para>
                <para>See also qSqrt().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.QRound(System.Double)">
            <summary>
                <para>Rounds value to the nearest integer.</para>
                <para>Example:</para>
                <para> qreal valueA = 2.3;</para>
                <para> qreal valueB = 2.7;</para>
                <para>
                </para>
                <para> int roundedValueA = qRound(valueA);</para>
                <para> // roundedValueA = 2</para>
                <para> int roundedValueB = qRound(valueB);</para>
                <para> // roundedValueB = 3</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.QRound64(System.Double)">
            <summary>
                <para>Rounds value to the nearest 64-bit integer.</para>
                <para>Example:</para>
                <para> qreal valueA = 42949672960.3;</para>
                <para> qreal valueB = 42949672960.7;</para>
                <para>
                </para>
                <para> int roundedValueA = qRound(valueA);</para>
                <para> // roundedValueA = 42949672960</para>
                <para> int roundedValueB = qRound(valueB);</para>
                <para> // roundedValueB = 42949672961</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.QSin(System.Double)">
            <summary>
                <para>Returns the sine of the angle v in radians.</para>
                <para>See also qCos() and qTan().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.QSqrt(System.Double)">
            <summary>
                <para>Returns the square root of v. This function returns a NaN if v is a negative number.</para>
                <para>See also qPow().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.QTan(System.Double)">
            <summary>
                <para>Returns the tangent of an angle v in radians.</para>
                <para>See also qSin() and qCos().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.Qgetenv(System.String)">
            <summary>
                <para>Returns the value of the environment variable with name varName. To get the variable string, use QByteArray::constData().</para>
                <para>Note: qgetenv() was introduced because getenv() from the standard C library was deprecated in VC2005 (and later versions). qgetenv() uses the new replacement function in VC, and calls the standard C library's implementation on all other platforms.</para>
                <para>See also qputenv().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.Qputenv(System.String,QtCore.QByteArray)">
            <summary>
                <para>This function sets the value of the environment variable named varName. It will create the variable if it does not exist. It returns 0 if the variable could not be set.</para>
                <para>Note: qputenv() was introduced because putenv() from the standard C library was deprecated in VC2005 (and later versions). qputenv() uses the replacement function in VC, and calls the standard C library's implementation on all other platforms.</para>
                <para>See also qgetenv().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.Qsrand(System.UInt32)">
            <summary>
                <para>Thread-safe version of the standard C++ srand() function.</para>
                <para>Sets the argument seed to be used to generate a new random number sequence of pseudo random integers to be returned by qrand().</para>
                <para>The sequence of random numbers generated is deterministic per thread. For example, if two threads call qsrand(1) and subsequently calls qrand(), the threads will get the same random number sequence.</para>
                <para>This function was introduced in Qt 4.2.</para>
                <para>See also qrand().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.Global.QtTrId(System.String,System.Int32)">
            <summary>
                <para>The qtTrId function finds and returns a translated string.</para>
                <para>Returns a translated string identified by id. If no matching string is found, the id itself is returned. This should not happen under normal conditions.</para>
                <para>If n &gt;= 0, all occurrences of %n in the resulting string are replaced with a decimal representation of n. In addition, depending on n's value, the translation text may vary.</para>
                <para>Meta data and comments can be passed as documented for QObject::tr(). In addition, it is possible to supply a source string template like that:</para>
                <para>//% &lt;C string&gt;</para>
                <para>or</para>
                <para>/*% &lt;C string&gt; */</para>
                <para>Example:</para>
                <para>     //% "%n fooish bar(s) found.\\n"</para>
                <para>     //% "Do you want to continue?"</para>
                <para>     QString text = qtTrId("qtn_foo_bar", n);</para>
                <para>Creating QM files suitable for use with this function requires passing the -idbased option to the lrelease tool.</para>
                <para>Warning: This method is reentrant only if all translators are installed before calling this method. Installing or removing translators while performing translations is not supported. Doing so will probably result in crashes or other undesirable behavior.</para>
                <para>Note: This function is reentrant.</para>
                <para>This function was introduced in Qt 4.6.</para>
                <para>See also QObject::tr(), QCoreApplication::translate(), and Internationalization with Qt.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QHostAddress">
            <summary>
            The QHostAddress class provides an IP address.
            </summary>
            <remarks>
                <para>
                </para>
                <para>This class holds an IPv4 or IPv6 address in a platform- and protocol-independent manner.</para>
                <para>QHostAddress is normally used with the QTcpSocket, QTcpServer, and QUdpSocket to connect to a host or to set up a server.</para>
                <para>A host address is set with setAddress(), and retrieved with toIPv4Address(), toIPv6Address(), or toString(). You can check the type with protocol().</para>
                <para>Note: Please note that QHostAddress does not do DNS lookups. QHostInfo is needed for that.</para>
                <para>The class also supports common predefined addresses: Null, LocalHost, LocalHostIPv6, Broadcast, and Any.</para>
                <para>
                </para>
                <para>See also QHostInfo, QTcpSocket, QTcpServer, and QUdpSocket.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QHostAddress.#ctor">
            <summary>
                <para>Constructs a host address object with the IP address 0.0.0.0.</para>
                <para>See also clear().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.#ctor(QtNetwork.QIPv6Address)">
            <summary>
                <para>Constructs a host address object with the IPv6 address ip6Addr.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.#ctor(QtNetwork.QHostAddress)">
            <summary>
                <para>Constructs a copy of the given address.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.#ctor(System.UInt32)">
            <summary>
                <para>Constructs a host address object with the IPv4 address ip4Addr.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.#ctor(QtCore.Pointer{System.Byte})">
            <summary>
                <para>Constructs a host address object with the IPv6 address ip6Addr.</para>
                <para>ip6Addr must be a 16-byte array in network byte order (big endian).</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.#ctor(System.String)">
            <summary>
                <para>Constructs an IPv4 or IPv6 address based on the string address (e.g., "127.0.0.1").</para>
                <para>See also setAddress().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.#ctor(QtNetwork.QHostAddress.SpecialAddress)">
            <summary>
                <para>Constructs a QHostAddress object for address.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QHostAddress.SpecialAddress.Any">
            <summary>
                <para>The IPv4 any-address. Equivalent to QHostAddress("0.0.0.0").</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QHostAddress.SpecialAddress.AnyIPv6">
            <summary>
                <para>The IPv6 any-address. Equivalent to QHostAddress("::").</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QHostAddress.SpecialAddress.Broadcast">
            <summary>
                <para>The IPv4 broadcast address. Equivalent to QHostAddress("255.255.255.255").</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QHostAddress.SpecialAddress.LocalHost">
            <summary>
                <para>The IPv4 localhost address. Equivalent to QHostAddress("127.0.0.1").</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QHostAddress.SpecialAddress.LocalHostIPv6">
            <summary>
                <para>The IPv6 localhost address. Equivalent to QHostAddress("::1").</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QHostAddress.SpecialAddress.Null">
            <summary>
                <para>The null address object. Equivalent to QHostAddress().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHostAddress.ScopeId">
            <summary>
                <para>Returns the scope ID of an IPv6 address. For IPv4 addresses, or if the address does not contain a scope ID, an empty QString is returned.</para>
                <para>The IPv6 scope ID specifies the scope of reachability for non-global IPv6 addresses, limiting the area in which the address can be used. All IPv6 addresses are associated with such a reachability scope. The scope ID is used to disambiguate addresses that are not guaranteed to be globally unique.</para>
                <para>IPv6 specifies the following four levels of reachability:</para>
                <para>
                </para>
                <para>Node-local: Addresses that are only used for communicating with services on the same interface (e.g., the loopback interface "::1").</para>
                <para>Link-local: Addresses that are local to the network interface (link). There is always one link-local address for each IPv6 interface on your host. Link-local addresses ("fe80...") are generated from the MAC address of the local network adaptor, and are not guaranteed to be unique.</para>
                <para>Site-local: Addresses that are local to the site / private network (e.g., the company intranet). Site-local addresses ("fec0...") are usually distributed by the site router, and are not guaranteed to be unique outside of the local site.</para>
                <para>Global: For globally routable addresses, such as public servers on the Internet.</para>
                <para>
                </para>
                <para>When using a link-local or site-local address for IPv6 connections, you must specify the scope ID. The scope ID for a link-local address is usually the same as the interface name (e.g., "eth0", "en1") or number (e.g., "1", "2").</para>
                <para>This function was introduced in Qt 4.1.</para>
                <para>Sets the IPv6 scope ID of the address to id. If the address protocol is not IPv6, this function does nothing.</para>
                <para>This function was introduced in Qt 4.1.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHostAddress.IsNull">
            <summary>
                <para>Returns true if this host address is null (INADDR_ANY or in6addr_any). The default constructor creates a null address, and that address is not valid for any host or interface.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHostAddress.Protocol">
            <summary>
                <para>Returns the network layer protocol of the host address.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.Clear">
            <summary>
                <para>Sets the host address to 0.0.0.0.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.IsInSubnet(QtNetwork.QHostAddress,System.Int32)">
            <summary>
                <para>Returns true if this IP is in the subnet described by the network prefix subnet and netmask netmask.</para>
                <para>An IP is considered to belong to a subnet if it is contained between the lowest and the highest address in that subnet. In the case of IP version 4, the lowest address is the network address, while the highest address is the broadcast address.</para>
                <para>The subnet argument does not have to be the actual network address (the lowest address in the subnet). It can be any valid IP belonging to that subnet. In particular, if it is equal to the IP address held by this object, this function will always return true (provided the netmask is a valid value).</para>
                <para>This function was introduced in Qt 4.5.</para>
                <para>See also parseSubnet().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.IsInSubnet(QtCore.QPair{QtNetwork.QHostAddress,System.Int32})">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Returns true if this IP is in the subnet described by subnet. The QHostAddress member of subnet contains the network prefix and the int (second) member contains the netmask (prefix length).</para>
                <para>This function was introduced in Qt 4.5.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.ParseSubnet(System.String)">
            <summary>
                <para>Parses the IP and subnet information contained in subnet and returns the network prefix for that network and its prefix length.</para>
                <para>The IP address and the netmask must be separated by a slash (/).</para>
                <para>This function supports arguments in the form:</para>
                <para>
                </para>
                <para>123.123.123.123/n where n is any value between 0 and 32</para>
                <para>123.123.123.123/255.255.255.255</para>
                <para>&lt;ipv6-address&gt;/n where n is any value between 0 and 128</para>
                <para>
                </para>
                <para>For IP version 4, this function accepts as well missing trailing components (i.e., less than 4 octets, like "192.168.1"), followed or not by a dot. If the netmask is also missing in that case, it is set to the number of octets actually passed (in the example above, it would be 24, for 3 octets).</para>
                <para>This function was introduced in Qt 4.5.</para>
                <para>See also isInSubnet().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.SetAddress(QtNetwork.QIPv6Address)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Set the IPv6 address specified by ip6Addr.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.SetAddress(System.UInt32)">
            <summary>
                <para>Set the IPv4 address specified by ip4Addr.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.SetAddress(QtCore.Pointer{System.Byte})">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Set the IPv6 address specified by ip6Addr.</para>
                <para>ip6Addr must be an array of 16 bytes in network byte order (high-order byte first).</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.SetAddress(System.String)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets the IPv4 or IPv6 address specified by the string representation specified by address (e.g. "127.0.0.1"). Returns true and sets the address if the address was successfully parsed; otherwise returns false.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.ToIPv4Address">
            <summary>
                <para>Returns the IPv4 address as a number.</para>
                <para>For example, if the address is 127.0.0.1, the returned value is 2130706433 (i.e. 0x7f000001).</para>
                <para>This value is only valid if the Protocol() is IPv4Protocol.</para>
                <para>See also toString().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.ToIPv6Address">
            <summary>
                <para>Returns the IPv6 address as a Q_IPV6ADDR structure. The structure consists of 16 unsigned characters.</para>
                <para> Q_IPV6ADDR addr = hostAddr.toIPv6Address();</para>
                <para> // addr contains 16 unsigned characters</para>
                <para>
                </para>
                <para> for (int i = 0; i &lt; 16; ++i) {</para>
                <para>     // process addr[i]</para>
                <para> }</para>
                <para>This value is only valid if the protocol() is IPv6Protocol.</para>
                <para>See also toString().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.ToString">
            <summary>
                <para>Returns the address as a string.</para>
                <para>For example, if the address is the IPv4 address 127.0.0.1, the returned string is "127.0.0.1". For IPv6 the string format will follow the RFC5952 recommendation.</para>
                <para>See also toIPv4Address().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.Finalize">
            <summary>
                <para>Destroys the host address object.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.op_Inequality(QtNetwork.QHostAddress,QtNetwork.QHostAddress)">
            <summary>
                <para>Returns true if this host address is not the same as the other address given; otherwise returns false.</para>
                <para>This function was introduced in Qt 4.2.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.op_Inequality(QtNetwork.QHostAddress,QtNetwork.QHostAddress.SpecialAddress)">
            <summary>
                <para>Returns true if this host address is not the same as the other address given; otherwise returns false.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.op_Equality(QtNetwork.QHostAddress,QtNetwork.QHostAddress)">
            <summary>
                <para>Returns true if this host address is the same as the other address given; otherwise returns false.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.op_Equality(QtNetwork.QHostAddress,QtNetwork.QHostAddress.SpecialAddress)">
            <summary>
                <para>Returns true if this host address is the same as the other address given; otherwise returns false.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QHostInfo">
            <summary>
            The QHostInfo class provides static functions for host name lookups.
            </summary>
            <remarks>
                <para>
                </para>
                <para>QHostInfo uses the lookup mechanisms provided by the operating system to find the IP address(es) associated with a host name, or the host name associated with an IP address. The class provides two static convenience functions: one that works asynchronously and emits a signal once the host is found, and one that blocks and returns a QHostInfo object.</para>
                <para>To look up a host's IP addresses asynchronously, call lookupHost(), which takes the host name or IP address, a receiver object, and a slot signature as arguments and returns an ID. You can abort the lookup by calling abortHostLookup() with the lookup ID.</para>
                <para>Example:</para>
                <para> // To find the IP address of qt.nokia.com</para>
                <para> QHostInfo::lookupHost("qt.nokia.com",</para>
                <para>                       this, SLOT(printResults(QHostInfo)));</para>
                <para>
                </para>
                <para> // To find the host name for 4.2.2.1</para>
                <para> QHostInfo::lookupHost("4.2.2.1",</para>
                <para>                       this, SLOT(printResults(QHostInfo)));</para>
                <para>The slot is invoked when the results are ready. The results are stored in a QHostInfo object. Call addresses() to get the list of IP addresses for the host, and hostName() to get the host name that was looked up.</para>
                <para>If the lookup failed, error() returns the type of error that occurred. errorString() gives a human-readable description of the lookup error.</para>
                <para>If you want a blocking lookup, use the QHostInfo::fromName() function:</para>
                <para> QHostInfo info = QHostInfo::fromName("qt.nokia.com");</para>
                <para>QHostInfo supports Internationalized Domain Names (IDNs) through the IDNA and Punycode standards.</para>
                <para>To retrieve the name of the local host, use the static QHostInfo::localHostName() function.</para>
                <para>Note: Since Qt 4.6.1 QHostInfo is using multiple threads for DNS lookup instead of one dedicated DNS thread. This improves performance, but also changes the order of signal emissions when using lookupHost() compared to previous versions of Qt. Note: Since Qt 4.6.3 QHostInfo is using a small internal 60 second DNS cache for performance improvements.</para>
                <para>
                </para>
                <para>See also QAbstractSocket and RFC 3492.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QHostInfo.#ctor(QtNetwork.QHostInfo)">
            <summary>
                <para>Constructs a copy of other.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostInfo.#ctor(System.Int32)">
            <summary>
                <para>Constructs an empty host info object with lookup ID id.</para>
                <para>See also lookupId().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QHostInfo.HostInfoError">
            <summary>
                <para>This enum describes the various errors that can occur when trying to resolve a host name.</para>
                <para>See also error() and setError().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QHostInfo.HostInfoError.HostNotFound">
            <summary>
                <para>No IP addresses were found for the host.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QHostInfo.HostInfoError.NoError">
            <summary>
                <para>The lookup was successful.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QHostInfo.HostInfoError.UnknownError">
            <summary>
                <para>An unknown error occurred.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHostInfo.Addresses">
            <summary>
                <para>Returns the list of IP addresses associated with hostName(). This list may be empty.</para>
                <para>Example:</para>
                <para> QHostInfo info;</para>
                <para> ...</para>
                <para> if (!info.addresses().isEmpty()) {</para>
                <para>     QHostAddress address = info.addresses().first();</para>
                <para>     // use the first IP address</para>
                <para> }</para>
                <para>Sets the list of addresses in this QHostInfo to addresses.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHostInfo.Error">
            <summary>
                <para>Returns the type of error that occurred if the host name lookup failed; otherwise returns NoError.</para>
                <para>Sets the error type of this QHostInfo to error.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHostInfo.ErrorString">
            <summary>
                <para>If the lookup failed, this function returns a human readable description of the error; otherwise "Unknown error" is returned.</para>
                <para>Sets the human readable description of the error that occurred to str if the lookup failed.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHostInfo.HostName">
            <summary>
                <para>Returns the name of the host whose IP addresses were looked up.</para>
                <para>Sets the host name of this QHostInfo to hostName.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHostInfo.LookupId">
            <summary>
                <para>Returns the ID of this lookup.</para>
                <para>Sets the ID of this lookup to id.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHostInfo.LocalDomainName">
            <summary>
                <para>Returns the DNS domain of this machine.</para>
                <para>Note: DNS domains are not related to domain names found in Windows networks.</para>
                <para>See also hostName().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHostInfo.LocalHostName">
            <summary>
                <para>Returns the host name of this machine.</para>
                <para>See also hostName().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostInfo.AbortHostLookup(System.Int32)">
            <summary>
                <para>Aborts the host lookup with the ID id, as returned by lookupHost().</para>
                <para>See also lookupHost() and lookupId().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostInfo.FromName(System.String)">
            <summary>
                <para>Looks up the IP address(es) for the given host name. The function blocks during the lookup which means that execution of the program is suspended until the results of the lookup are ready. Returns the result of the lookup in a QHostInfo object.</para>
                <para>If you pass a literal IP address to name instead of a host name, QHostInfo will search for the domain name for the IP (i.e., QHostInfo will perform a reverse lookup). On success, the returned QHostInfo will contain both the resolved domain name and IP addresses for the host name.</para>
                <para>See also lookupHost().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostInfo.LookupHost(System.String,QtCore.QObject,System.String)">
            <summary>
                <para>Looks up the IP address(es) associated with host name name, and returns an ID for the lookup. When the result of the lookup is ready, the slot or signal member in receiver is called with a QHostInfo argument. The QHostInfo object can then be inspected to get the results of the lookup.</para>
                <para>The lookup is performed by a single function call, for example:</para>
                <para> QHostInfo::lookupHost("www.kde.org",</para>
                <para>                       this, SLOT(lookedUp(QHostInfo)));</para>
                <para>The implementation of the slot prints basic information about the addresses returned by the lookup, or reports an error if it failed:</para>
                <para> void MyWidget::lookedUp(const QHostInfo &amp;host)</para>
                <para> {</para>
                <para>     if (host.error() != QHostInfo::NoError) {</para>
                <para>         qDebug() &lt;&lt; "Lookup failed:" &lt;&lt; host.errorString();</para>
                <para>         return;</para>
                <para>     }</para>
                <para>
                </para>
                <para>     foreach (const QHostAddress &amp;address, host.addresses())</para>
                <para>         qDebug() &lt;&lt; "Found address:" &lt;&lt; address.toString();</para>
                <para> }</para>
                <para>If you pass a literal IP address to name instead of a host name, QHostInfo will search for the domain name for the IP (i.e., QHostInfo will perform a reverse lookup). On success, the resulting QHostInfo will contain both the resolved domain name and IP addresses for the host name. Example:</para>
                <para> QHostInfo::lookupHost("4.2.2.1",</para>
                <para>                       this, SLOT(lookedUp(QHostInfo)));</para>
                <para>Note: There is no guarantee on the order the signals will be emitted if you start multiple requests with lookupHost().</para>
                <para>See also abortHostLookup(), addresses(), error(), and fromName().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostInfo.Finalize">
            <summary>
                <para>Destroys the host info object.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QHttp">
            <summary>
            The QHttp class provides an implementation of the HTTP protocol.
            </summary>
            <remarks>
                <para>
                </para>
                <para>This class provides a direct interface to HTTP that allows you to download and upload data with the HTTP protocol. However, for new applications, it is recommended to use QNetworkAccessManager and QNetworkReply, as those classes possess a simpler, yet more powerful API and a more modern protocol implementation.</para>
                <para>The class works asynchronously, so there are no blocking functions. If an operation cannot be executed immediately, the function will still return straight away and the operation will be scheduled for later execution. The results of scheduled operations are reported via signals. This approach depends on the event loop being in operation.</para>
                <para>The operations that can be scheduled (they are called "requests" in the rest of the documentation) are the following: setHost(), get(), post(), head() and request().</para>
                <para>All of these requests return a unique identifier that allows you to keep track of the request that is currently executed. When the execution of a request starts, the requestStarted() signal with the identifier is emitted and when the request is finished, the requestFinished() signal is emitted with the identifier and a bool that indicates if the request finished with an error.</para>
                <para>To make an HTTP request you must set up suitable HTTP headers. The following example demonstrates how to request the main HTML page from the Qt website (i.e., the URL http://qt.nokia.com/index.html):</para>
                <para> QHttpRequestHeader header("GET", QUrl::toPercentEncoding("/index.html"));</para>
                <para> header.setValue("Host", "qt.nokia.com");</para>
                <para> http-&gt;setHost("qt.nokia.com");</para>
                <para> http-&gt;request(header);</para>
                <para>For the common HTTP requests GET, POST and HEAD, QHttp provides the convenience functions get(), post() and head(). They already use a reasonable header and if you don't have to set special header fields, they are easier to use. The above example can also be written as:</para>
                <para> http-&gt;setHost("qt.nokia.com");                // id == 1</para>
                <para> http-&gt;get(QUrl::toPercentEncoding("/index.html")); // id == 2</para>
                <para>For this example the following sequence of signals is emitted (with small variations, depending on network traffic, etc.):</para>
                <para> requestStarted(1)</para>
                <para> requestFinished(1, false)</para>
                <para>
                </para>
                <para> requestStarted(2)</para>
                <para> stateChanged(Connecting)</para>
                <para> stateChanged(Sending)</para>
                <para> dataSendProgress(77, 77)</para>
                <para> stateChanged(Reading)</para>
                <para> responseHeaderReceived(responseheader)</para>
                <para> dataReadProgress(5388, 0)</para>
                <para> readyRead(responseheader)</para>
                <para> dataReadProgress(18300, 0)</para>
                <para> readyRead(responseheader)</para>
                <para> stateChanged(Connected)</para>
                <para> requestFinished(2, false)</para>
                <para>
                </para>
                <para> done(false)</para>
                <para>
                </para>
                <para> stateChanged(Closing)</para>
                <para> stateChanged(Unconnected)</para>
                <para>The dataSendProgress() and dataReadProgress() signals in the above example are useful if you want to show a progress bar to inform the user about the progress of the download. The second argument is the total size of data. In certain cases it is not possible to know the total amount in advance, in which case the second argument is 0. (If you connect to a QProgressBar a total of 0 results in a busy indicator.)</para>
                <para>When the response header is read, it is reported with the responseHeaderReceived() signal.</para>
                <para>The readyRead() signal tells you that there is data ready to be read. The amount of data can then be queried with the bytesAvailable() function and it can be read with the read() or readAll() functions.</para>
                <para>If an error occurs during the execution of one of the commands in a sequence of commands, all the pending commands (i.e. scheduled, but not yet executed commands) are cleared and no signals are emitted for them.</para>
                <para>For example, if you have the following sequence of requests</para>
                <para> http-&gt;setHost("www.foo.bar");       // id == 1</para>
                <para> http-&gt;get("/index.html");           // id == 2</para>
                <para> http-&gt;post("register.html", data);  // id == 3</para>
                <para>and the get() request fails because the host lookup fails, then the post() request is never executed and the signals would look like this:</para>
                <para> requestStarted(1)</para>
                <para> requestFinished(1, false)</para>
                <para>
                </para>
                <para> requestStarted(2)</para>
                <para> stateChanged(HostLookup)</para>
                <para> requestFinished(2, true)</para>
                <para>
                </para>
                <para> done(true)</para>
                <para>
                </para>
                <para> stateChanged(Unconnected)</para>
                <para>You can then get details about the error with the error() and errorString() functions. Note that only unexpected behavior, like network failure is considered as an error. If the server response contains an error status, like a 404 response, this is reported as a normal response case. So you should always check the status code of the response header.</para>
                <para>The functions currentId() and currentRequest() provide more information about the currently executing request.</para>
                <para>The functions hasPendingRequests() and clearPendingRequests() allow you to query and clear the list of pending requests.</para>
                <para>
                </para>
                <para>See also QFtp, QNetworkAccessManager, QNetworkRequest, QNetworkReply, HTTP Example, and Torrent Example.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QHttp.#ctor(QtCore.QObject)">
            <summary>
                <para>Constructs a QHttp object. The parent parameter is passed on to the QObject constructor.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttp.#ctor(System.String,System.UInt16,QtCore.QObject)">
            <summary>
                <para>Constructs a QHttp object. Subsequent requests are done by connecting to the server hostName on port port.</para>
                <para>The parent parameter is passed on to the QObject constructor.</para>
                <para>See also setHost().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttp.#ctor(System.String,QtNetwork.QHttp.ConnectionMode,System.UInt16,QtCore.QObject)">
            <summary>
                <para>Constructs a QHttp object. Subsequent requests are done by connecting to the server hostName on port port using the connection mode mode.</para>
                <para>If port is 0, it will use the default port for the mode used (80 for Http and 443 for Https).</para>
                <para>The parent parameter is passed on to the QObject constructor.</para>
                <para>See also setHost().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QHttp.ConnectionMode">
            <summary>
                <para>This enum is used to specify the mode of connection to use:</para>
                <para>When using the HTTPS mode, care should be taken to connect to the sslErrors signal, and handle possible SSL errors.</para>
                <para>This enum was introduced or modified in Qt 4.3.</para>
                <para>See also QSslSocket.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QHttp.ConnectionMode.ConnectionModeHttp">
            <summary>
                <para>The connection is a regular HTTP connection to the server</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QHttp.ConnectionMode.ConnectionModeHttps">
            <summary>
                <para>The HTTPS protocol is used and the connection is encrypted using SSL.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QHttp.Error">
            <summary>
                <para>This enum identifies the error that occurred.</para>
                <para>See also error().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QHttp.Error.Aborted">
            <summary>
                <para>The request was aborted with abort().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QHttp.Error.AuthenticationRequiredError">
            <summary>
                <para>The web server requires authentication to complete the request.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QHttp.Error.ConnectionRefused">
            <summary>
                <para>The server refused the connection.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QHttp.Error.HostNotFound">
            <summary>
                <para>The host name lookup failed.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QHttp.Error.InvalidResponseHeader">
            <summary>
                <para>The server sent an invalid response header.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QHttp.Error.NoError">
            <summary>
                <para>No error occurred.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QHttp.Error.ProxyAuthenticationRequiredError">
            <summary>
                <para>QHttp is using a proxy, and the proxy server requires authentication to establish a connection.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QHttp.Error.UnexpectedClose">
            <summary>
                <para>The server closed the connection unexpectedly.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QHttp.Error.UnknownError">
            <summary>
                <para>An error other than those specified above occurred.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QHttp.Error.WrongContentLength">
            <summary>
                <para>The client could not read the content correctly because an error with respect to the content length occurred.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QHttp.State">
            <summary>
                <para>This enum is used to specify the state the client is in:</para>
                <para>See also stateChanged() and state().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QHttp.State.Closing">
            <summary>
                <para>The connection is closing down, but is not yet closed. (The state will be Unconnected when the connection is closed.)</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QHttp.State.Connected">
            <summary>
                <para>The connection to the host is open, but the client is neither sending a request, nor waiting for a response.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QHttp.State.Connecting">
            <summary>
                <para>An attempt to connect to the host is in progress.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QHttp.State.HostLookup">
            <summary>
                <para>A host name lookup is in progress.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QHttp.State.Reading">
            <summary>
                <para>The client's request has been sent and the client is reading the server's response.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QHttp.State.Sending">
            <summary>
                <para>The client is sending its request to the server.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QHttp.State.Unconnected">
            <summary>
                <para>There is no connection to the host.</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QHttp.StateChanged">
            <summary>
                <para>This signal is emitted when the state of the QHttp object changes. The argument state is the new state of the connection; it is one of the State values.</para>
                <para>This usually happens when a request is started, but it can also happen when the server closes the connection or when a call to close() succeeded.</para>
                <para>See also get(), post(), head(), request(), close(), state(), and State.</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QHttp.ResponseHeaderReceived">
            <summary>
                <para>This signal is emitted when the HTTP header of a server response is available. The header is passed in resp.</para>
                <para>See also get(), post(), head(), request(), and readyRead().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QHttp.ReadyRead">
            <summary>
                <para>This signal is emitted when there is new response data to read.</para>
                <para>If you specified a device in the request where the data should be written to, then this signal is not emitted; instead the data is written directly to the device.</para>
                <para>The response header is passed in resp.</para>
                <para>You can read the data with the readAll() or read() functions</para>
                <para>This signal is useful if you want to process the data in chunks as soon as it becomes available. If you are only interested in the complete data, just connect to the requestFinished() signal and read the data then instead.</para>
                <para>See also get(), post(), request(), readAll(), read(), and bytesAvailable().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QHttp.DataSendProgress">
            <summary>
                <para>This signal is emitted when this object sends data to a HTTP server to inform it about the progress of the upload.</para>
                <para>done is the amount of data that has already arrived and total is the total amount of data. It is possible that the total amount of data that should be transferred cannot be determined, in which case total is 0.(If you connect to a QProgressBar, the progress bar shows a busy indicator if the total is 0).</para>
                <para>Warning: done and total are not necessarily the size in bytes, since for large files these values might need to be "scaled" to avoid overflow.</para>
                <para>See also dataReadProgress(), post(), request(), and QProgressBar.</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QHttp.DataReadProgress">
            <summary>
                <para>This signal is emitted when this object reads data from a HTTP server to indicate the current progress of the download.</para>
                <para>done is the amount of data that has already arrived and total is the total amount of data. It is possible that the total amount of data that should be transferred cannot be determined, in which case total is 0.(If you connect to a QProgressBar, the progress bar shows a busy indicator if the total is 0).</para>
                <para>Warning: done and total are not necessarily the size in bytes, since for large files these values might need to be "scaled" to avoid overflow.</para>
                <para>See also dataSendProgress(), get(), post(), request(), and QProgressBar.</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QHttp.RequestStarted">
            <summary>
                <para>This signal is emitted when processing the request identified by id starts.</para>
                <para>See also requestFinished() and done().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QHttp.RequestFinished">
            <summary>
                <para>This signal is emitted when processing the request identified by id has finished. error is true if an error occurred during the processing; otherwise error is false.</para>
                <para>See also requestStarted(), done(), error(), and errorString().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QHttp.Done">
            <summary>
                <para>This signal is emitted when the last pending request has finished; (it is emitted after the last request's requestFinished() signal). error is true if an error occurred during the processing; otherwise error is false.</para>
                <para>See also requestFinished(), error(), and errorString().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QHttp.ProxyAuthenticationRequired">
            <summary>
                <para>This signal can be emitted when a proxy that requires authentication is used. The authenticator object can then be filled in with the required details to allow authentication and continue the connection.</para>
                <para>Note: It is not possible to use a QueuedConnection to connect to this signal, as the connection will fail if the authenticator has not been filled in with new information when the signal returns.</para>
                <para>This function was introduced in Qt 4.3.</para>
                <para>See also QAuthenticator and QNetworkProxy.</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QHttp.AuthenticationRequired">
            <summary>
                <para>This signal can be emitted when a web server on a given hostname and port requires authentication. The authenticator object can then be filled in with the required details to allow authentication and continue the connection.</para>
                <para>Note: It is not possible to use a QueuedConnection to connect to this signal, as the connection will fail if the authenticator has not been filled in with new information when the signal returns.</para>
                <para>This function was introduced in Qt 4.3.</para>
                <para>See also QAuthenticator and QNetworkProxy.</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QHttp.SslErrors">
            <summary>
                <para>Forwards the sslErrors signal from the QSslSocket used in QHttp. errors is the list of errors that occurred during the SSL handshake. Unless you call ignoreSslErrors() from within a slot connected to this signal when an error occurs, QHttp will tear down the connection immediately after emitting the signal.</para>
                <para>This function was introduced in Qt 4.3.</para>
                <para>See also QSslSocket and QSslSocket::ignoreSslErrors().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHttp.BytesAvailable">
            <summary>
                <para>Returns the number of bytes that can be read from the response content at the moment.</para>
                <para>See also get(), post(), request(), readyRead(), read(), and readAll().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHttp.CurrentDestinationDevice">
            <summary>
                <para>Returns the QIODevice pointer that is used as to store the data of the HTTP request being executed. If there is no current request or if the request does not store the data to an IO device, this function returns 0.</para>
                <para>This function can be used to delete the QIODevice in the slot connected to the requestFinished() signal.</para>
                <para>See also currentSourceDevice(), get(), post(), and request().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHttp.CurrentId">
            <summary>
                <para>Returns the identifier of the HTTP request being executed or 0 if there is no request being executed (i.e. they've all finished).</para>
                <para>See also currentRequest().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHttp.CurrentRequest">
            <summary>
                <para>Returns the request header of the HTTP request being executed. If the request is one issued by setHost() or close(), it returns an invalid request header, i.e. QHttpRequestHeader::isValid() returns false.</para>
                <para>See also currentId().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHttp.CurrentSourceDevice">
            <summary>
                <para>Returns the QIODevice pointer that is used as the data source of the HTTP request being executed. If there is no current request or if the request does not use an IO device as the data source, this function returns 0.</para>
                <para>This function can be used to delete the QIODevice in the slot connected to the requestFinished() signal.</para>
                <para>See also currentDestinationDevice(), post(), and request().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHttp.error">
            <summary>
                <para>Returns the last error that occurred. This is useful to find out what happened when receiving a requestFinished() or a done() signal with the error argument true.</para>
                <para>If you start a new request, the error status is reset to NoError.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHttp.ErrorString">
            <summary>
                <para>Returns a human-readable description of the last error that occurred. This is useful to present a error message to the user when receiving a requestFinished() or a done() signal with the error argument true.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHttp.HasPendingRequests">
            <summary>
                <para>Returns true if there are any requests scheduled that have not yet been executed; otherwise returns false.</para>
                <para>The request that is being executed is not considered as a scheduled request.</para>
                <para>See also clearPendingRequests(), currentId(), and currentRequest().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHttp.LastResponse">
            <summary>
                <para>Returns the received response header of the most recently finished HTTP request. If no response has yet been received QHttpResponseHeader::isValid() will return false.</para>
                <para>See also currentRequest().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHttp.state">
            <summary>
                <para>Returns the current state of the object. When the state changes, the stateChanged() signal is emitted.</para>
                <para>See also State and stateChanged().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttp.Abort">
            <summary>
                <para>Aborts the current request and deletes all scheduled requests.</para>
                <para>For the current request, the requestFinished() signal with the error argument true is emitted. For all other requests that are affected by the abort(), no signals are emitted.</para>
                <para>Since this slot also deletes the scheduled requests, there are no requests left and the done() signal is emitted (with the error argument true).</para>
                <para>See also clearPendingRequests().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttp.OnAuthenticationRequired(System.String,System.UInt16,QtNetwork.QAuthenticator)">
            <summary>
                <para>This signal can be emitted when a web server on a given hostname and port requires authentication. The authenticator object can then be filled in with the required details to allow authentication and continue the connection.</para>
                <para>Note: It is not possible to use a QueuedConnection to connect to this signal, as the connection will fail if the authenticator has not been filled in with new information when the signal returns.</para>
                <para>This function was introduced in Qt 4.3.</para>
                <para>See also QAuthenticator and QNetworkProxy.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttp.ClearPendingRequests">
            <summary>
                <para>Deletes all pending requests from the list of scheduled requests. This does not affect the request that is being executed. If you want to stop this as well, use abort().</para>
                <para>See also hasPendingRequests() and abort().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttp.Close">
            <summary>
                <para>Closes the connection; this is useful if you have a keep-alive connection and want to close it.</para>
                <para>For the requests issued with get(), post() and head(), QHttp sets the connection to be keep-alive. You can also do this using the header you pass to the request() function. QHttp only closes the connection to the HTTP server if the response header requires it to do so.</para>
                <para>The function does not block; instead, it returns immediately. The request is scheduled, and its execution is performed asynchronously. The function returns a unique identifier which is passed by requestStarted() and requestFinished().</para>
                <para>When the request is started the requestStarted() signal is emitted. When it is finished the requestFinished() signal is emitted.</para>
                <para>If you want to close the connection immediately, you have to use abort() instead.</para>
                <para>See also stateChanged(), abort(), requestStarted(), requestFinished(), and done().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttp.CloseConnection">
            <summary>
                <para>Behaves the same as close().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttp.OnDataReadProgress(System.Int32,System.Int32)">
            <summary>
                <para>This signal is emitted when this object reads data from a HTTP server to indicate the current progress of the download.</para>
                <para>done is the amount of data that has already arrived and total is the total amount of data. It is possible that the total amount of data that should be transferred cannot be determined, in which case total is 0.(If you connect to a QProgressBar, the progress bar shows a busy indicator if the total is 0).</para>
                <para>Warning: done and total are not necessarily the size in bytes, since for large files these values might need to be "scaled" to avoid overflow.</para>
                <para>See also dataSendProgress(), get(), post(), request(), and QProgressBar.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttp.OnDataSendProgress(System.Int32,System.Int32)">
            <summary>
                <para>This signal is emitted when this object sends data to a HTTP server to inform it about the progress of the upload.</para>
                <para>done is the amount of data that has already arrived and total is the total amount of data. It is possible that the total amount of data that should be transferred cannot be determined, in which case total is 0.(If you connect to a QProgressBar, the progress bar shows a busy indicator if the total is 0).</para>
                <para>Warning: done and total are not necessarily the size in bytes, since for large files these values might need to be "scaled" to avoid overflow.</para>
                <para>See also dataReadProgress(), post(), request(), and QProgressBar.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttp.OnDone(System.Boolean)">
            <summary>
                <para>This signal is emitted when the last pending request has finished; (it is emitted after the last request's requestFinished() signal). error is true if an error occurred during the processing; otherwise error is false.</para>
                <para>See also requestFinished(), error(), and errorString().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttp.Get(System.String,QtCore.QIODevice)">
            <summary>
                <para>Sends a get request for path to the server set by setHost() or as specified in the constructor.</para>
                <para>path must be a absolute path like /index.html or an absolute URI like http://example.com/index.html and must be encoded with either QUrl::toPercentEncoding() or QUrl::encodedPath().</para>
                <para>If the IO device to is 0 the readyRead() signal is emitted every time new content data is available to read.</para>
                <para>If the IO device to is not 0, the content data of the response is written directly to the device. Make sure that the to pointer is valid for the duration of the operation (it is safe to delete it when the requestFinished() signal is emitted).</para>
                <para>
                </para>
                <para>Request Processing</para>
                <para>The function does not block; instead, it returns immediately. The request is scheduled, and its execution is performed asynchronously. The function returns a unique identifier which is passed by requestStarted() and requestFinished().</para>
                <para>When the request is started the requestStarted() signal is emitted. When it is finished the requestFinished() signal is emitted.</para>
                <para>See also setHost(), post(), head(), request(), requestStarted(), requestFinished(), and done().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttp.Head(System.String)">
            <summary>
                <para>Sends a header request for path to the server set by setHost() or as specified in the constructor.</para>
                <para>path must be an absolute path like /index.html or an absolute URI like http://example.com/index.html.</para>
                <para>The function does not block; instead, it returns immediately. The request is scheduled, and its execution is performed asynchronously. The function returns a unique identifier which is passed by requestStarted() and requestFinished().</para>
                <para>When the request is started the requestStarted() signal is emitted. When it is finished the requestFinished() signal is emitted.</para>
                <para>See also setHost(), get(), post(), request(), requestStarted(), requestFinished(), and done().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttp.IgnoreSslErrors">
            <summary>
                <para>Tells the QSslSocket used for the Http connection to ignore the errors reported in the sslErrors() signal.</para>
                <para>Note that this function must be called from within a slot connected to the sslErrors() signal to have any effect.</para>
                <para>See also QSslSocket and QSslSocket::sslErrors().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttp.Post(System.String,QtCore.QIODevice,QtCore.QIODevice)">
            <summary>
                <para>Sends a post request for path to the server set by setHost() or as specified in the constructor.</para>
                <para>path must be an absolute path like /index.html or an absolute URI like http://example.com/index.html and must be encoded with either QUrl::toPercentEncoding() or QUrl::encodedPath().</para>
                <para>The incoming data comes via the data IO device.</para>
                <para>If the IO device to is 0 the readyRead() signal is emitted every time new content data is available to read.</para>
                <para>If the IO device to is not 0, the content data of the response is written directly to the device. Make sure that the to pointer is valid for the duration of the operation (it is safe to delete it when the requestFinished() signal is emitted).</para>
                <para>The function does not block; instead, it returns immediately. The request is scheduled, and its execution is performed asynchronously. The function returns a unique identifier which is passed by requestStarted() and requestFinished().</para>
                <para>When the request is started the requestStarted() signal is emitted. When it is finished the requestFinished() signal is emitted.</para>
                <para>See also setHost(), get(), head(), request(), requestStarted(), requestFinished(), and done().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttp.Post(System.String,QtCore.QByteArray,QtCore.QIODevice)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>data is used as the content data of the HTTP request.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttp.OnProxyAuthenticationRequired(QtNetwork.QNetworkProxy,QtNetwork.QAuthenticator)">
            <summary>
                <para>This signal can be emitted when a proxy that requires authentication is used. The authenticator object can then be filled in with the required details to allow authentication and continue the connection.</para>
                <para>Note: It is not possible to use a QueuedConnection to connect to this signal, as the connection will fail if the authenticator has not been filled in with new information when the signal returns.</para>
                <para>This function was introduced in Qt 4.3.</para>
                <para>See also QAuthenticator and QNetworkProxy.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttp.Read(QtCore.Pointer{System.SByte},System.Int64)">
            <summary>
                <para>Reads maxlen bytes from the response content into data and returns the number of bytes read. Returns -1 if an error occurred.</para>
                <para>See also get(), post(), request(), readyRead(), bytesAvailable(), and readAll().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttp.ReadAll">
            <summary>
                <para>Reads all the bytes from the response content and returns them.</para>
                <para>See also get(), post(), request(), readyRead(), bytesAvailable(), and read().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttp.OnReadyRead(QtNetwork.QHttpResponseHeader)">
            <summary>
                <para>This signal is emitted when there is new response data to read.</para>
                <para>If you specified a device in the request where the data should be written to, then this signal is not emitted; instead the data is written directly to the device.</para>
                <para>The response header is passed in resp.</para>
                <para>You can read the data with the readAll() or read() functions</para>
                <para>This signal is useful if you want to process the data in chunks as soon as it becomes available. If you are only interested in the complete data, just connect to the requestFinished() signal and read the data then instead.</para>
                <para>See also get(), post(), request(), readAll(), read(), and bytesAvailable().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttp.Request(QtNetwork.QHttpRequestHeader,QtCore.QIODevice,QtCore.QIODevice)">
            <summary>
                <para>Sends a request to the server set by setHost() or as specified in the constructor. Uses the header as the HTTP request header. You are responsible for setting up a header that is appropriate for your request.</para>
                <para>The incoming data comes via the data IO device.</para>
                <para>If the IO device to is 0 the readyRead() signal is emitted every time new content data is available to read.</para>
                <para>If the IO device to is not 0, the content data of the response is written directly to the device. Make sure that the to pointer is valid for the duration of the operation (it is safe to delete it when the requestFinished() signal is emitted).</para>
                <para>The function does not block; instead, it returns immediately. The request is scheduled, and its execution is performed asynchronously. The function returns a unique identifier which is passed by requestStarted() and requestFinished().</para>
                <para>When the request is started the requestStarted() signal is emitted. When it is finished the requestFinished() signal is emitted.</para>
                <para>See also setHost(), get(), post(), head(), requestStarted(), requestFinished(), and done().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttp.Request(QtNetwork.QHttpRequestHeader,QtCore.QByteArray,QtCore.QIODevice)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>data is used as the content data of the HTTP request.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttp.OnRequestFinished(System.Int32,System.Boolean)">
            <summary>
                <para>This signal is emitted when processing the request identified by id has finished. error is true if an error occurred during the processing; otherwise error is false.</para>
                <para>See also requestStarted(), done(), error(), and errorString().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttp.OnRequestStarted(System.Int32)">
            <summary>
                <para>This signal is emitted when processing the request identified by id starts.</para>
                <para>See also requestFinished() and done().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttp.OnResponseHeaderReceived(QtNetwork.QHttpResponseHeader)">
            <summary>
                <para>This signal is emitted when the HTTP header of a server response is available. The header is passed in resp.</para>
                <para>See also get(), post(), head(), request(), and readyRead().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttp.SetHost(System.String,System.UInt16)">
            <summary>
                <para>Sets the HTTP server that is used for requests to hostName on port port.</para>
                <para>The function does not block; instead, it returns immediately. The request is scheduled, and its execution is performed asynchronously. The function returns a unique identifier which is passed by requestStarted() and requestFinished().</para>
                <para>When the request is started the requestStarted() signal is emitted. When it is finished the requestFinished() signal is emitted.</para>
                <para>See also get(), post(), head(), request(), requestStarted(), requestFinished(), and done().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttp.SetHost(System.String,QtNetwork.QHttp.ConnectionMode,System.UInt16)">
            <summary>
                <para>Sets the HTTP server that is used for requests to hostName on port port using the connection mode mode.</para>
                <para>If port is 0, it will use the default port for the mode used (80 for HTTP and 443 for HTTPS).</para>
                <para>The function does not block; instead, it returns immediately. The request is scheduled, and its execution is performed asynchronously. The function returns a unique identifier which is passed by requestStarted() and requestFinished().</para>
                <para>When the request is started the requestStarted() signal is emitted. When it is finished the requestFinished() signal is emitted.</para>
                <para>See also get(), post(), head(), request(), requestStarted(), requestFinished(), and done().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttp.SetProxy(QtNetwork.QNetworkProxy)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Enables HTTP proxy support using the proxy settings from proxy. If proxy is a transparent proxy, QHttp will call QAbstractSocket::setProxy() on the underlying socket. If the type is QNetworkProxy::HttpCachingProxy, QHttp will behave like the previous function.</para>
                <para>Note: for compatibility with Qt 4.3, if the proxy type is QNetworkProxy::HttpProxy and the request type is unencrypted (that is, ConnectionModeHttp), QHttp will treat the proxy as a caching proxy.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttp.SetProxy(System.String,System.Int32,System.String,System.String)">
            <summary>
                <para>Enables HTTP proxy support, using the proxy server host on port port. username and password can be provided if the proxy server requires authentication.</para>
                <para>Example:</para>
                <para> void Ticker::getTicks()</para>
                <para> {</para>
                <para>   http = new QHttp(this);</para>
                <para>   connect(http, SIGNAL(done(bool)), this, SLOT(showPage()));</para>
                <para>   http-&gt;setProxy("proxy.example.com", 3128);</para>
                <para>   http-&gt;setHost("ticker.example.com");</para>
                <para>   http-&gt;get("/ticks.asp");</para>
                <para> }</para>
                <para>
                </para>
                <para> void Ticker::showPage()</para>
                <para> {</para>
                <para>   display(http-&gt;readAll());</para>
                <para> }</para>
                <para>QHttp supports non-transparent web proxy servers only, such as the Squid Web proxy cache server (from http://www.squid.org/). For transparent proxying, such as SOCKS5, use QNetworkProxy instead.</para>
                <para>Note: setProxy() has to be called before setHost() for it to take effect. If setProxy() is called after setHost(), then it will not apply until after setHost() is called again.</para>
                <para>See also QFtp::setProxy().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttp.SetSocket(QtNetwork.QTcpSocket)">
            <summary>
                <para>Replaces the internal QTcpSocket that QHttp uses with socket. This is useful if you want to use your own custom QTcpSocket subclass instead of the plain QTcpSocket that QHttp uses by default. QHttp does not take ownership of the socket, and will not delete socket when destroyed.</para>
                <para>The function does not block; instead, it returns immediately. The request is scheduled, and its execution is performed asynchronously. The function returns a unique identifier which is passed by requestStarted() and requestFinished().</para>
                <para>When the request is started the requestStarted() signal is emitted. When it is finished the requestFinished() signal is emitted.</para>
                <para>Note: If QHttp is used in a non-GUI thread that runs its own event loop, you must move socket to that thread before calling setSocket().</para>
                <para>See also QObject::moveToThread() and Thread Support in Qt.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttp.SetUser(System.String,System.String)">
            <summary>
                <para>This function sets the user name userName and password password for web pages that require authentication.</para>
                <para>The function does not block; instead, it returns immediately. The request is scheduled, and its execution is performed asynchronously. The function returns a unique identifier which is passed by requestStarted() and requestFinished().</para>
                <para>When the request is started the requestStarted() signal is emitted. When it is finished the requestFinished() signal is emitted.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttp.OnSslErrors(System.Collections.Generic.List{QtNetwork.QSslError})">
            <summary>
                <para>Forwards the sslErrors signal from the QSslSocket used in QHttp. errors is the list of errors that occurred during the SSL handshake. Unless you call ignoreSslErrors() from within a slot connected to this signal when an error occurs, QHttp will tear down the connection immediately after emitting the signal.</para>
                <para>This function was introduced in Qt 4.3.</para>
                <para>See also QSslSocket and QSslSocket::ignoreSslErrors().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttp.OnStateChanged(System.Int32)">
            <summary>
                <para>This signal is emitted when the state of the QHttp object changes. The argument state is the new state of the connection; it is one of the State values.</para>
                <para>This usually happens when a request is started, but it can also happen when the server closes the connection or when a call to close() succeeded.</para>
                <para>See also get(), post(), head(), request(), close(), state(), and State.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttp.Finalize">
            <summary>
                <para>Destroys the QHttp object. If there is an open connection, it is closed.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QHttpHeader">
            <summary>
            The QHttpHeader class contains header information for HTTP.
            </summary>
            <remarks>
                <para>
                </para>
                <para>In most cases you should use the more specialized derivatives of this class, QHttpResponseHeader and QHttpRequestHeader, rather than directly using QHttpHeader.</para>
                <para>QHttpHeader provides the HTTP header fields. A HTTP header field consists of a name followed by a colon, a single space, and the field value. (See RFC 1945.) Field names are case-insensitive. A typical header field looks like this:</para>
                <para> content-type: text/html</para>
                <para>In the API the header field name is called the "key" and the content is called the "value". You can get and set a header field's value by using its key with value() and setValue(), e.g.</para>
                <para> header.setValue("content-type", "text/html");</para>
                <para> QString contentType = header.value("content-type");</para>
                <para>Some fields are so common that getters and setters are provided for them as a convenient alternative to using value() and setValue(), e.g. contentLength() and contentType(), setContentLength() and setContentType().</para>
                <para>Each header key has a single value associated with it. If you set the value for a key which already exists the previous value will be discarded.</para>
                <para>
                </para>
                <para>See also QHttpRequestHeader and QHttpResponseHeader.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QHttpHeader.#ctor">
            <summary>
                <para>Constructs an empty HTTP header.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpHeader.#ctor(QtNetwork.QHttpHeader)">
            <summary>
                <para>Constructs a copy of header.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpHeader.#ctor(System.String)">
            <summary>
                <para>Constructs a HTTP header for str.</para>
                <para>This constructor parses the string str for header fields and adds this information. The str should consist of one or more "\\r\\n" delimited lines; each of these lines should have the format key, colon, space, value.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHttpHeader.ContentType">
            <summary>
                <para>Returns the value of the special HTTP header field content-type.</para>
                <para>Sets the value of the special HTTP header field content-type to type.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHttpHeader.HasContentLength">
            <summary>
                <para>Returns true if the header has an entry for the special HTTP header field content-length; otherwise returns false.</para>
                <para>See also contentLength() and setContentLength().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHttpHeader.HasContentType">
            <summary>
                <para>Returns true if the header has an entry for the special HTTP header field content-type; otherwise returns false.</para>
                <para>See also contentType() and setContentType().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHttpHeader.IsValid">
            <summary>
                <para>Returns true if the HTTP header is valid; otherwise returns false.</para>
                <para>A QHttpHeader is invalid if it was created by parsing a malformed string.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHttpHeader.Keys">
            <summary>
                <para>Returns a list of the keys in the HTTP header.</para>
                <para>See also hasKey().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHttpHeader.MajorVersion">
            <summary>
                <para>Returns the major protocol-version of the HTTP header.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHttpHeader.MinorVersion">
            <summary>
                <para>Returns the minor protocol-version of the HTTP header.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpHeader.AddValue(System.String,System.String)">
            <summary>
                <para>Adds a new entry with the key and value.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpHeader.AllValues(System.String)">
            <summary>
                <para>Returns all the entries with the given key. If no entry has this key, an empty string list is returned.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpHeader.ContentLength">
            <summary>
                <para>Returns the value of the special HTTP header field content-length.</para>
                <para>See also setContentLength() and hasContentLength().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpHeader.HasKey(System.String)">
            <summary>
                <para>Returns true if the HTTP header has an entry with the given key; otherwise returns false.</para>
                <para>See also value(), setValue(), and keys().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpHeader.RemoveAllValues(System.String)">
            <summary>
                <para>Removes all the entries with the key key from the HTTP header.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpHeader.RemoveValue(System.String)">
            <summary>
                <para>Removes the entry with the key key from the HTTP header.</para>
                <para>See also value() and setValue().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpHeader.SetContentLength(System.Int32)">
            <summary>
                <para>Sets the value of the special HTTP header field content-length to len.</para>
                <para>See also contentLength() and hasContentLength().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpHeader.SetValue(System.String,System.String)">
            <summary>
                <para>Sets the value of the entry with the key to value.</para>
                <para>If no entry with key exists, a new entry with the given key and value is created. If an entry with the key already exists, the first value is discarded and replaced with the given value.</para>
                <para>See also value(), hasKey(), and removeValue().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpHeader.ToString">
            <summary>
                <para>Returns a string representation of the HTTP header.</para>
                <para>The string is suitable for use by the constructor that takes a QString. It consists of lines with the format: key, colon, space, value, "\\r\\n".</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpHeader.Value(System.String)">
            <summary>
                <para>Returns the first value for the entry with the given key. If no entry has this key, an empty string is returned.</para>
                <para>See also setValue(), removeValue(), hasKey(), and keys().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpHeader.Finalize">
            <summary>
                <para>Destructor.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QHttpMultiPart">
            <summary>
            The QHttpMultiPart class resembles a MIME multipart message to be sent over HTTP.
            </summary>
            <remarks>
                <para>
                </para>
                <para>The QHttpMultiPart resembles a MIME multipart message, as described in RFC 2046, which is to be sent over HTTP. A multipart message consists of an arbitrary number of body parts (see QHttpPart), which are separated by a unique boundary. The boundary of the QHttpMultiPart is constructed with the string "boundary_.oOo._" followed by random characters, and provides enough uniqueness to make sure it does not occur inside the parts itself. If desired, the boundary can still be set via setBoundary().</para>
                <para>As an example, consider the following code snippet, which constructs a multipart message containing a text part followed by an image part:</para>
                <para> QHttpMultiPart *multiPart = new QHttpMultiPart(QHttpMultiPart::FormDataType);</para>
                <para>
                </para>
                <para> QHttpPart textPart;</para>
                <para> textPart.setHeader(QNetworkRequest::ContentDispositionHeader, QVariant("form-data; name=\\"text\\""));</para>
                <para> textPart.setBody("my text");</para>
                <para>
                </para>
                <para> QHttpPart imagePart;</para>
                <para> imagePart.setHeader(QNetworkRequest::ContentTypeHeader, QVariant("image/jpeg"));</para>
                <para> imagePart.setHeader(QNetworkRequest::ContentDispositionHeader, QVariant("form-data; name=\\"image\\""));</para>
                <para> QFile *file = new QFile("image.jpg");</para>
                <para> file-&gt;open(QIODevice::ReadOnly);</para>
                <para> imagePart.setBodyDevice(file);</para>
                <para> file-&gt;setParent(multiPart); // we cannot delete the file now, so delete it with the multiPart</para>
                <para>
                </para>
                <para> multiPart-&gt;append(textPart);</para>
                <para> multiPart-&gt;append(imagePart);</para>
                <para>
                </para>
                <para> QUrl url("http://my.server.tld");</para>
                <para> QNetworkRequest request(url);</para>
                <para>
                </para>
                <para> QNetworkAccessManager manager;</para>
                <para> QNetworkReply *reply = manager.post(request, multiPart);</para>
                <para> multiPart-&gt;setParent(reply); // delete the multiPart with the reply</para>
                <para> // here connect signals etc.</para>
                <para>
                </para>
                <para>See also QHttpPart and QNetworkAccessManager::post().</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QHttpMultiPart.#ctor(QtCore.QObject)">
            <summary>
                <para>Constructs a QHttpMultiPart with content type MixedType and sets parent as the parent object.</para>
                <para>See also QHttpMultiPart::ContentType.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpMultiPart.#ctor(QtNetwork.QHttpMultiPart.ContentType,QtCore.QObject)">
            <summary>
                <para>Constructs a QHttpMultiPart with content type contentType and sets parent as the parent object.</para>
                <para>See also QHttpMultiPart::ContentType.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QHttpMultiPart.ContentType">
            <summary>
                <para>List of known content types for a multipart subtype as described in RFC 2046 and others.</para>
                <para>See also setContentType().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QHttpMultiPart.ContentType.AlternativeType">
            <summary>
                <para>Corresponds to the "multipart/alternative" subtype, meaning the body parts are alternative representations of the same information, as described in RFC 2046.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QHttpMultiPart.ContentType.FormDataType">
            <summary>
                <para>Corresponds to the "multipart/form-data" subtype, meaning the body parts contain form elements, as described in RFC 2388.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QHttpMultiPart.ContentType.MixedType">
            <summary>
                <para>Corresponds to the "multipart/mixed" subtype, meaning the body parts are independent of each other, as described in RFC 2046.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QHttpMultiPart.ContentType.RelatedType">
            <summary>
                <para>Corresponds to the "multipart/related" subtype, meaning the body parts are related to each other, as described in RFC 2387.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHttpMultiPart.Boundary">
            <summary>
                <para>returns the boundary.</para>
                <para>Sets the boundary to boundary.</para>
                <para>Usually, you do not need to generate a boundary yourself; upon construction the boundary is initiated with the string "boundary_.oOo._" followed by random characters, and provides enough uniqueness to make sure it does not occur inside the parts itself.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpMultiPart.Append(QtNetwork.QHttpPart)">
            <summary>
                <para>Appends httpPart to this multipart.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpMultiPart.SetContentType(QtNetwork.QHttpMultiPart.ContentType)">
            <summary>
                <para>Sets the content type to contentType. The content type will be used in the HTTP header section when sending the multipart message via QNetworkAccessManager::post(). In case you want to use a multipart subtype not contained in QHttpMultiPart::ContentType, you can add the "Content-Type" header field to the QNetworkRequest by hand, and then use this request together with the multipart message for posting.</para>
                <para>See also QHttpMultiPart::ContentType and QNetworkAccessManager::post().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpMultiPart.Finalize">
            <summary>
                <para>Destroys the multipart.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QHttpPart">
            <summary>
            The QHttpPart class holds a body part to be used inside a HTTP multipart MIME message.
            </summary>
            <remarks>
                <para>
                </para>
                <para>The QHttpPart class holds a body part to be used inside a HTTP multipart MIME message (which is represented by the QHttpMultiPart class). A QHttpPart consists of a header block and a data block, which are separated by each other by two consecutive new lines. An example for one part would be:</para>
                <para> Content-Type: text/plain</para>
                <para> Content-Disposition: form-data; name="text"</para>
                <para>
                </para>
                <para> here goes the body</para>
                <para>For setting headers, use setHeader() and setRawHeader(), which behave exactly like QNetworkRequest::setHeader() and QNetworkRequest::setRawHeader().</para>
                <para>For reading small pieces of data, use setBody(); for larger data blocks like e.g. images, use setBodyDevice(). The latter method saves memory by not copying the data internally, but reading directly from the device. This means that the device must be opened and readable at the moment when the multipart message containing the body part is sent on the network via QNetworkAccessManager::post().</para>
                <para>To construct a QHttpPart with a small body, consider the following snippet (this produces the data shown in the example above):</para>
                <para> QHttpPart textPart;</para>
                <para> textPart.setHeader(QNetworkRequest::ContentTypeHeader, QVariant("text/plain"));</para>
                <para> textPart.setHeader(QNetworkRequest::ContentDispositionHeader, QVariant("form-data; name=\\"text\\""));</para>
                <para> textPart.setBody("here goes the body");</para>
                <para>To construct a QHttpPart reading from a device (e.g. a file), the following can be applied:</para>
                <para> QHttpPart imagePart;</para>
                <para> imagePart.setHeader(QNetworkRequest::ContentTypeHeader, QVariant("image/jpeg"));</para>
                <para> imagePart.setHeader(QNetworkRequest::ContentDispositionHeader, QVariant("form-data; name=\\"image\\""));</para>
                <para> imagePart.setRawHeader("Content-ID", "my@content.id"); // add any headers you like via setRawHeader()</para>
                <para> QFile *file = new QFile("image.jpg");</para>
                <para> file-&gt;open(QIODevice::ReadOnly);</para>
                <para> imagePart.setBodyDevice(file);</para>
                <para>Be aware that QHttpPart does not take ownership of the device when set, so it is the developer's responsibility to destroy it when it is not needed anymore. A good idea might be to set the multipart message as parent object for the device, as documented at the documentation for QHttpMultiPart.</para>
                <para>
                </para>
                <para>See also QHttpMultiPart and QNetworkAccessManager.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QHttpPart.#ctor">
            <summary>
                <para>Constructs an empty QHttpPart object.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpPart.#ctor(QtNetwork.QHttpPart)">
            <summary>
                <para>Creates a copy of other.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpPart.SetBody(QtCore.QByteArray)">
            <summary>
                <para>Sets the body of this MIME part to body. The body set with this method will be used unless the device is set via setBodyDevice(). For a large amount of data (e.g. an image), use setBodyDevice(), which will not copy the data internally.</para>
                <para>See also setBodyDevice().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpPart.SetBodyDevice(QtCore.QIODevice)">
            <summary>
                <para>Sets the device to read the content from to device. For large amounts of data this method should be preferred over setBody(), because the content is not copied when using this method, but read directly from the device. device must be open and readable. QHttpPart does not take ownership of device, i.e. the device must be closed and destroyed if necessary. if device is sequential (e.g. sockets, but not files), QNetworkAccessManager::post() should be called after device has emitted finished(). For unsetting the device and using data set via setBody(), use "setBodyDevice(0)".</para>
                <para>See also setBody() and QNetworkAccessManager::post().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpPart.SetHeader(QtNetwork.QNetworkRequest.KnownHeaders,System.Object)">
            <summary>
                <para>Sets the value of the known header header to be value, overriding any previously set headers.</para>
                <para>See also QNetworkRequest::KnownHeaders, setRawHeader(), and QNetworkRequest::setHeader().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpPart.SetRawHeader(QtCore.QByteArray,QtCore.QByteArray)">
            <summary>
                <para>Sets the header headerName to be of value headerValue. If headerName corresponds to a known header (see QNetworkRequest::KnownHeaders), the raw format will be parsed and the corresponding "cooked" header will be set as well.</para>
                <para>Note: setting the same header twice overrides the previous setting. To accomplish the behaviour of multiple HTTP headers of the same name, you should concatenate the two values, separating them with a comma (",") and set one single raw header.</para>
                <para>See also QNetworkRequest::KnownHeaders, setHeader(), and QNetworkRequest::setRawHeader().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpPart.Finalize">
            <summary>
                <para>Destroys this QHttpPart.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpPart.op_Inequality(QtNetwork.QHttpPart,QtNetwork.QHttpPart)">
            <summary>
                <para>Returns true if this object is not the same as other.</para>
                <para>See also operator==().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpPart.op_Equality(QtNetwork.QHttpPart,QtNetwork.QHttpPart)">
            <summary>
                <para>Returns true if this object is the same as other (i.e., if they have the same headers and body).</para>
                <para>See also operator!=().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QHttpRequestHeader">
            <summary>
            The QHttpRequestHeader class contains request header information for HTTP.
            </summary>
            <remarks>
                <para>
                </para>
                <para>This class is used in the QHttp class to report the header information if the client requests something from the server.</para>
                <para>HTTP requests have a method which describes the request's action. The most common requests are "GET" and "POST". In addition to the request method the header also includes a request-URI to specify the location for the method to use.</para>
                <para>The method, request-URI and protocol-version can be set using a constructor or later using setRequest(). The values can be obtained using method(), path(), majorVersion() and minorVersion().</para>
                <para>Note that the request-URI must be in the format expected by the HTTP server. That is, all reserved characters must be encoded in %HH (where HH are two hexadecimal digits). See QUrl::toPercentEncoding() for more information.</para>
                <para>Important inherited functions: setValue() and value().</para>
                <para>
                </para>
                <para>See also QHttpResponseHeader and QHttp.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QHttpRequestHeader.#ctor">
            <summary>
                <para>Constructs an empty HTTP request header.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpRequestHeader.#ctor(QtNetwork.QHttpRequestHeader)">
            <summary>
                <para>Constructs a copy of header.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpRequestHeader.#ctor(System.String)">
            <summary>
                <para>Constructs a HTTP request header from the string str. The str should consist of one or more "\\r\\n" delimited lines; the first line should be the request-line (format: method, space, request-URI, space HTTP-version); each of the remaining lines should have the format key, colon, space, value.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpRequestHeader.#ctor(System.String,System.String,System.Int32,System.Int32)">
            <summary>
                <para>Constructs a HTTP request header for the method method, the request-URI path and the protocol-version majorVer and minorVer. The path argument must be properly encoded for an HTTP request.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHttpRequestHeader.MajorVersion">
            <summary>
                <para>Reimplemented from QHttpHeader::majorVersion().</para>
                <para>Returns the major protocol-version of the HTTP request header.</para>
                <para>See also minorVersion(), method(), path(), and setRequest().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHttpRequestHeader.MinorVersion">
            <summary>
                <para>Reimplemented from QHttpHeader::minorVersion().</para>
                <para>Returns the minor protocol-version of the HTTP request header.</para>
                <para>See also majorVersion(), method(), path(), and setRequest().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHttpRequestHeader.Method">
            <summary>
                <para>Returns the method of the HTTP request header.</para>
                <para>See also path(), majorVersion(), minorVersion(), and setRequest().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHttpRequestHeader.Path">
            <summary>
                <para>Returns the request-URI of the HTTP request header.</para>
                <para>See also method(), majorVersion(), minorVersion(), and setRequest().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpRequestHeader.SetRequest(System.String,System.String,System.Int32,System.Int32)">
            <summary>
                <para>This function sets the request method to method, the request-URI to path and the protocol-version to majorVer and minorVer. The path argument must be properly encoded for an HTTP request.</para>
                <para>See also method(), path(), majorVersion(), and minorVersion().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpRequestHeader.ToString">
            <summary>
                <para>Reimplemented from QHttpHeader::toString().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QHttpResponseHeader">
            <summary>
            The QHttpResponseHeader class contains response header information for HTTP.
            </summary>
            <remarks>
                <para>
                </para>
                <para>This class is used by the QHttp class to report the header information that the client received from the server.</para>
                <para>HTTP responses have a status code that indicates the status of the response. This code is a 3-digit integer result code (for details see to RFC 1945). In addition to the status code, you can also specify a human-readable text that describes the reason for the code ("reason phrase"). This class allows you to get the status code and the reason phrase.</para>
                <para>
                </para>
                <para>See also QHttpRequestHeader, QHttp, and HTTP Example.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QHttpResponseHeader.#ctor">
            <summary>
                <para>Constructs an empty HTTP response header.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpResponseHeader.#ctor(QtNetwork.QHttpResponseHeader)">
            <summary>
                <para>Constructs a copy of header.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpResponseHeader.#ctor(System.String)">
            <summary>
                <para>Constructs a HTTP response header from the string str. The string is parsed and the information is set. The str should consist of one or more "\\r\\n" delimited lines; the first line should be the status-line (format: HTTP-version, space, status-code, space, reason-phrase); each of remaining lines should have the format key, colon, space, value.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpResponseHeader.#ctor(System.Int32,System.String,System.Int32,System.Int32)">
            <summary>
                <para>Constructs a QHttpResponseHeader, setting the status code to code, the reason phrase to text and the protocol-version to majorVer and minorVer.</para>
                <para>This function was introduced in Qt 4.1.</para>
                <para>See also statusCode(), reasonPhrase(), majorVersion(), and minorVersion().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHttpResponseHeader.MajorVersion">
            <summary>
                <para>Reimplemented from QHttpHeader::majorVersion().</para>
                <para>Returns the major protocol-version of the HTTP response header.</para>
                <para>See also minorVersion(), statusCode(), and reasonPhrase().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHttpResponseHeader.MinorVersion">
            <summary>
                <para>Reimplemented from QHttpHeader::minorVersion().</para>
                <para>Returns the minor protocol-version of the HTTP response header.</para>
                <para>See also majorVersion(), statusCode(), and reasonPhrase().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHttpResponseHeader.ReasonPhrase">
            <summary>
                <para>Returns the reason phrase of the HTTP response header.</para>
                <para>See also statusCode(), majorVersion(), and minorVersion().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHttpResponseHeader.StatusCode">
            <summary>
                <para>Returns the status code of the HTTP response header.</para>
                <para>See also reasonPhrase(), majorVersion(), and minorVersion().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpResponseHeader.SetStatusLine(System.Int32,System.String,System.Int32,System.Int32)">
            <summary>
                <para>Sets the status code to code, the reason phrase to text and the protocol-version to majorVer and minorVer.</para>
                <para>This function was introduced in Qt 4.1.</para>
                <para>See also statusCode(), reasonPhrase(), majorVersion(), and minorVersion().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpResponseHeader.ToString">
            <summary>
                <para>Reimplemented from QHttpHeader::toString().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QLocalServer">
            <summary>
            The QLocalServer class provides a local socket based server.
            </summary>
            <remarks>
                <para>
                </para>
                <para>This class makes it possible to accept incoming local socket connections.</para>
                <para>Call listen() to have the server start listening for incoming connections on a specified key. The newConnection() signal is then emitted each time a client connects to the server.</para>
                <para>Call nextPendingConnection() to accept the pending connection as a connected QLocalSocket. The function returns a pointer to a QLocalSocket that can be used for communicating with the client.</para>
                <para>If an error occurs, serverError() returns the type of error, and errorString() can be called to get a human readable description of what happened.</para>
                <para>When listening for connections, the name which the server is listening on is available through serverName().</para>
                <para>Calling close() makes QLocalServer stop listening for incoming connections.</para>
                <para>Although QLocalServer is designed for use with an event loop, it's possible to use it without one. In that case, you must use waitForNewConnection(), which blocks until either a connection is available or a timeout expires.</para>
                <para>
                </para>
                <para>See also QLocalSocket and QTcpServer.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QLocalServer.#ctor(QtCore.QObject)">
            <summary>
                <para>Create a new local socket server with the given parent.</para>
                <para>See also listen().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QLocalServer.NewConnection">
            <summary>
                <para>This signal is emitted every time a new connection is available.</para>
                <para>See also hasPendingConnections() and nextPendingConnection().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QLocalServer.MaxPendingConnections">
            <summary>
                <para>Returns the maximum number of pending accepted connections. The default is 30.</para>
                <para>Sets the maximum number of pending accepted connections to numConnections. QLocalServer will accept no more than numConnections incoming connections before nextPendingConnection() is called.</para>
                <para>Note: Even though QLocalServer will stop accepting new connections after it has reached its maximum number of pending connections, the operating system may still keep them in queue which will result in clients signaling that it is connected.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QLocalServer.ErrorString">
            <summary>
                <para>Returns the human-readable message appropriate to the current error reported by serverError(). If no suitable string is available, an empty string is returned.</para>
                <para>See also serverError().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QLocalServer.FullServerName">
            <summary>
                <para>Returns the full path that the server is listening on.</para>
                <para>Note: This is platform specific</para>
                <para>See also listen() and serverName().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QLocalServer.HasPendingConnections">
            <summary>
                <para>Returns true if the server has a pending connection; otherwise returns false.</para>
                <para>See also nextPendingConnection() and setMaxPendingConnections().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QLocalServer.IsListening">
            <summary>
                <para>Returns true if the server is listening for incoming connections otherwise false.</para>
                <para>See also listen() and close().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QLocalServer.NextPendingConnection">
            <summary>
                <para>Returns the next pending connection as a connected QLocalSocket object.</para>
                <para>The socket is created as a child of the server, which means that it is automatically deleted when the QLocalServer object is destroyed. It is still a good idea to delete the object explicitly when you are done with it, to avoid wasting memory.</para>
                <para>0 is returned if this function is called when there are no pending connections.</para>
                <para>See also hasPendingConnections(), newConnection(), and incomingConnection().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QLocalServer.ServerError">
            <summary>
                <para>Returns the type of error that occurred last or NoError.</para>
                <para>See also errorString().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QLocalServer.ServerName">
            <summary>
                <para>Returns the server name if the server is listening for connections; otherwise returns QString()</para>
                <para>See also listen() and fullServerName().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalServer.Close">
            <summary>
                <para>Stop listening for incoming connections. Existing connections are not effected, but any new connections will be refused.</para>
                <para>See also isListening() and listen().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalServer.Listen(System.String)">
            <summary>
                <para>Tells the server to listen for incoming connections on name. If the server is currently listening then it will return false. Return true on success otherwise false.</para>
                <para>name can be a single name and QLocalServer will determine the correct platform specific path. serverName() will return the name that is passed into listen.</para>
                <para>Usually you would just pass in a name like "foo", but on Unix this could also be a path such as "/tmp/foo" and on Windows this could be a pipe path such as "\\\\.\\pipe\\foo"</para>
                <para>Note: On Unix if the server crashes without closing listen will fail with AddressInUseError. To create a new server the file should be removed. On Windows two local servers can listen to the same pipe at the same time, but any connections will go to one of the server.</para>
                <para>See also serverName(), isListening(), and close().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalServer.OnNewConnection">
            <summary>
                <para>This signal is emitted every time a new connection is available.</para>
                <para>See also hasPendingConnections() and nextPendingConnection().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalServer.RemoveServer(System.String)">
            <summary>
                <para>Removes any server instance that might cause a call to listen() to fail and returns true if successful; otherwise returns false. This function is meant to recover from a crash, when the previous server instance has not been cleaned up.</para>
                <para>On Windows, this function does nothing; on Unix, it removes the socket file given by name.</para>
                <para>Warning: Be careful to avoid removing sockets of running instances.</para>
                <para>This function was introduced in Qt 4.5.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalServer.WaitForNewConnection(System.Int32)">
            <summary>
                <para>Waits for at most msec milliseconds or until an incoming connection is available. Returns true if a connection is available; otherwise returns false. If the operation timed out and timedOut is not 0, *timedOut will be set to true.</para>
                <para>This is a blocking function call. Its use is ill-advised in a single-threaded GUI application, since the whole application will stop responding until the function returns. waitForNewConnection() is mostly useful when there is no event loop available.</para>
                <para>The non-blocking alternative is to connect to the newConnection() signal.</para>
                <para>If msec is -1, this function will not time out.</para>
                <para>See also hasPendingConnections() and nextPendingConnection().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalServer.WaitForNewConnection(System.Int32,System.Boolean@)">
            <summary>
                <para>Waits for at most msec milliseconds or until an incoming connection is available. Returns true if a connection is available; otherwise returns false. If the operation timed out and timedOut is not 0, *timedOut will be set to true.</para>
                <para>This is a blocking function call. Its use is ill-advised in a single-threaded GUI application, since the whole application will stop responding until the function returns. waitForNewConnection() is mostly useful when there is no event loop available.</para>
                <para>The non-blocking alternative is to connect to the newConnection() signal.</para>
                <para>If msec is -1, this function will not time out.</para>
                <para>See also hasPendingConnections() and nextPendingConnection().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalServer.Finalize">
            <summary>
                <para>Destroys the QLocalServer object. If the server is listening for connections, it is automatically closed.</para>
                <para>Any client QLocalSockets that are still connected must either disconnect or be reparented before the server is deleted.</para>
                <para>See also close().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QLocalSocket">
            <summary>
            The QLocalSocket class provides a local socket.
            </summary>
            <remarks>
                <para>
                </para>
                <para>On Windows this is a named pipe and on Unix this is a local domain socket.</para>
                <para>If an error occurs, socketError() returns the type of error, and errorString() can be called to get a human readable description of what happened.</para>
                <para>Although QLocalSocket is designed for use with an event loop, it's possible to use it without one. In that case, you must use waitForConnected(), waitForReadyRead(), waitForBytesWritten(), and waitForDisconnected() which blocks until the operation is complete or the timeout expires.</para>
                <para>Note that this feature is not supported on versions of Windows earlier than Windows XP.</para>
                <para>
                </para>
                <para>See also QLocalServer.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QLocalSocket.#ctor(QtCore.QObject)">
            <summary>
                <para>Creates a new local socket. The parent argument is passed to QObject's constructor.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QLocalSocket.LocalSocketError">
            <summary>
                <para>The LocalServerError enumeration represents the errors that can occur. The most recent error can be retrieved through a call to QLocalSocket::error().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QLocalSocket.LocalSocketError.ConnectionError">
            <summary>
                <para>An error occurred with the connection.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QLocalSocket.LocalSocketError.ConnectionRefusedError">
            <summary>
                <para>The connection was refused by the peer (or timed out).</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QLocalSocket.LocalSocketError.DatagramTooLargeError">
            <summary>
                <para>The datagram was larger than the operating system's limit (which can be as low as 8192 bytes).</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QLocalSocket.LocalSocketError.PeerClosedError">
            <summary>
                <para>The remote socket closed the connection. Note that the client socket (i.e., this socket) will be closed after the remote close notification has been sent.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QLocalSocket.LocalSocketError.ServerNotFoundError">
            <summary>
                <para>The local socket name was not found.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QLocalSocket.LocalSocketError.SocketAccessError">
            <summary>
                <para>The socket operation failed because the application lacked the required privileges.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QLocalSocket.LocalSocketError.SocketResourceError">
            <summary>
                <para>The local system ran out of resources (e.g., too many sockets).</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QLocalSocket.LocalSocketError.SocketTimeoutError">
            <summary>
                <para>The socket operation timed out.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QLocalSocket.LocalSocketError.UnknownSocketError">
            <summary>
                <para>An unidentified error occurred.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QLocalSocket.LocalSocketError.UnsupportedSocketOperationError">
            <summary>
                <para>The requested socket operation is not supported by the local operating system.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QLocalSocket.LocalSocketState">
            <summary>
                <para>This enum describes the different states in which a socket can be.</para>
                <para>See also QLocalSocket::state().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QLocalSocket.LocalSocketState.ClosingState">
            <summary>
                <para>The socket is about to close (data may still be waiting to be written).</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QLocalSocket.LocalSocketState.ConnectedState">
            <summary>
                <para>A connection is established.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QLocalSocket.LocalSocketState.ConnectingState">
            <summary>
                <para>The socket has started establishing a connection.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QLocalSocket.LocalSocketState.UnconnectedState">
            <summary>
                <para>The socket is not connected.</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QLocalSocket.Connected">
            <summary>
                <para>This signal is emitted after connectToServer() has been called and a connection has been successfully established.</para>
                <para>See also connectToServer() and disconnected().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QLocalSocket.Disconnected">
            <summary>
                <para>This signal is emitted when the socket has been disconnected.</para>
                <para>See also connectToServer(), disconnectFromServer(), abort(), and connected().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QLocalSocket.ErrorSocketError">
            <summary>
                <para>This signal is emitted after an error occurred. The socketError parameter describes the type of error that occurred.</para>
                <para>QLocalSocket::LocalSocketError is not a registered metatype, so for queued connections, you will have to register it with Q_DECLARE_METATYPE() and qRegisterMetaType().</para>
                <para>See also error(), errorString(), and Creating Custom Qt Types.</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QLocalSocket.StateChanged">
            <summary>
                <para>This signal is emitted whenever QLocalSocket's state changes. The socketState parameter is the new state.</para>
                <para>QLocalSocket::SocketState is not a registered metatype, so for queued connections, you will have to register it with Q_DECLARE_METATYPE() and qRegisterMetaType().</para>
                <para>See also state() and Creating Custom Qt Types.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QLocalSocket.ReadBufferSize">
            <summary>
                <para>Returns the size of the internal read buffer. This limits the amount of data that the client can receive before you call read() or readAll(). A read buffer size of 0 (the default) means that the buffer has no size limit, ensuring that no data is lost.</para>
                <para>Sets the size of QLocalSocket's internal read buffer to be size bytes.</para>
                <para>If the buffer size is limited to a certain size, QLocalSocket won't buffer more than this size of data. Exceptionally, a buffer size of 0 means that the read buffer is unlimited and all incoming data is buffered. This is the default.</para>
                <para>This option is useful if you only read the data at certain points in time (e.g., in a real-time streaming application) or if you want to protect your socket against receiving too much data, which may eventually cause your application to run out of memory.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QLocalSocket.BytesAvailable">
            <summary>
                <para>Reimplemented from QIODevice::bytesAvailable().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QLocalSocket.BytesToWrite">
            <summary>
                <para>Reimplemented from QIODevice::bytesToWrite().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QLocalSocket.CanReadLine">
            <summary>
                <para>Reimplemented from QIODevice::canReadLine().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QLocalSocket.Flush">
            <summary>
                <para>This function writes as much as possible from the internal write buffer to the socket, without blocking. If any data was written, this function returns true; otherwise false is returned.</para>
                <para>Call this function if you need QLocalSocket to start sending buffered data immediately. The number of bytes successfully written depends on the operating system. In most cases, you do not need to call this function, because QLocalSocket will start sending data automatically once control goes back to the event loop. In the absence of an event loop, call waitForBytesWritten() instead.</para>
                <para>See also write() and waitForBytesWritten().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QLocalSocket.FullServerName">
            <summary>
                <para>Returns the server path that the socket is connected to.</para>
                <para>Note: The return value of this function is platform specific.</para>
                <para>See also connectToServer() and serverName().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QLocalSocket.IsSequential">
            <summary>
                <para>Reimplemented from QIODevice::isSequential().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QLocalSocket.IsValid">
            <summary>
                <para>Returns true if the socket is valid and ready for use; otherwise returns false.</para>
                <para>Note: The socket's state must be ConnectedState before reading and writing can occur.</para>
                <para>See also state() and connectToServer().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QLocalSocket.ServerName">
            <summary>
                <para>Returns the name of the peer as specified by connectToServer(), or an empty QString if connectToServer() has not been called or it failed.</para>
                <para>See also connectToServer() and fullServerName().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QLocalSocket.State">
            <summary>
                <para>Returns the state of the socket.</para>
                <para>See also error().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalSocket.Abort">
            <summary>
                <para>Aborts the current connection and resets the socket. Unlike disconnectFromServer(), this function immediately closes the socket, clearing any pending data in the write buffer.</para>
                <para>See also disconnectFromServer() and close().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalSocket.Close">
            <summary>
                <para>Reimplemented from QIODevice::close().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalSocket.ConnectToServer(System.String,QtCore.QIODevice.OpenModeFlag)">
            <summary>
                <para>Attempts to make a connection to name.</para>
                <para>The socket is opened in the given openMode and first enters ConnectingState. It then attempts to connect to the address or addresses returned by the lookup. Finally, if a connection is established, QLocalSocket enters ConnectedState and emits connected().</para>
                <para>At any point, the socket can emit error() to signal that an error occurred.</para>
                <para>See also state(), serverName(), and waitForConnected().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalSocket.OnConnected">
            <summary>
                <para>This signal is emitted after connectToServer() has been called and a connection has been successfully established.</para>
                <para>See also connectToServer() and disconnected().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalSocket.DisconnectFromServer">
            <summary>
                <para>Attempts to close the socket. If there is pending data waiting to be written, QLocalSocket will enter ClosingState and wait until all data has been written. Eventually, it will enter UnconnectedState and emit the disconnectedFromServer() signal.</para>
                <para>See also connectToServer().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalSocket.OnDisconnected">
            <summary>
                <para>This signal is emitted when the socket has been disconnected.</para>
                <para>See also connectToServer(), disconnectFromServer(), abort(), and connected().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalSocket.Error">
            <summary>
                <para>Returns the type of error that last occurred.</para>
                <para>See also state() and errorString().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalSocket.OnError(QtNetwork.QLocalSocket.LocalSocketError)">
            <summary>
                <para>This signal is emitted after an error occurred. The socketError parameter describes the type of error that occurred.</para>
                <para>QLocalSocket::LocalSocketError is not a registered metatype, so for queued connections, you will have to register it with Q_DECLARE_METATYPE() and qRegisterMetaType().</para>
                <para>See also error(), errorString(), and Creating Custom Qt Types.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalSocket.ReadData(QtCore.Pointer{System.SByte},System.Int64)">
            <summary>
                <para>Reimplemented from QIODevice::readData().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalSocket.OnStateChanged(QtNetwork.QLocalSocket.LocalSocketState)">
            <summary>
                <para>This signal is emitted whenever QLocalSocket's state changes. The socketState parameter is the new state.</para>
                <para>QLocalSocket::SocketState is not a registered metatype, so for queued connections, you will have to register it with Q_DECLARE_METATYPE() and qRegisterMetaType().</para>
                <para>See also state() and Creating Custom Qt Types.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalSocket.WaitForBytesWritten(System.Int32)">
            <summary>
                <para>Reimplemented from QIODevice::waitForBytesWritten().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalSocket.WaitForConnected(System.Int32)">
            <summary>
                <para>Waits until the socket is connected, up to msecs milliseconds. If the connection has been established, this function returns true; otherwise it returns false. In the case where it returns false, you can call error() to determine the cause of the error.</para>
                <para>The following example waits up to one second for a connection to be established:</para>
                <para> socket-&gt;connectToServer("market");</para>
                <para> if (socket-&gt;waitForConnected(1000))</para>
                <para>     qDebug("Connected!");</para>
                <para>If msecs is -1, this function will not time out.</para>
                <para>See also connectToServer() and connected().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalSocket.WaitForDisconnected(System.Int32)">
            <summary>
                <para>Waits until the socket has disconnected, up to msecs milliseconds. If the connection has been disconnected, this function returns true; otherwise it returns false. In the case where it returns false, you can call error() to determine the cause of the error.</para>
                <para>The following example waits up to one second for a connection to be closed:</para>
                <para> socket-&gt;disconnectFromServer();</para>
                <para> if (socket-&gt;waitForDisconnected(1000))</para>
                <para>     qDebug("Disconnected!");</para>
                <para>If msecs is -1, this function will not time out.</para>
                <para>See also disconnectFromServer() and close().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalSocket.WaitForReadyRead(System.Int32)">
            <summary>
                <para>Reimplemented from QIODevice::waitForReadyRead().</para>
                <para>This function blocks until data is available for reading and the readyRead() signal has been emitted. The function will timeout after msecs milliseconds; the default timeout is 30000 milliseconds.</para>
                <para>The function returns true if data is available for reading; otherwise it returns false (if an error occurred or the operation timed out).</para>
                <para>See also waitForBytesWritten().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalSocket.WriteData(System.String,System.Int64)">
            <summary>
                <para>Reimplemented from QIODevice::writeData().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalSocket.Finalize">
            <summary>
                <para>Destroys the socket, closing the connection if necessary.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkAccessManager">
            <summary>
            The QNetworkAccessManager class allows the application to send network requests and receive replies
            </summary>
            <remarks>
                <para>
                </para>
                <para>The Network Access API is constructed around one QNetworkAccessManager object, which holds the common configuration and settings for the requests it sends. It contains the proxy and cache configuration, as well as the signals related to such issues, and reply signals that can be used to monitor the progress of a network operation. One QNetworkAccessManager should be enough for the whole Qt application.</para>
                <para>Once a QNetworkAccessManager object has been created, the application can use it to send requests over the network. A group of standard functions are supplied that take a request and optional data, and each return a QNetworkReply object. The returned object is used to obtain any data returned in response to the corresponding request.</para>
                <para>A simple download off the network could be accomplished with:</para>
                <para> QNetworkAccessManager *manager = new QNetworkAccessManager(this);</para>
                <para> connect(manager, SIGNAL(finished(QNetworkReply*)),</para>
                <para>         this, SLOT(replyFinished(QNetworkReply*)));</para>
                <para>
                </para>
                <para> manager-&gt;get(QNetworkRequest(QUrl("http://qt.nokia.com")));</para>
                <para>QNetworkAccessManager has an asynchronous API. When the replyFinished slot above is called, the parameter it takes is the QNetworkReply object containing the downloaded data as well as meta-data (headers, etc.).</para>
                <para>Note: After the request has finished, it is the responsibility of the user to delete the QNetworkReply object at an appropriate time. Do not directly delete it inside the slot connected to finished(). You can use the deleteLater() function.</para>
                <para>Note: QNetworkAccessManager queues the requests it receives. The number of requests executed in parallel is dependent on the protocol. Currently, for the HTTP protocol on desktop platforms, 6 requests are executed in parallel for one host/port combination.</para>
                <para>A more involved example, assuming the manager is already existent, can be:</para>
                <para> QNetworkRequest request;</para>
                <para> request.setUrl(QUrl("http://qt.nokia.com"));</para>
                <para> request.setRawHeader("User-Agent", "MyOwnBrowser 1.0");</para>
                <para>
                </para>
                <para> QNetworkReply *reply = manager-&gt;get(request);</para>
                <para> connect(reply, SIGNAL(readyRead()), this, SLOT(slotReadyRead()));</para>
                <para> connect(reply, SIGNAL(error(QNetworkReply::NetworkError)),</para>
                <para>         this, SLOT(slotError(QNetworkReply::NetworkError)));</para>
                <para> connect(reply, SIGNAL(sslErrors(QList&lt;QSslError&gt;)),</para>
                <para>         this, SLOT(slotSslErrors(QList&lt;QSslError&gt;)));</para>
                <para>
                </para>
                <para>Network and Roaming support</para>
                <para>With the addition of the Bearer Management API to Qt 4.7 QNetworkAccessManager gained the ability to manage network connections. QNetworkAccessManager can start the network interface if the device is offline and terminates the interface if the current process is the last one to use the uplink. Note that some platform utilize grace periods from when the last application stops using a uplink until the system actually terminates the connectivity link. Roaming is equally transparent. Any queued/pending network requests are automatically transferred to new access point.</para>
                <para>Clients wanting to utilize this feature should not require any changes. In fact it is likely that existing platform specific connection code can simply be removed from the application.</para>
                <para>Note: The network and roaming support in QNetworkAccessManager is conditional upon the platform supporting connection management. The QNetworkConfigurationManager::NetworkSessionRequired can be used to detect whether QNetworkAccessManager utilizes this feature. Currently only Meego/Harmattan and Symbian platforms provide connection management support.</para>
                <para>Note: This feature cannot be used in combination with the Bearer Management API as provided by QtMobility. Applications have to migrate to the Qt version of Bearer Management.</para>
                <para>
                </para>
                <para>Symbian Platform Security Requirements</para>
                <para>On Symbian, processes which use this class must have the NetworkServices platform security capability. If the client process lacks this capability, operations will result in a panic.</para>
                <para>Platform security capabilities are added via the TARGET.CAPABILITY qmake variable.</para>
                <para>
                </para>
                <para>See also QNetworkRequest, QNetworkReply, and QNetworkProxy.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QNetworkAccessManager.#ctor(QtCore.QObject)">
            <summary>
                <para>Constructs a QNetworkAccessManager object that is the center of the Network Access API and sets parent as the parent object.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkAccessManager.NetworkAccessibility">
            <summary>
                <para>Indicates whether the network is accessible via this network access manager.</para>
                <para>See also networkAccessible.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkAccessManager.NetworkAccessibility.Accessible">
            <summary>
                <para>The network is accessible.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkAccessManager.NetworkAccessibility.NotAccessible">
            <summary>
                <para>The network is not currently accessible, either because there is currently no network coverage or network access has been explicitly disabled by a call to setNetworkAccessible().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkAccessManager.NetworkAccessibility.UnknownAccessibility">
            <summary>
                <para>The network accessibility cannot be determined.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkAccessManager.Operation">
            <summary>
                <para>Indicates the operation this reply is processing.</para>
                <para>This enum was introduced or modified in Qt 4.7.</para>
                <para>See also QNetworkReply::operation().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkAccessManager.Operation.CustomOperation">
            <summary>
                <para>Custom operation (created with sendCustomRequest())</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkAccessManager.Operation.DeleteOperation">
            <summary>
                <para>Delete contents operation (created with deleteResource())</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkAccessManager.Operation.GetOperation">
            <summary>
                <para>Retrieve headers and download contents (created with get())</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkAccessManager.Operation.HeadOperation">
            <summary>
                <para>Retrieve headers operation (created with head())</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkAccessManager.Operation.PostOperation">
            <summary>
                <para>Send the contents of an HTML form for processing via HTTP POST (created with post())</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkAccessManager.Operation.PutOperation">
            <summary>
                <para>Upload contents operation (created with put())</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkAccessManager.ProxyAuthenticationRequired">
            <summary>
                <para>This signal is emitted whenever a proxy requests authentication and QNetworkAccessManager cannot find a valid, cached credential. The slot connected to this signal should fill in the credentials for the proxy proxy in the authenticator object.</para>
                <para>QNetworkAccessManager will cache the credentials internally. The next time the proxy requests authentication, QNetworkAccessManager will automatically send the same credential without emitting the proxyAuthenticationRequired signal again.</para>
                <para>If the proxy rejects the credentials, QNetworkAccessManager will emit the signal again.</para>
                <para>See also proxy(), setProxy(), and authenticationRequired().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkAccessManager.AuthenticationRequired">
            <summary>
                <para>This signal is emitted whenever a final server requests authentication before it delivers the requested contents. The slot connected to this signal should fill the credentials for the contents (which can be determined by inspecting the reply object) in the authenticator object.</para>
                <para>QNetworkAccessManager will cache the credentials internally and will send the same values if the server requires authentication again, without emitting the authenticationRequired() signal. If it rejects the credentials, this signal will be emitted again.</para>
                <para>Note: It is not possible to use a QueuedConnection to connect to this signal, as the connection will fail if the authenticator has not been filled in with new information when the signal returns.</para>
                <para>See also proxyAuthenticationRequired().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkAccessManager.Finished">
            <summary>
                <para>This signal is emitted whenever a pending network reply is finished. The reply parameter will contain a pointer to the reply that has just finished. This signal is emitted in tandem with the QNetworkReply::finished() signal.</para>
                <para>See QNetworkReply::finished() for information on the status that the object will be in.</para>
                <para>Note: Do not delete the reply object in the slot connected to this signal. Use deleteLater().</para>
                <para>See also QNetworkReply::finished() and QNetworkReply::error().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkAccessManager.SslErrors">
            <summary>
                <para>This signal is emitted if the SSL/TLS session encountered errors during the set up, including certificate verification errors. The errors parameter contains the list of errors and reply is the QNetworkReply that is encountering these errors.</para>
                <para>To indicate that the errors are not fatal and that the connection should proceed, the QNetworkReply::ignoreSslErrors() function should be called from the slot connected to this signal. If it is not called, the SSL session will be torn down before any data is exchanged (including the URL).</para>
                <para>This signal can be used to display an error message to the user indicating that security may be compromised and display the SSL settings (see sslConfiguration() to obtain it). If the user decides to proceed after analyzing the remote certificate, the slot should call ignoreSslErrors().</para>
                <para>See also QSslSocket::sslErrors(), QNetworkReply::sslErrors(), QNetworkReply::sslConfiguration(), and QNetworkReply::ignoreSslErrors().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkAccessManager.NetworkAccessibleChanged">
            <summary>
                <para>This signal is emitted when the value of the networkAccessible property changes. accessible is the new network accessibility.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkAccessManager.Cache">
            <summary>
                <para>Returns the cache that is used to store data obtained from the network.</para>
                <para>This function was introduced in Qt 4.5.</para>
                <para>Sets the manager's network cache to be the cache specified. The cache is used for all requests dispatched by the manager.</para>
                <para>Use this function to set the network cache object to a class that implements additional features, like saving the cookies to permanent storage.</para>
                <para>Note: QNetworkAccessManager takes ownership of the cache object.</para>
                <para>QNetworkAccessManager by default does not have a set cache. Qt provides a simple disk cache, QNetworkDiskCache, which can be used.</para>
                <para>This function was introduced in Qt 4.5.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkAccessManager.Configuration">
            <summary>
                <para>Returns the network configuration that will be used to create the network session which will be used when processing network requests.</para>
                <para>This function was introduced in Qt 4.7.</para>
                <para>Sets the network configuration that will be used when creating the network session to config.</para>
                <para>The network configuration is used to create and open a network session before any request that requires network access is process. If no network configuration is explicitly set via this function the network configuration returned by QNetworkConfigurationManager::defaultConfiguration() will be used.</para>
                <para>To restore the default network configuration set the network configuration to the value returned from QNetworkConfigurationManager::defaultConfiguration().</para>
                <para> QNetworkConfigurationManager manager;</para>
                <para> networkAccessManager-&gt;setConfiguration(manager.defaultConfiguration());</para>
                <para>If an invalid network configuration is set, a network session will not be created. In this case network requests will be processed regardless, but may fail. For example:</para>
                <para> networkAccessManager-&gt;setConfiguration(QNetworkConfiguration());</para>
                <para>This function was introduced in Qt 4.7.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkAccessManager.CookieJar">
            <summary>
                <para>Returns the QNetworkCookieJar that is used to store cookies obtained from the network as well as cookies that are about to be sent.</para>
                <para>Sets the manager's cookie jar to be the cookieJar specified. The cookie jar is used by all requests dispatched by the manager.</para>
                <para>Use this function to set the cookie jar object to a class that implements additional features, like saving the cookies to permanent storage.</para>
                <para>Note: QNetworkAccessManager takes ownership of the cookieJar object.</para>
                <para>If cookieJar is in the same thread as this QNetworkAccessManager, it will set the parent of the cookieJar so that the cookie jar is deleted when this object is deleted as well. If you want to share cookie jars between different QNetworkAccessManager objects, you may want to set the cookie jar's parent to 0 after calling this function.</para>
                <para>QNetworkAccessManager by default does not implement any cookie policy of its own: it accepts all cookies sent by the server, as long as they are well formed and meet the minimum security requirements (cookie domain matches the request's and cookie path matches the request's). In order to implement your own security policy, override the QNetworkCookieJar::cookiesForUrl() and QNetworkCookieJar::setCookiesFromUrl() virtual functions. Those functions are called by QNetworkAccessManager when it detects a new cookie.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkAccessManager.Proxy">
            <summary>
                <para>Returns the QNetworkProxy that the requests sent using this QNetworkAccessManager object will use. The default value for the proxy is QNetworkProxy::DefaultProxy.</para>
                <para>Sets the proxy to be used in future requests to be proxy. This does not affect requests that have already been sent. The proxyAuthenticationRequired() signal will be emitted if the proxy requests authentication.</para>
                <para>A proxy set with this function will be used for all requests issued by QNetworkAccessManager. In some cases, it might be necessary to select different proxies depending on the type of request being sent or the destination host. If that's the case, you should consider using setProxyFactory().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkAccessManager.ProxyFactory">
            <summary>
                <para>Returns the proxy factory that this QNetworkAccessManager object is using to determine the proxies to be used for requests.</para>
                <para>Note that the pointer returned by this function is managed by QNetworkAccessManager and could be deleted at any time.</para>
                <para>This function was introduced in Qt 4.5.</para>
                <para>Sets the proxy factory for this class to be factory. A proxy factory is used to determine a more specific list of proxies to be used for a given request, instead of trying to use the same proxy value for all requests.</para>
                <para>All queries sent by QNetworkAccessManager will have type QNetworkProxyQuery::UrlRequest.</para>
                <para>For example, a proxy factory could apply the following rules:</para>
                <para>
                </para>
                <para>if the target address is in the local network (for example, if the hostname contains no dots or if it's an IP address in the organization's range), return QNetworkProxy::NoProxy</para>
                <para>if the request is FTP, return an FTP proxy</para>
                <para>if the request is HTTP or HTTPS, then return an HTTP proxy</para>
                <para>otherwise, return a SOCKSv5 proxy server</para>
                <para>
                </para>
                <para>The lifetime of the object factory will be managed by QNetworkAccessManager. It will delete the object when necessary.</para>
                <para>Note: If a specific proxy is set with setProxy(), the factory will not be used.</para>
                <para>This function was introduced in Qt 4.5.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkAccessManager.ActiveConfiguration">
            <summary>
                <para>Returns the current active network configuration.</para>
                <para>If the network configuration returned by configuration() is of type QNetworkConfiguration::ServiceNetwork this function will return the current active child network configuration of that configuration. Otherwise returns the same network configuration as configuration().</para>
                <para>Use this function to return the actual network configuration currently in use by the network session.</para>
                <para>This function was introduced in Qt 4.7.</para>
                <para>See also configuration().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkAccessManager.NetworkAccessible">
            <summary>
                <para>This property holds whether the network is currently accessible via this network access manager.</para>
                <para>If the network is not accessible the network access manager will not process any new network requests, all such requests will fail with an error. Requests with URLs with the file:// scheme will still be processed.</para>
                <para>By default the value of this property reflects the physical state of the device. Applications may override it to disable all network requests via this network access manager by calling</para>
                <para> networkAccessManager-&gt;setNetworkAccessible(QNetworkAccessManager::NotAccessible);</para>
                <para>Network requests can be reenabled again by calling</para>
                <para> networkAccessManager-&gt;setNetworkAccessible(QNetworkAccessManager::Accessible);</para>
                <para>Note: Calling setNetworkAccessible() does not change the network state.</para>
                <para>This property was introduced in Qt 4.7.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAccessManager.OnAuthenticationRequired(QtNetwork.QNetworkReply,QtNetwork.QAuthenticator)">
            <summary>
                <para>This signal is emitted whenever a final server requests authentication before it delivers the requested contents. The slot connected to this signal should fill the credentials for the contents (which can be determined by inspecting the reply object) in the authenticator object.</para>
                <para>QNetworkAccessManager will cache the credentials internally and will send the same values if the server requires authentication again, without emitting the authenticationRequired() signal. If it rejects the credentials, this signal will be emitted again.</para>
                <para>Note: It is not possible to use a QueuedConnection to connect to this signal, as the connection will fail if the authenticator has not been filled in with new information when the signal returns.</para>
                <para>See also proxyAuthenticationRequired().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAccessManager.CreateRequest(QtNetwork.QNetworkAccessManager.Operation,QtNetwork.QNetworkRequest,QtCore.QIODevice)">
            <summary>
                <para>Returns a new QNetworkReply object to handle the operation op and request req. The device outgoingData is always 0 for Get and Head requests, but is the value passed to post() and put() in those operations (the QByteArray variants will pass a QBuffer object).</para>
                <para>The default implementation calls QNetworkCookieJar::cookiesForUrl() on the cookie jar set with setCookieJar() to obtain the cookies to be sent to the remote server.</para>
                <para>The returned object must be in an open state.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAccessManager.DeleteResource(QtNetwork.QNetworkRequest)">
            <summary>
                <para>Sends a request to delete the resource identified by the URL of request.</para>
                <para>Note: This feature is currently available for HTTP only, performing an HTTP DELETE request.</para>
                <para>This function was introduced in Qt 4.6.</para>
                <para>See also get(), post(), put(), and sendCustomRequest().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAccessManager.OnFinished(QtNetwork.QNetworkReply)">
            <summary>
                <para>This signal is emitted whenever a pending network reply is finished. The reply parameter will contain a pointer to the reply that has just finished. This signal is emitted in tandem with the QNetworkReply::finished() signal.</para>
                <para>See QNetworkReply::finished() for information on the status that the object will be in.</para>
                <para>Note: Do not delete the reply object in the slot connected to this signal. Use deleteLater().</para>
                <para>See also QNetworkReply::finished() and QNetworkReply::error().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAccessManager.Get(QtNetwork.QNetworkRequest)">
            <summary>
                <para>Posts a request to obtain the contents of the target request and returns a new QNetworkReply object opened for reading which emits the readyRead() signal whenever new data arrives.</para>
                <para>The contents as well as associated headers will be downloaded.</para>
                <para>See also post(), put(), deleteResource(), and sendCustomRequest().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAccessManager.Head(QtNetwork.QNetworkRequest)">
            <summary>
                <para>Posts a request to obtain the network headers for request and returns a new QNetworkReply object which will contain such headers.</para>
                <para>The function is named after the HTTP request associated (HEAD).</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAccessManager.OnNetworkAccessibleChanged(QtNetwork.QNetworkAccessManager.NetworkAccessibility)">
            <summary>
                <para>This signal is emitted when the value of the networkAccessible property changes. accessible is the new network accessibility.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAccessManager.Post(QtNetwork.QNetworkRequest,QtCore.QIODevice)">
            <summary>
                <para>Sends an HTTP POST request to the destination specified by request and returns a new QNetworkReply object opened for reading that will contain the reply sent by the server. The contents of the data device will be uploaded to the server.</para>
                <para>data must be open for reading and must remain valid until the finished() signal is emitted for this reply.</para>
                <para>Note: Sending a POST request on protocols other than HTTP and HTTPS is undefined and will probably fail.</para>
                <para>See also get(), put(), deleteResource(), and sendCustomRequest().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAccessManager.Post(QtNetwork.QNetworkRequest,QtCore.QByteArray)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sends the contents of the data byte array to the destination specified by request.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAccessManager.Post(QtNetwork.QNetworkRequest,QtNetwork.QHttpMultiPart)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sends the contents of the multiPart message to the destination specified by request.</para>
                <para>This can be used for sending MIME multipart messages over HTTP.</para>
                <para>This function was introduced in Qt 4.8.</para>
                <para>See also QHttpMultiPart, QHttpPart, and put().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAccessManager.OnProxyAuthenticationRequired(QtNetwork.QNetworkProxy,QtNetwork.QAuthenticator)">
            <summary>
                <para>This signal is emitted whenever a proxy requests authentication and QNetworkAccessManager cannot find a valid, cached credential. The slot connected to this signal should fill in the credentials for the proxy proxy in the authenticator object.</para>
                <para>QNetworkAccessManager will cache the credentials internally. The next time the proxy requests authentication, QNetworkAccessManager will automatically send the same credential without emitting the proxyAuthenticationRequired signal again.</para>
                <para>If the proxy rejects the credentials, QNetworkAccessManager will emit the signal again.</para>
                <para>See also proxy(), setProxy(), and authenticationRequired().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAccessManager.Put(QtNetwork.QNetworkRequest,QtCore.QIODevice)">
            <summary>
                <para>Uploads the contents of data to the destination request and returnes a new QNetworkReply object that will be open for reply.</para>
                <para>data must be opened for reading when this function is called and must remain valid until the finished() signal is emitted for this reply.</para>
                <para>Whether anything will be available for reading from the returned object is protocol dependent. For HTTP, the server may send a small HTML page indicating the upload was successful (or not). Other protocols will probably have content in their replies.</para>
                <para>Note: For HTTP, this request will send a PUT request, which most servers do not allow. Form upload mechanisms, including that of uploading files through HTML forms, use the POST mechanism.</para>
                <para>See also get(), post(), deleteResource(), and sendCustomRequest().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAccessManager.Put(QtNetwork.QNetworkRequest,QtCore.QByteArray)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sends the contents of the data byte array to the destination specified by request.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAccessManager.Put(QtNetwork.QNetworkRequest,QtNetwork.QHttpMultiPart)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sends the contents of the multiPart message to the destination specified by request.</para>
                <para>This can be used for sending MIME multipart messages over HTTP.</para>
                <para>This function was introduced in Qt 4.8.</para>
                <para>See also QHttpMultiPart, QHttpPart, and post().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAccessManager.SendCustomRequest(QtNetwork.QNetworkRequest,QtCore.QByteArray,QtCore.QIODevice)">
            <summary>
                <para>Sends a custom request to the server identified by the URL of request.</para>
                <para>It is the user's responsibility to send a verb to the server that is valid according to the HTTP specification.</para>
                <para>This method provides means to send verbs other than the common ones provided via get() or post() etc., for instance sending an HTTP OPTIONS command.</para>
                <para>If data is not empty, the contents of the data device will be uploaded to the server; in that case, data must be open for reading and must remain valid until the finished() signal is emitted for this reply.</para>
                <para>Note: This feature is currently available for HTTP(S) only.</para>
                <para>This function was introduced in Qt 4.7.</para>
                <para>See also get(), post(), put(), and deleteResource().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAccessManager.OnSslErrors(QtNetwork.QNetworkReply,System.Collections.Generic.List{QtNetwork.QSslError})">
            <summary>
                <para>This signal is emitted if the SSL/TLS session encountered errors during the set up, including certificate verification errors. The errors parameter contains the list of errors and reply is the QNetworkReply that is encountering these errors.</para>
                <para>To indicate that the errors are not fatal and that the connection should proceed, the QNetworkReply::ignoreSslErrors() function should be called from the slot connected to this signal. If it is not called, the SSL session will be torn down before any data is exchanged (including the URL).</para>
                <para>This signal can be used to display an error message to the user indicating that security may be compromised and display the SSL settings (see sslConfiguration() to obtain it). If the user decides to proceed after analyzing the remote certificate, the slot should call ignoreSslErrors().</para>
                <para>See also QSslSocket::sslErrors(), QNetworkReply::sslErrors(), QNetworkReply::sslConfiguration(), and QNetworkReply::ignoreSslErrors().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAccessManager.Finalize">
            <summary>
                <para>Destroys the QNetworkAccessManager object and frees up any resources. Note that QNetworkReply objects that are returned from this class have this object set as their parents, which means that they will be deleted along with it if you don't call QObject::setParent() on them.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkAddressEntry">
            <summary>
            The QNetworkAddressEntry class stores one IP address supported by a network interface, along with its associated netmask and broadcast address.
            </summary>
            <remarks>
                <para>
                </para>
                <para>Each network interface can contain zero or more IP addresses, which in turn can be associated with a netmask and/or a broadcast address (depending on support from the operating system).</para>
                <para>This class represents one such group.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QNetworkAddressEntry.#ctor">
            <summary>
                <para>Constructs an empty QNetworkAddressEntry object.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAddressEntry.#ctor(QtNetwork.QNetworkAddressEntry)">
            <summary>
                <para>Constructs a QNetworkAddressEntry object that is a copy of the object other.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkAddressEntry.Broadcast">
            <summary>
                <para>Returns the broadcast address associated with the IPv4 address and netmask. It can usually be derived from those two by setting to 1 the bits of the IP address where the netmask contains a 0. (In other words, by bitwise-OR'ing the IP address with the inverse of the netmask)</para>
                <para>This member is always empty for IPv6 addresses, since the concept of broadcast has been abandoned in that system in favor of multicast. In particular, the group of hosts corresponding to all the nodes in the local network can be reached by the "all-nodes" special multicast group (address FF02::1).</para>
                <para>Sets the broadcast IP address of this QNetworkAddressEntry object to newBroadcast.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkAddressEntry.Ip">
            <summary>
                <para>This function returns one IPv4 or IPv6 address found, that was found in a network interface.</para>
                <para>Sets the IP address the QNetworkAddressEntry object contains to newIp.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkAddressEntry.Netmask">
            <summary>
                <para>Returns the netmask associated with the IP address. The netmask is expressed in the form of an IP address, such as 255.255.0.0.</para>
                <para>For IPv6 addresses, the prefix length is converted to an address where the number of bits set to 1 is equal to the prefix length. For a prefix length of 64 bits (the most common value), the netmask will be expressed as a QHostAddress holding the address FFFF:FFFF:FFFF:FFFF::</para>
                <para>Sets the netmask that this QNetworkAddressEntry object contains to newNetmask. Setting the netmask also sets the prefix length to match the new netmask.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkAddressEntry.PrefixLength">
            <summary>
                <para>Returns the prefix length of this IP address. The prefix length matches the number of bits set to 1 in the netmask (see netmask()). For IPv4 addresses, the value is between 0 and 32. For IPv6 addresses, it's contained between 0 and 128 and is the preferred form of representing addresses.</para>
                <para>This function returns -1 if the prefix length could not be determined (i.e., netmask() returns a null QHostAddress()).</para>
                <para>This function was introduced in Qt 4.5.</para>
                <para>Sets the prefix length of this IP address to length. The value of length must be valid for this type of IP address: between 0 and 32 for IPv4 addresses, between 0 and 128 for IPv6 addresses. Setting to any invalid value is equivalent to setting to -1, which means "no prefix length".</para>
                <para>Setting the prefix length also sets the netmask (see netmask()).</para>
                <para>This function was introduced in Qt 4.5.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAddressEntry.Finalize">
            <summary>
                <para>Destroys this QNetworkAddressEntry object.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAddressEntry.op_Inequality(QtNetwork.QNetworkAddressEntry,QtNetwork.QNetworkAddressEntry)">
            <summary>
                <para>Returns true if this network address entry is different from other.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAddressEntry.op_Equality(QtNetwork.QNetworkAddressEntry,QtNetwork.QNetworkAddressEntry)">
            <summary>
                <para>Returns true if this network address entry is the same as other.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkCacheMetaData">
            <summary>
            The QNetworkCacheMetaData class provides cache information.
            </summary>
            <remarks>
                <para>
                </para>
                <para>QNetworkCacheMetaData provides information about a cache file including the url, when it was last modified, when the cache file was created, headers for file and if the file should be saved onto a disk.</para>
                <para>
                </para>
                <para>See also QAbstractNetworkCache.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QNetworkCacheMetaData.#ctor">
            <summary>
                <para>Constructs an invalid network cache meta data.</para>
                <para>See also isValid().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkCacheMetaData.#ctor(QtNetwork.QNetworkCacheMetaData)">
            <summary>
                <para>Constructs a copy of the other QNetworkCacheMetaData.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkCacheMetaData.Attributes">
            <summary>
                <para>Returns all the attributes stored with this cache item.</para>
                <para>This function was introduced in Qt 4.6.</para>
                <para>Sets all attributes of this cache item to be the map attributes.</para>
                <para>This function was introduced in Qt 4.6.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkCacheMetaData.ExpirationDate">
            <summary>
                <para>Returns the date and time when the meta data expires.</para>
                <para>Sets the date and time when the meta data expires to dateTime.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkCacheMetaData.LastModified">
            <summary>
                <para>Returns the date and time when the meta data was last modified.</para>
                <para>Sets the date and time when the meta data was last modified to dateTime.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkCacheMetaData.SaveToDisk">
            <summary>
                <para>Returns is this cache should be allowed to be stored on disk.</para>
                <para>Some cache implementations can keep these cache items in memory for performance reasons, but for security reasons they should not be written to disk.</para>
                <para>Specifically with http, documents marked with Pragma: no-cache, or have a Cache-control set to no-store or no-cache or any https document that doesn't have "Cache-control: public" set will set the saveToDisk to false.</para>
                <para>Sets whether this network cache meta data and associated content should be allowed to be stored on disk to allow.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkCacheMetaData.Url">
            <summary>
                <para>Returns the URL this network cache meta data is referring to.</para>
                <para>Sets the URL this network cache meta data to to be url.</para>
                <para>The password and fragment are removed from the url.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkCacheMetaData.IsValid">
            <summary>
                <para>Returns true if this network cache meta data has attributes that have been set otherwise false.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkCacheMetaData.Finalize">
            <summary>
                <para>Destroys the network cache meta data.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkCacheMetaData.op_Inequality(QtNetwork.QNetworkCacheMetaData,QtNetwork.QNetworkCacheMetaData)">
            <summary>
                <para>Returns true if this meta data is not equal to the other meta data; otherwise returns false.</para>
                <para>See also operator==().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkCacheMetaData.op_Equality(QtNetwork.QNetworkCacheMetaData,QtNetwork.QNetworkCacheMetaData)">
            <summary>
                <para>Returns true if this meta data is equal to the other meta data; otherwise returns false.</para>
                <para>See also operator!=().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkConfiguration">
            <summary>
            The QNetworkConfiguration class provides an abstraction of one or more access point configurations.
            </summary>
            <remarks>
                <para>
                </para>
                <para>QNetworkConfiguration encapsulates a single access point or service network. In most cases a single access point configuration can be mapped to one network interface. However a single network interface may not always map to only one access point configuration. Multiple configurations for the same network device may enable multiple access points. An example device that could exhibit such a configuration might be a Smartphone which allows the user to manage multiple WLAN configurations while the device itself has only one WLAN network device.</para>
                <para>The QNetworkConfiguration also supports the concept of service networks. This concept allows the grouping of multiple access point configurations into one entity. Such a group is called service network and can be beneficial in cases whereby a network session to a particular destination network is required (e.g. a company network). When using a service network the user doesn't usually care which one of the connectivity options is chosen (e.g. corporate WLAN or VPN via GPRS) as long as he can reach the company's target server. Depending on the current position and time some of the access points that make up the service network may not even be available. Furthermore automated access point roaming can be enabled which enables the device to change the network interface configuration dynamically while maintaining the applications connection to the target network. It allows adaption to the changing environment and may enable optimization with regards to cost, speed or other network parameters.</para>
                <para>Special configurations of type UserChoice provide a placeholder configuration which is resolved to an actual network configuration by the platform when a session is opened. Not all platforms support the concept of a user choice configuration.</para>
                <para>
                </para>
                <para>Configuration states</para>
                <para>The list of available configurations can be obtained via QNetworkConfigurationManager::allConfigurations(). A configuration can have multiple states. The Defined configuration state indicates that the configuration is stored on the device. However the configuration is not yet ready to be activated as e.g. a WLAN may not be available at the current time.</para>
                <para>The Discovered state implies that the configuration is Defined and the outside conditions are such that the configuration can be used immediately to open a new network session. An example of such an outside condition may be that the Ethernet cable is actually connected to the device or that the WLAN with the specified SSID is in range.</para>
                <para>The Active state implies that the configuration is Discovered. A configuration in this state is currently being used by an application. The underlying network interface has a valid IP configuration and can transfer IP packets between the device and the target network.</para>
                <para>The Undefined state indicates that the system has knowledge of possible target networks but cannot actually use that knowledge to connect to it. An example for such a state could be an encrypted WLAN that has been discovered but the user hasn't actually saved a configuration including the required password which would allow the device to connect to it.</para>
                <para>Depending on the type of configuration some states are transient in nature. A GPRS/UMTS connection may almost always be Discovered if the GSM/UMTS network is available. However if the GSM/UMTS network looses the connection the associated configuration may change its state from Discovered to Defined as well. A similar use case might be triggered by WLAN availability. QNetworkConfigurationManager::updateConfigurations() can be used to manually trigger updates of states. Note that some platforms do not require such updates as they implicitly change the state once it has been discovered. If the state of a configuration changes all related QNetworkConfiguration instances change their state automatically.</para>
                <para>
                </para>
                <para>See also QNetworkSession and QNetworkConfigurationManager.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QNetworkConfiguration.#ctor">
            <summary>
                <para>Constructs an invalid configuration object.</para>
                <para>See also isValid().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkConfiguration.#ctor(QtNetwork.QNetworkConfiguration)">
            <summary>
                <para>Creates a copy of the QNetworkConfiguration object contained in other.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkConfiguration.BearerType">
            <summary>
                <para>Specifies the type of bearer used by a configuration.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.BearerType.Bearer2G">
            <summary>
                <para>The configuration is for a CSD, GPRS, HSCSD, EDGE or cdmaOne interface.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.BearerType.BearerBluetooth">
            <summary>
                <para>The configuration is for a Bluetooth interface.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.BearerType.BearerCDMA2000">
            <summary>
                <para>The configuration is for CDMA interface.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.BearerType.BearerEthernet">
            <summary>
                <para>The configuration is for an Ethernet interfaces.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.BearerType.BearerHSPA">
            <summary>
                <para>The configuration is for High Speed Packet Access (HSPA) interface.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.BearerType.BearerUnknown">
            <summary>
                <para>The type of bearer is unknown or unspecified. The bearerTypeName() function may return additional information.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.BearerType.BearerWCDMA">
            <summary>
                <para>The configuration is for W-CDMA/UMTS interface.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.BearerType.BearerWLAN">
            <summary>
                <para>The configuration is for a Wireless LAN interface.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.BearerType.BearerWiMAX">
            <summary>
                <para>The configuration is for a WiMAX interface.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkConfiguration.Purpose">
            <summary>
                <para>Specifies the purpose of the configuration.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.Purpose.PrivatePurpose">
            <summary>
                <para>The configuration is suitable to access a private network such as an office Intranet.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.Purpose.PublicPurpose">
            <summary>
                <para>The configuration can be used for general purpose internet access.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.Purpose.ServiceSpecificPurpose">
            <summary>
                <para>The configuration can be used for operator specific services (e.g. receiving MMS messages or content streaming).</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.Purpose.UnknownPurpose">
            <summary>
                <para>The configuration doesn't specify any purpose. This is the default value.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkConfiguration.StateFlag">
            <summary>
                <para>Specifies the configuration states.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.StateFlag.Active">
            <summary>
                <para>The configuration is currently used by an open network session (see QNetworkSession::isOpen()). However this does not mean that the current process is the entity that created the open session. It merely indicates that if a new QNetworkSession were to be constructed based on this configuration QNetworkSession::state() would return QNetworkSession::Connected. This state implies the QNetworkConfiguration::Discovered state.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.StateFlag.Defined">
            <summary>
                <para>Defined configurations are known to the system but are not immediately usable (e.g. a configured WLAN is not within range or the Ethernet cable is currently not plugged into the machine).</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.StateFlag.Discovered">
            <summary>
                <para>A discovered configuration can be immediately used to create a new QNetworkSession. An example of a discovered configuration could be a WLAN which is within in range. If the device moves out of range the discovered flag is dropped. A second example is a GPRS configuration which generally remains discovered for as long as the device has network coverage. A configuration that has this state is also in state QNetworkConfiguration::Defined. If the configuration is a service network this flag is set if at least one of the underlying access points configurations has the Discovered state.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.StateFlag.Undefined">
            <summary>
                <para>This state is used for transient configurations such as newly discovered WLANs for which the user has not actually created a configuration yet.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkConfiguration.Type">
            <summary>
                <para>This enum describes the type of configuration.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.Type.InternetAccessPoint">
            <summary>
                <para>The configuration specifies the details for a single access point. Note that configurations of type InternetAccessPoint may be part of other QNetworkConfigurations of type ServiceNetwork.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.Type.Invalid">
            <summary>
                <para>The configuration is invalid.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.Type.ServiceNetwork">
            <summary>
                <para>The configuration is based on a group of QNetworkConfigurations of type InternetAccessPoint. All group members can reach the same target network. This type of configuration is a mandatory requirement for roaming enabled network sessions. On some platforms this form of configuration may also be called Service Network Access Point (SNAP).</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.Type.UserChoice">
            <summary>
                <para>The configuration is a placeholder which will be resolved to an actual configuration by the platform when a session is opened. Depending on the platform the selection may generate a popup dialog asking the user for his preferred choice.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkConfiguration.BearerName">
            <summary>
                <para>This function is deprecated.</para>
                <para>This function is deprecated. It is equivalent to calling bearerTypeName(), however bearerType() should be used in preference.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkConfiguration.bearerType">
            <summary>
                <para>Returns the type of bearer used by this network configuration.</para>
                <para>If the bearer type is unknown the bearerTypeName() function can be used to retrieve a textural type name for the bearer.</para>
                <para>An invalid network configuration always returns the BearerUnknown value.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkConfiguration.BearerTypeName">
            <summary>
                <para>Returns the type of bearer used by this network configuration as a string.</para>
                <para>The string is not translated and therefore can not be shown to the user. The subsequent table shows the fixed mappings between BearerType and the bearer type name for known types. If the BearerType is unknown this function may return additional information if it is available; otherwise an empty string will be returned.</para>
                <para>
                </para>
                <para>BearerTypeValue</para>
                <para>BearerUnknown	The session is based on an unknown or unspecified bearer type. The value of the string returned describes the bearer type.</para>
                <para>BearerEthernet	Ethernet</para>
                <para>BearerWLAN	WLAN</para>
                <para>Bearer2G	2G</para>
                <para>BearerCDMA2000	CDMA2000</para>
                <para>BearerWCDMA	WCDMA</para>
                <para>BearerHSPA	HSPA</para>
                <para>BearerBluetooth	Bluetooth</para>
                <para>BearerWiMAX	WiMAX</para>
                <para>
                </para>
                <para>This function returns an empty string if this is an invalid configuration, a network configuration of type QNetworkConfiguration::ServiceNetwork or QNetworkConfiguration::UserChoice.</para>
                <para>See also bearerType().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkConfiguration.Children">
            <summary>
                <para>Returns all sub configurations of this network configuration in priority order. The first sub configuration in the list has the highest priority.</para>
                <para>Only network configurations of type ServiceNetwork can have children. Otherwise this function returns an empty list.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkConfiguration.Identifier">
            <summary>
                <para>Returns the unique and platform specific identifier for this network configuration; otherwise an empty string.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkConfiguration.IsRoamingAvailable">
            <summary>
                <para>Returns true if this configuration supports roaming; otherwise false.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkConfiguration.IsValid">
            <summary>
                <para>Returns true if this QNetworkConfiguration object is valid. A configuration may become invalid if the user deletes the configuration or the configuration was default-constructed.</para>
                <para>The addition and removal of configurations can be monitored via the QNetworkConfigurationManager.</para>
                <para>See also QNetworkConfigurationManager.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkConfiguration.Name">
            <summary>
                <para>Returns the user visible name of this configuration.</para>
                <para>The name may either be the name of the underlying access point or the name for service network that this configuration represents.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkConfiguration.purpose">
            <summary>
                <para>Returns the purpose of this configuration.</para>
                <para>The purpose field may be used to programmatically determine the purpose of a configuration. Such information is usually part of the access point or service network meta data.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkConfiguration.State">
            <summary>
                <para>Returns the current state of the configuration.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkConfiguration.type">
            <summary>
                <para>Returns the type of the configuration.</para>
                <para>A configuration can represent a single access point configuration or a set of access point configurations. Such a set is called service network. A configuration that is based on a service network can potentially support roaming of network sessions.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkConfiguration.Finalize">
            <summary>
                <para>Frees the resources associated with the QNetworkConfiguration object.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkConfiguration.op_Inequality(QtNetwork.QNetworkConfiguration,QtNetwork.QNetworkConfiguration)">
            <summary>
                <para>Returns true if this configuration is not the same as the other configuration given; otherwise returns false.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkConfiguration.op_Equality(QtNetwork.QNetworkConfiguration,QtNetwork.QNetworkConfiguration)">
            <summary>
                <para>Returns true, if this configuration is the same as the other configuration given; otherwise returns false.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkConfigurationManager">
            <summary>
            The QNetworkConfigurationManager class manages the network configurations provided by the system.
            </summary>
            <remarks>
                <para>
                </para>
                <para>QNetworkConfigurationManager provides access to the network configurations known to the system and enables applications to detect the system capabilities (with regards to network sessions) at runtime.</para>
                <para>A QNetworkConfiguration abstracts a set of configuration options describing how a network interface has to be configured to connect to a particular target network. QNetworkConfigurationManager maintains and updates the global list of QNetworkConfigurations. Applications can access and filter this list via allConfigurations(). If a new configuration is added or an existing one is removed or changed the configurationAdded(), configurationRemoved() and configurationChanged() signals are emitted respectively.</para>
                <para>The defaultConfiguration() can be used when intending to immediately create a new network session without caring about the particular configuration. It returns a QNetworkConfiguration::Discovered configuration. If there are not any discovered ones an invalid configuration is returned.</para>
                <para>Some configuration updates may require some time to perform updates. A WLAN scan is such an example. Unless the platform performs internal updates it may be required to manually trigger configuration updates via QNetworkConfigurationManager::updateConfigurations(). The completion of the update process is indicted by emitting the updateCompleted() signal. The update process ensures that every existing QNetworkConfiguration instance is updated. There is no need to ask for a renewed configuration list via allConfigurations().</para>
                <para>
                </para>
                <para>See also QNetworkConfiguration.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QNetworkConfigurationManager.#ctor(QtCore.QObject)">
            <summary>
                <para>Constructs a QNetworkConfigurationManager with the given parent.</para>
                <para>Note that to ensure a valid list of current configurations immediately available, updating is done during construction which causes some delay.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkConfigurationManager.Capability">
            <summary>
                <para>Specifies the system capabilities of the bearer API. The possible values are:</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfigurationManager.Capability.ApplicationLevelRoaming">
            <summary>
                <para>The system gives applications control over the systems roaming behavior. Applications can initiate roaming (in case the current link is not suitable) and are consulted if the system has identified a more suitable access point.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfigurationManager.Capability.CanStartAndStopInterfaces">
            <summary>
                <para>Network sessions and their underlying access points can be started and stopped. If this flag is not set QNetworkSession can only monitor but not influence the state of access points. On some platforms this feature may require elevated user permissions. This option is platform specific and may not always be available.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfigurationManager.Capability.DataStatistics">
            <summary>
                <para>If this flag is set QNetworkSession can provide statistics about transmitted and received data.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfigurationManager.Capability.DirectConnectionRouting">
            <summary>
                <para>Network sessions and their sockets can be bound to a particular network interface. Any packet that passes through the socket goes to the specified network interface and thus disregards standard routing table entries. This may be useful when two interfaces can reach overlapping IP ranges or an application has specific needs in regards to target networks. This option is platform specific and may not always be available.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfigurationManager.Capability.ForcedRoaming">
            <summary>
                <para>The system disconnects an existing access point and reconnects via a more suitable one. The application does not have any control over this process and has to reconnect its active sockets.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfigurationManager.Capability.NetworkSessionRequired">
            <summary>
                <para>If this flag is set the platform requires that a network session is created before network operations can be performed.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfigurationManager.Capability.SystemSessionSupport">
            <summary>
                <para>If this flag is set the underlying platform ensures that a network interface is not shut down until the last network session has been closed(). This works across multiple processes. If the platform session support is missing this API can only ensure the above behavior for network sessions within the same process. In general mobile platforms (such as Symbian/S60) have such support whereas most desktop platform lack this capability.</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkConfigurationManager.ConfigurationAdded">
            <summary>
                <para>This signal is emitted whenever a new network configuration is added to the system. The new configuration is specified by config.</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkConfigurationManager.ConfigurationRemoved">
            <summary>
                <para>This signal is emitted when a configuration is about to be removed from the system. The removed configuration, specified by config, is invalid but retains name and identifier.</para>
                <para>This function was introduced in Qt 4.8.</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkConfigurationManager.ConfigurationChanged">
            <summary>
                <para>This signal is emitted when the state of config changes.</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkConfigurationManager.OnlineStateChanged">
            <summary>
                <para>This signal is emitted when the device changes from online to offline mode or vice versa. isOnline represents the new state of the device.</para>
                <para>The state is considered to be online for as long as allConfigurations(QNetworkConfiguration::Active) returns a list with at least one entry.</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkConfigurationManager.UpdateCompleted">
            <summary>
                <para>This signal is emitted when the configuration update has been completed. Such an update can be initiated via updateConfigurations().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkConfigurationManager.Capabilities">
            <summary>
                <para>Returns the capabilities supported by the current platform.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkConfigurationManager.DefaultConfiguration">
            <summary>
                <para>Returns the default configuration to be used. This function always returns a discovered configuration; otherwise an invalid configuration.</para>
                <para>In some cases it may be required to call updateConfigurations() and wait for the updateCompleted() signal before calling this function.</para>
                <para>See also allConfigurations().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkConfigurationManager.IsOnline">
            <summary>
                <para>Returns true if the system is considered to be connected to another device via an active network interface; otherwise returns false.</para>
                <para>This is equivalent to the following code snippet:</para>
                <para> QNetworkConfigurationManager mgr;</para>
                <para> QList&lt;QNetworkConfiguration&gt; activeConfigs = mgr.allConfigurations(QNetworkConfiguration::Active)</para>
                <para> if (activeConfigs.count() &gt; 0)</para>
                <para>     Q_ASSERT(mgr.isOnline())</para>
                <para> else</para>
                <para>     Q_ASSERT(!mgr.isOnline())</para>
                <para>See also onlineStateChanged().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkConfigurationManager.AllConfigurations(QtNetwork.QNetworkConfiguration.StateFlag)">
            <summary>
                <para>Returns the list of configurations which comply with the given filter.</para>
                <para>By default this function returns all (defined and undefined) configurations.</para>
                <para>A wireless network with a particular SSID may only be accessible in a certain area despite the fact that the system has a valid configuration for it. Therefore the filter flag may be used to limit the list to discovered and possibly connected configurations only.</para>
                <para>If filter is set to zero this function returns all possible configurations.</para>
                <para>Note that this function returns the states for all configurations as they are known at the time of this function call. If for instance a configuration of type WLAN is defined the system may have to perform a WLAN scan in order to determine whether it is actually available. To obtain the most accurate state updateConfigurations() should be used to update each configuration's state. Note that such an update may require some time. It's completion is signalled by updateCompleted(). In the absence of a configuration update this function returns the best estimate at the time of the call. Therefore, if WLAN configurations are of interest, it is recommended that updateConfigurations() is called once after QNetworkConfigurationManager instantiation (WLAN scans are too time consuming to perform in constructor). After this the data is kept automatically up-to-date as the system reports any changes.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkConfigurationManager.OnConfigurationAdded(QtNetwork.QNetworkConfiguration)">
            <summary>
                <para>This signal is emitted whenever a new network configuration is added to the system. The new configuration is specified by config.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkConfigurationManager.OnConfigurationChanged(QtNetwork.QNetworkConfiguration)">
            <summary>
                <para>This signal is emitted when the state of config changes.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkConfigurationManager.ConfigurationFromIdentifier(System.String)">
            <summary>
                <para>Returns the QNetworkConfiguration for identifier; otherwise returns an invalid QNetworkConfiguration.</para>
                <para>See also QNetworkConfiguration::identifier().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkConfigurationManager.OnConfigurationRemoved(QtNetwork.QNetworkConfiguration)">
            <summary>
                <para>This signal is emitted when a configuration is about to be removed from the system. The removed configuration, specified by config, is invalid but retains name and identifier.</para>
                <para>This function was introduced in Qt 4.8.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkConfigurationManager.OnOnlineStateChanged(System.Boolean)">
            <summary>
                <para>This signal is emitted when the device changes from online to offline mode or vice versa. isOnline represents the new state of the device.</para>
                <para>The state is considered to be online for as long as allConfigurations(QNetworkConfiguration::Active) returns a list with at least one entry.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkConfigurationManager.OnUpdateCompleted">
            <summary>
                <para>This signal is emitted when the configuration update has been completed. Such an update can be initiated via updateConfigurations().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkConfigurationManager.UpdateConfigurations">
            <summary>
                <para>Initiates an update of all configurations. This may be used to initiate WLAN scans or other time consuming updates which may be required to obtain the correct state for configurations.</para>
                <para>This call is asynchronous. On completion of this update the updateCompleted() signal is emitted. If new configurations are discovered or old ones were removed or changed the update process may trigger the emission of one or multiple configurationAdded(), configurationRemoved() and configurationChanged() signals.</para>
                <para>If a configuration state changes as a result of this update all existing QNetworkConfiguration instances are updated automatically.</para>
                <para>See also allConfigurations().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkConfigurationManager.Finalize">
            <summary>
                <para>Frees the resources associated with the QNetworkConfigurationManager object.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkCookie">
            <summary>
            The QNetworkCookie class holds one network cookie.
            </summary>
            <remarks>
                <para>
                </para>
                <para>Cookies are small bits of information that stateless protocols like HTTP use to maintain some persistent information across requests.</para>
                <para>A cookie is set by a remote server when it replies to a request and it expects the same cookie to be sent back when further requests are sent.</para>
                <para>QNetworkCookie holds one such cookie as received from the network. A cookie has a name and a value, but those are opaque to the application (that is, the information stored in them has no meaning to the application). A cookie has an associated path name and domain, which indicate when the cookie should be sent again to the server.</para>
                <para>A cookie can also have an expiration date, indicating its validity. If the expiration date is not present, the cookie is considered a "session cookie" and should be discarded when the application exits (or when its concept of session is over).</para>
                <para>QNetworkCookie provides a way of parsing a cookie from the HTTP header format using the QNetworkCookie::parseCookies() function. However, when received in a QNetworkReply, the cookie is already parsed.</para>
                <para>This class implements cookies as described by the initial cookie specification by Netscape, which is somewhat similar to the RFC 2109 specification, plus the "HttpOnly" extension. The more recent RFC 2965 specification (which uses the Set-Cookie2 header) is not supported.</para>
                <para>
                </para>
                <para>See also QNetworkCookieJar, QNetworkRequest, and QNetworkReply.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QNetworkCookie.#ctor">
            <summary>
                <para>Create a new QNetworkCookie object, initializing the cookie name to name and its value to value.</para>
                <para>A cookie is only valid if it has a name. However, the value is opaque to the application and being empty may have significance to the remote server.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkCookie.#ctor(QtNetwork.QNetworkCookie)">
            <summary>
                <para>Creates a new QNetworkCookie object by copying the contents of other.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkCookie.#ctor(QtCore.QByteArray)">
            <summary>
                <para>Create a new QNetworkCookie object, initializing the cookie name to name and its value to value.</para>
                <para>A cookie is only valid if it has a name. However, the value is opaque to the application and being empty may have significance to the remote server.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkCookie.#ctor(QtCore.QByteArray,QtCore.QByteArray)">
            <summary>
                <para>Create a new QNetworkCookie object, initializing the cookie name to name and its value to value.</para>
                <para>A cookie is only valid if it has a name. However, the value is opaque to the application and being empty may have significance to the remote server.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkCookie.RawForm">
            <summary>
                <para>This enum is used with the toRawForm() function to declare which form of a cookie shall be returned.</para>
                <para>Note that only the Full form of the cookie can be parsed back into its original contents.</para>
                <para>See also toRawForm() and parseCookies().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkCookie.RawForm.Full">
            <summary>
                <para>Makes toRawForm() return the full cookie contents, as suitable for sending to a client in a server's "Set-Cookie:" header.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkCookie.RawForm.NameAndValueOnly">
            <summary>
                <para>Makes toRawForm() return only the "NAME=VALUE" part of the cookie, as suitable for sending back to a server in a client request's "Cookie:" header. Multiple cookies are separated by a semi-colon in the "Cookie:" header field.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkCookie.Domain">
            <summary>
                <para>Returns the domain this cookie is associated with. This corresponds to the "domain" field of the cookie string.</para>
                <para>Note that the domain here may start with a dot, which is not a valid hostname. However, it means this cookie matches all hostnames ending with that domain name.</para>
                <para>Sets the domain associated with this cookie to be domain.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkCookie.ExpirationDate">
            <summary>
                <para>Returns the expiration date for this cookie. If this cookie is a session cookie, the QDateTime returned will not be valid. If the date is in the past, this cookie has already expired and should not be sent again back to a remote server.</para>
                <para>The expiration date corresponds to the parameters of the "expires" entry in the cookie string.</para>
                <para>Sets the expiration date of this cookie to date. Setting an invalid expiration date to this cookie will mean it's a session cookie.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkCookie.Name">
            <summary>
                <para>Returns the name of this cookie. The only mandatory field of a cookie is its name, without which it is not considered valid.</para>
                <para>Sets the name of this cookie to be cookieName. Note that setting a cookie name to an empty QByteArray will make this cookie invalid.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkCookie.Path">
            <summary>
                <para>Returns the path associated with this cookie. This corresponds to the "path" field of the cookie string.</para>
                <para>Sets the path associated with this cookie to be path.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkCookie.Value">
            <summary>
                <para>Returns this cookies value, as specified in the cookie string. Note that a cookie is still valid if its value is empty.</para>
                <para>Cookie name-value pairs are considered opaque to the application: that is, their values don't mean anything.</para>
                <para>Sets the value of this cookie to be value.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkCookie.IsHttpOnly">
            <summary>
                <para>Returns true if the "HttpOnly" flag is enabled for this cookie.</para>
                <para>A cookie that is "HttpOnly" is only set and retrieved by the network requests and replies; i.e., the HTTP protocol. It is not accessible from scripts running on browsers.</para>
                <para>This function was introduced in Qt 4.5.</para>
                <para>See also isSecure().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkCookie.IsSecure">
            <summary>
                <para>Returns true if the "secure" option was specified in the cookie string, false otherwise.</para>
                <para>Secure cookies may contain private information and should not be resent over unencrypted connections.</para>
                <para>See also setSecure().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkCookie.IsSessionCookie">
            <summary>
                <para>Returns true if this cookie is a session cookie. A session cookie is a cookie which has no expiration date, which means it should be discarded when the application's concept of session is over (usually, when the application exits).</para>
                <para>See also expirationDate() and setExpirationDate().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkCookie.ParseCookies(QtCore.QByteArray)">
            <summary>
                <para>Parses the cookie string cookieString as received from a server response in the "Set-Cookie:" header. If there's a parsing error, this function returns an empty list.</para>
                <para>Since the HTTP header can set more than one cookie at the same time, this function returns a QList&lt;QNetworkCookie&gt;, one for each cookie that is parsed.</para>
                <para>See also toRawForm().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkCookie.SetHttpOnly(System.Boolean)">
            <summary>
                <para>Sets this cookie's "HttpOnly" flag to enable.</para>
                <para>This function was introduced in Qt 4.5.</para>
                <para>See also isHttpOnly().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkCookie.SetSecure(System.Boolean)">
            <summary>
                <para>Sets the secure flag of this cookie to enable.</para>
                <para>Secure cookies may contain private information and should not be resent over unencrypted connections.</para>
                <para>See also isSecure().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkCookie.ToRawForm(QtNetwork.QNetworkCookie.RawForm)">
            <summary>
                <para>Returns the raw form of this QNetworkCookie. The QByteArray returned by this function is suitable for an HTTP header, either in a server response (the Set-Cookie header) or the client request (the Cookie header). You can choose from one of two formats, using form.</para>
                <para>See also parseCookies().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkCookie.Finalize">
            <summary>
                <para>Destroys this QNetworkCookie object.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkCookie.op_Inequality(QtNetwork.QNetworkCookie,QtNetwork.QNetworkCookie)">
            <summary>
                <para>Returns true if this cookie is not equal to other.</para>
                <para>See also operator==().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkCookie.op_Equality(QtNetwork.QNetworkCookie,QtNetwork.QNetworkCookie)">
            <summary>
                <para>Returns true if this cookie is equal to other. This function only returns true if all fields of the cookie are the same.</para>
                <para>However, in some contexts, two cookies of the same name could be considered equal.</para>
                <para>See also operator!=().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkCookieJar">
            <summary>
            The QNetworkCookieJar class implements a simple jar of QNetworkCookie objects
            </summary>
            <remarks>
                <para>
                </para>
                <para>Cookies are small bits of information that stateless protocols like HTTP use to maintain some persistent information across requests.</para>
                <para>A cookie is set by a remote server when it replies to a request and it expects the same cookie to be sent back when further requests are sent.</para>
                <para>The cookie jar is the object that holds all cookies set in previous requests. Web browsers save their cookie jars to disk in order to conserve permanent cookies across invocations of the application.</para>
                <para>QNetworkCookieJar does not implement permanent storage: it only keeps the cookies in memory. Once the QNetworkCookieJar object is deleted, all cookies it held will be discarded as well. If you want to save the cookies, you should derive from this class and implement the saving to disk to your own storage format.</para>
                <para>This class implements only the basic security recommended by the cookie specifications and does not implement any cookie acceptance policy (it accepts all cookies set by any requests). In order to override those rules, you should reimplement the cookiesForUrl() and setCookiesFromUrl() virtual functions. They are called by QNetworkReply and QNetworkAccessManager when they detect new cookies and when they require cookies.</para>
                <para>
                </para>
                <para>See also QNetworkCookie, QNetworkAccessManager, QNetworkReply, QNetworkRequest, and QNetworkAccessManager::setCookieJar().</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QNetworkCookieJar.#ctor(QtCore.QObject)">
            <summary>
                <para>Creates a QNetworkCookieJar object and sets the parent object to be parent.</para>
                <para>The cookie jar is initialized to empty.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkCookieJar.AllCookies">
            <summary>
                <para>Returns all cookies stored in this cookie jar. This function is suitable for derived classes to save cookies to disk, as well as to implement cookie expiration and other policies.</para>
                <para>Sets the internal list of cookies held by this cookie jar to be cookieList. This function is suitable for derived classes to implement loading cookies from permanent storage, or their own cookie acceptance policies by reimplementing setCookiesFromUrl().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkCookieJar.CookiesForUrl(QtCore.QUrl)">
            <summary>
                <para>Returns the cookies to be added to when a request is sent to url. This function is called by the default QNetworkAccessManager::createRequest(), which adds the cookies returned by this function to the request being sent.</para>
                <para>If more than one cookie with the same name is found, but with differing paths, the one with longer path is returned before the one with shorter path. In other words, this function returns cookies sorted decreasingly by path length.</para>
                <para>The default QNetworkCookieJar class implements only a very basic security policy (it makes sure that the cookies' domain and path match the reply's). To enhance the security policy with your own algorithms, override cookiesForUrl().</para>
                <para>See also setCookiesFromUrl() and QNetworkAccessManager::setCookieJar().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkCookieJar.SetCookiesFromUrl(System.Collections.Generic.List{QtNetwork.QNetworkCookie},QtCore.QUrl)">
            <summary>
                <para>Adds the cookies in the list cookieList to this cookie jar. Default values for path and domain are taken from the url object.</para>
                <para>Returns true if one or more cookies are set for url, otherwise false.</para>
                <para>If a cookie already exists in the cookie jar, it will be overridden by those in cookieList.</para>
                <para>The default QNetworkCookieJar class implements only a very basic security policy (it makes sure that the cookies' domain and path match the reply's). To enhance the security policy with your own algorithms, override setCookiesFromUrl().</para>
                <para>Also, QNetworkCookieJar does not have a maximum cookie jar size. Reimplement this function to discard older cookies to create room for new ones.</para>
                <para>See also cookiesForUrl() and QNetworkAccessManager::setCookieJar().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkCookieJar.Finalize">
            <summary>
                <para>Destroys this cookie jar object and discards all cookies stored in it. Cookies are not saved to disk in the QNetworkCookieJar default implementation.</para>
                <para>If you need to save the cookies to disk, you have to derive from QNetworkCookieJar and save the cookies to disk yourself.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkDiskCache">
            <summary>
            The QNetworkDiskCache class provides a very basic disk cache.
            </summary>
            <remarks>
                <para>
                </para>
                <para>QNetworkDiskCache stores each url in its own file inside of the cacheDirectory using QDataStream. Files with a text MimeType are compressed using qCompress. Each cache file starts with "cache_" and ends in ".cache". Data is written to disk only in insert() and updateMetaData().</para>
                <para>Currently you can not share the same cache files with more then one disk cache.</para>
                <para>QNetworkDiskCache by default limits the amount of space that the cache will use on the system to 50MB.</para>
                <para>Note you have to set the cache directory before it will work.</para>
                <para>A network disk cache can be enabled by:</para>
                <para> QNetworkAccessManager *manager = new QNetworkAccessManager(this);</para>
                <para> QNetworkDiskCache *diskCache = new QNetworkDiskCache(this);</para>
                <para> diskCache-&gt;setCacheDirectory("cacheDir");</para>
                <para> manager-&gt;setCache(diskCache);</para>
                <para>When sending requests, to control the preference of when to use the cache and when to use the network, consider the following:</para>
                <para> // do a normal request (preferred from network, as this is the default)</para>
                <para> QNetworkRequest request(QUrl(QString("http://qt.nokia.com")));</para>
                <para> manager-&gt;get(request);</para>
                <para>
                </para>
                <para> // do a request preferred from cache</para>
                <para> QNetworkRequest request2(QUrl(QString("http://qt.nokia.com")));</para>
                <para> request2.setAttribute(QNetworkRequest::CacheLoadControlAttribute, QNetworkRequest::PreferCache);</para>
                <para> manager-&gt;get(request2);</para>
                <para>To check whether the response came from the cache or from the network, the following can be applied:</para>
                <para> void replyFinished(QNetworkReply *reply) {</para>
                <para>     QVariant fromCache = reply-&gt;attribute(QNetworkRequest::SourceIsFromCacheAttribute);</para>
                <para>     qDebug() &lt;&lt; "page from cache?" &lt;&lt; fromCache.toBool();</para>
                <para> }</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QNetworkDiskCache.#ctor(QtCore.QObject)">
            <summary>
                <para>Creates a new disk cache. The parent argument is passed to QAbstractNetworkCache's constructor.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkDiskCache.CacheDirectory">
            <summary>
                <para>Returns the location where cached files will be stored.</para>
                <para>Sets the directory where cached files will be stored to cacheDir</para>
                <para>QNetworkDiskCache will create this directory if it does not exists.</para>
                <para>Prepared cache items will be stored in the new cache directory when they are inserted.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkDiskCache.MaximumCacheSize">
            <summary>
                <para>Returns the current maximum size in bytes for the disk cache.</para>
                <para>Sets the maximum size of the disk cache to be size in bytes.</para>
                <para>If the new size is smaller then the current cache size then the cache will call expire().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkDiskCache.CacheSize">
            <summary>
                <para>Reimplemented from QAbstractNetworkCache::cacheSize().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkDiskCache.Clear">
            <summary>
                <para>Reimplemented from QAbstractNetworkCache::clear().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkDiskCache.Data(QtCore.QUrl)">
            <summary>
                <para>Reimplemented from QAbstractNetworkCache::data().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkDiskCache.Expire">
            <summary>
                <para>Cleans the cache so that its size is under the maximum cache size. Returns the current size of the cache.</para>
                <para>When the current size of the cache is greater than the maximumCacheSize() older cache files are removed until the total size is less then 90% of maximumCacheSize() starting with the oldest ones first using the file creation date to determine how old a cache file is.</para>
                <para>Subclasses can reimplement this function to change the order that cache files are removed taking into account information in the application knows about that QNetworkDiskCache does not, for example the number of times a cache is accessed.</para>
                <para>Note: cacheSize() calls expire if the current cache size is unknown.</para>
                <para>See also maximumCacheSize() and fileMetaData().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkDiskCache.FileMetaData(System.String)">
            <summary>
                <para>Returns the QNetworkCacheMetaData for the cache file fileName.</para>
                <para>If fileName is not a cache file QNetworkCacheMetaData will be invalid.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkDiskCache.Insert(QtCore.QIODevice)">
            <summary>
                <para>Reimplemented from QAbstractNetworkCache::insert().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkDiskCache.MetaData(QtCore.QUrl)">
            <summary>
                <para>Reimplemented from QAbstractNetworkCache::metaData().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkDiskCache.Prepare(QtNetwork.QNetworkCacheMetaData)">
            <summary>
                <para>Reimplemented from QAbstractNetworkCache::prepare().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkDiskCache.Remove(QtCore.QUrl)">
            <summary>
                <para>Reimplemented from QAbstractNetworkCache::remove().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkDiskCache.UpdateMetaData(QtNetwork.QNetworkCacheMetaData)">
            <summary>
                <para>Reimplemented from QAbstractNetworkCache::updateMetaData().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkDiskCache.Finalize">
            <summary>
                <para>Destroys the cache object. This does not clear the disk cache.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkInterface">
            <summary>
            The QNetworkInterface class provides a listing of the host's IP addresses and network interfaces.
            </summary>
            <remarks>
                <para>
                </para>
                <para>QNetworkInterface represents one network interface attached to the host where the program is being run. Each network interface may contain zero or more IP addresses, each of which is optionally associated with a netmask and/or a broadcast address. The list of such trios can be obtained with addressEntries(). Alternatively, when the netmask or the broadcast addresses aren't necessary, use the allAddresses() convenience function to obtain just the IP addresses.</para>
                <para>QNetworkInterface also reports the interface's hardware address with hardwareAddress().</para>
                <para>Not all operating systems support reporting all features. Only the IPv4 addresses are guaranteed to be listed by this class in all platforms. In particular, IPv6 address listing is only supported on Windows XP and more recent versions, Linux, MacOS X and the BSDs.</para>
                <para>
                </para>
                <para>See also QNetworkAddressEntry.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QNetworkInterface.#ctor">
            <summary>
                <para>Constructs an empty network interface object.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkInterface.#ctor(QtNetwork.QNetworkInterface)">
            <summary>
                <para>Creates a copy of the QNetworkInterface object contained in other.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkInterface.InterfaceFlag">
            <summary>
                <para>Specifies the flags associated with this network interface. The possible values are:</para>
                <para>Note that one network interface cannot be both broadcast-based and point-to-point.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkInterface.InterfaceFlag.CanBroadcast">
            <summary>
                <para>The network interface works in broadcast mode</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkInterface.InterfaceFlag.CanMulticast">
            <summary>
                <para>The network interface supports multicasting</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkInterface.InterfaceFlag.IsLoopBack">
            <summary>
                <para>The network interface is a loopback interface: that is, it's a virtual interface whose destination is the host computer itself</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkInterface.InterfaceFlag.IsPointToPoint">
            <summary>
                <para>The network interface is a point-to-point interface: that is, there is one, single other address that can be directly reached by it.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkInterface.InterfaceFlag.IsRunning">
            <summary>
                <para>The network interface has resources allocated</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkInterface.InterfaceFlag.IsUp">
            <summary>
                <para>The network interface is active</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkInterface.AddressEntries">
            <summary>
                <para>Returns the list of IP addresses that this interface possesses along with their associated netmasks and broadcast addresses.</para>
                <para>If the netmask or broadcast address information is not necessary, you can call the allAddresses() function to obtain just the IP addresses.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkInterface.AllAddresses">
            <summary>
                <para>This convenience function returns all IP addresses found on the host machine. It is equivalent to calling addressEntries() on all the objects returned by allInterfaces() to obtain lists of QHostAddress objects then calling QHostAddress::ip() on each of these.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkInterface.AllInterfaces">
            <summary>
                <para>Returns a listing of all the network interfaces found on the host machine.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkInterface.Flags">
            <summary>
                <para>Returns the flags associated with this network interface.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkInterface.HardwareAddress">
            <summary>
                <para>Returns the low-level hardware address for this interface. On Ethernet interfaces, this will be a MAC address in string representation, separated by colons.</para>
                <para>Other interface types may have other types of hardware addresses. Implementations should not depend on this function returning a valid MAC address.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkInterface.HumanReadableName">
            <summary>
                <para>Returns the human-readable name of this network interface on Windows, such as "Local Area Connection", if the name could be determined. If it couldn't, this function returns the same as name(). The human-readable name is a name that the user can modify in the Windows Control Panel, so it may change during the execution of the program.</para>
                <para>On Unix, this function currently always returns the same as name(), since Unix systems don't store a configuration for human-readable names.</para>
                <para>This function was introduced in Qt 4.5.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkInterface.Index">
            <summary>
                <para>Returns the interface system index, if known. This is an integer assigned by the operating system to identify this interface and it generally doesn't change. It matches the scope ID field in IPv6 addresses.</para>
                <para>If the index isn't known, this function returns 0.</para>
                <para>This function was introduced in Qt 4.5.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkInterface.IsValid">
            <summary>
                <para>Returns true if this QNetworkInterface object contains valid information about a network interface.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkInterface.Name">
            <summary>
                <para>Returns the name of this network interface. On Unix systems, this is a string containing the type of the interface and optionally a sequence number, such as "eth0", "lo" or "pcn0". On Windows, it's an internal ID that cannot be changed by the user.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkInterface.InterfaceFromIndex(System.Int32)">
            <summary>
                <para>Returns a QNetworkInterface object for the interface whose internal ID is index. Network interfaces have a unique identifier called the "interface index" to distinguish it from other interfaces on the system. Often, this value is assigned progressively and interfaces being removed and then added again get a different value every time.</para>
                <para>This index is also found in the IPv6 address' scope ID field.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkInterface.InterfaceFromName(System.String)">
            <summary>
                <para>Returns a QNetworkInterface object for the interface named name. If no such interface exists, this function returns an invalid QNetworkInterface object.</para>
                <para>See also name() and isValid().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkInterface.Finalize">
            <summary>
                <para>Frees the resources associated with the QNetworkInterface object.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkProxy">
            <summary>
            The QNetworkProxy class provides a network layer proxy.
            </summary>
            <remarks>
                <para>
                </para>
                <para>QNetworkProxy provides the method for configuring network layer proxy support to the Qt network classes. The currently supported classes are QAbstractSocket, QTcpSocket, QUdpSocket, QTcpServer, QNetworkAccessManager and QFtp. The proxy support is designed to be as transparent as possible. This means that existing network-enabled applications that you have written should automatically support network proxy using the following code.</para>
                <para> QNetworkProxy proxy;</para>
                <para> proxy.setType(QNetworkProxy::Socks5Proxy);</para>
                <para> proxy.setHostName("proxy.example.com");</para>
                <para> proxy.setPort(1080);</para>
                <para> proxy.setUser("username");</para>
                <para> proxy.setPassword("password");</para>
                <para> QNetworkProxy::setApplicationProxy(proxy);</para>
                <para>An alternative to setting an application wide proxy is to specify the proxy for individual sockets using QAbstractSocket::setProxy() and QTcpServer::setProxy(). In this way, it is possible to disable the use of a proxy for specific sockets using the following code:</para>
                <para> serverSocket-&gt;setProxy(QNetworkProxy::NoProxy);</para>
                <para>Network proxy is not used if the address used in connectToHost(), bind() or listen() is equivalent to QHostAddress::LocalHost or QHostAddress::LocalHostIPv6.</para>
                <para>Each type of proxy support has certain restrictions associated with it. You should read the ProxyType documentation carefully before selecting a proxy type to use.</para>
                <para>Note: Changes made to currently connected sockets do not take effect. If you need to change a connected socket, you should reconnect it.</para>
                <para>
                </para>
                <para>SOCKS5</para>
                <para>The SOCKS5 support in Qt 4 is based on RFC 1928 and RFC 1929. The supported authentication methods are no authentication and username/password authentication. Both IPv4 and IPv6 are supported. Domain names are resolved through the SOCKS5 server if the QNetworkProxy::HostNameLookupCapability is enabled, otherwise they are resolved locally and the IP address is sent to the server. There are several things to remember when using SOCKS5 with QUdpSocket and QTcpServer:</para>
                <para>With QUdpSocket, a call to bind() may fail with a timeout error. If a port number other than 0 is passed to bind(), it is not guaranteed that it is the specified port that will be used. Use localPort() and localAddress() to get the actual address and port number in use. Because proxied UDP goes through two UDP connections, it is more likely that packets will be dropped.</para>
                <para>With QTcpServer a call to listen() may fail with a timeout error. If a port number other than 0 is passed to listen(), then it is not guaranteed that it is the specified port that will be used. Use serverPort() and serverAddress() to get the actual address and port used to listen for connections. SOCKS5 only supports one accepted connection per call to listen(), and each call is likely to result in a different serverPort() being used.</para>
                <para>
                </para>
                <para>See also QAbstractSocket and QTcpServer.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QNetworkProxy.#ctor">
            <summary>
                <para>Constructs a QNetworkProxy with DefaultProxy type; the proxy type is determined by applicationProxy(), which defaults to NoProxy.</para>
                <para>See also setType() and setApplicationProxy().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxy.#ctor(QtNetwork.QNetworkProxy)">
            <summary>
                <para>Constructs a copy of other.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxy.#ctor(QtNetwork.QNetworkProxy.ProxyType,System.String,System.UInt16,System.String,System.String)">
            <summary>
                <para>Constructs a QNetworkProxy with type, hostName, port, user and password.</para>
                <para>The default capabilities for proxy type type are set automatically.</para>
                <para>See also capabilities().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkProxy.Capability">
            <summary>
                <para>These flags indicate the capabilities that a given proxy server supports.</para>
                <para>QNetworkProxy sets different capabilities by default when the object is created (see QNetworkProxy::ProxyType for a list of the defaults). However, it is possible to change the capabitilies after the object has been created with setCapabilities().</para>
                <para>The capabilities that QNetworkProxy supports are:</para>
                <para>This enum was introduced or modified in Qt 4.5.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkProxy.Capability.CachingCapability">
            <summary>
                <para>Ability to cache the contents of the transfer. This capability is specific to each protocol and proxy type. For example, HTTP proxies can cache the contents of web data transferred with "GET" commands.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkProxy.Capability.HostNameLookupCapability">
            <summary>
                <para>Ability to connect to perform the lookup on a remote host name and connect to it, as opposed to requiring the application to perform the name lookup and request connection to IP addresses only.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkProxy.Capability.ListeningCapability">
            <summary>
                <para>Ability to create a listening socket and wait for an incoming TCP connection from a remote host.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkProxy.Capability.TunnelingCapability">
            <summary>
                <para>Ability to open transparent, tunneled TCP connections to a remote host. The proxy server relays the transmission verbatim from one side to the other and does no caching.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkProxy.Capability.UdpTunnelingCapability">
            <summary>
                <para>Ability to relay UDP datagrams via the proxy server to and from a remote host.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkProxy.ProxyType">
            <summary>
                <para>This enum describes the types of network proxying provided in Qt.</para>
                <para>There are two types of proxies that Qt understands: transparent proxies and caching proxies. The first group consists of proxies that can handle any arbitrary data transfer, while the second can only handle specific requests. The caching proxies only make sense for the specific classes where they can be used.</para>
                <para>The table below lists different proxy types and their capabilities. Since each proxy type has different capabilities, it is important to understand them before choosing a proxy type.</para>
                <para>
                </para>
                <para>Proxy typeDescriptionDefault capabilities</para>
                <para>SOCKS 5	Generic proxy for any kind of connection. Supports TCP, UDP, binding to a port (incoming connections) and authentication.	TunnelingCapability, ListeningCapability, UdpTunnelingCapability, HostNameLookupCapability</para>
                <para>HTTP	Implemented using the "CONNECT" command, supports only outgoing TCP connections; supports authentication.	TunnelingCapability, CachingCapability, HostNameLookupCapability</para>
                <para>Caching-only HTTP	Implemented using normal HTTP commands, it is useful only in the context of HTTP requests (see QNetworkAccessManager)	CachingCapability, HostNameLookupCapability</para>
                <para>Caching FTP	Implemented using an FTP proxy, it is useful only in the context of FTP requests (see QFtp, QNetworkAccessManager)	CachingCapability, HostNameLookupCapability</para>
                <para>
                </para>
                <para>Also note that you shouldn't set the application default proxy (setApplicationProxy()) to a proxy that doesn't have the TunnelingCapability capability. If you do, QTcpSocket will not know how to open connections.</para>
                <para>See also setType(), type(), capabilities(), and setCapabilities().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkProxy.ProxyType.DefaultProxy">
            <summary>
                <para>Proxy is determined based on the application proxy set using setApplicationProxy()</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkProxy.ProxyType.FtpCachingProxy">
            <summary>
                <para>Proxying for FTP requests only (This value was introduced in 4.4.)</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkProxy.ProxyType.HttpCachingProxy">
            <summary>
                <para>Proxying for HTTP requests only (This value was introduced in 4.4.)</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkProxy.ProxyType.HttpProxy">
            <summary>
                <para>HTTP transparent proxying is used (This value was introduced in 4.3.)</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkProxy.ProxyType.NoProxy">
            <summary>
                <para>No proxying is used</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkProxy.ProxyType.Socks5Proxy">
            <summary>
                <para>Socks5 proxying is used</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkProxy.ApplicationProxy">
            <summary>
                <para>Returns the application level network proxying.</para>
                <para>If a QAbstractSocket or QTcpSocket has the QNetworkProxy::DefaultProxy type, then the QNetworkProxy returned by this function is used.</para>
                <para>Sets the application level network proxying to be networkProxy.</para>
                <para>If a QAbstractSocket or QTcpSocket has the QNetworkProxy::DefaultProxy type, then the QNetworkProxy set with this function is used. If you want more flexibility in determining which the proxy, use the QNetworkProxyFactory class.</para>
                <para>Setting a default proxy value with this function will override the application proxy factory set with QNetworkProxyFactory::setApplicationProxyFactory.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkProxy.Capabilities">
            <summary>
                <para>Returns the capabilities of this proxy server.</para>
                <para>This function was introduced in Qt 4.5.</para>
                <para>Sets the capabilities of this proxy to capabilities.</para>
                <para>This function was introduced in Qt 4.5.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkProxy.HostName">
            <summary>
                <para>Returns the host name of the proxy host.</para>
                <para>Sets the host name of the proxy host to be hostName.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkProxy.Password">
            <summary>
                <para>Returns the password used for authentication.</para>
                <para>Sets the password for proxy authentication to be password.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkProxy.Port">
            <summary>
                <para>Returns the port of the proxy host.</para>
                <para>Sets the port of the proxy host to be port.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkProxy.Type">
            <summary>
                <para>Returns the proxy type for this instance.</para>
                <para>Sets the proxy type for this instance to be type.</para>
                <para>Note that changing the type of a proxy does not change the set of capabilities this QNetworkProxy object holds if any capabilities have been set with setCapabilities().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkProxy.User">
            <summary>
                <para>Returns the user name used for authentication.</para>
                <para>Sets the user name for proxy authentication to be user.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkProxy.IsCachingProxy">
            <summary>
                <para>Returns true if this proxy supports the QNetworkProxy::CachingCapability capability.</para>
                <para>In Qt 4.4, the capability was tied to the proxy type, but since Qt 4.5 it is possible to remove the capability of caching from a proxy by calling setCapabilities().</para>
                <para>This function was introduced in Qt 4.4.</para>
                <para>See also capabilities(), type(), and isTransparentProxy().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkProxy.IsTransparentProxy">
            <summary>
                <para>Returns true if this proxy supports transparent tunneling of TCP connections. This matches the QNetworkProxy::TunnelingCapability capability.</para>
                <para>In Qt 4.4, the capability was tied to the proxy type, but since Qt 4.5 it is possible to remove the capability of caching from a proxy by calling setCapabilities().</para>
                <para>This function was introduced in Qt 4.4.</para>
                <para>See also capabilities(), type(), and isCachingProxy().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxy.Finalize">
            <summary>
                <para>Destroys the QNetworkProxy object.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxy.op_Inequality(QtNetwork.QNetworkProxy,QtNetwork.QNetworkProxy)">
            <summary>
                <para>Compares the value of this network proxy to other and returns true if they differ.</para>
                <para>This function was introduced in Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxy.op_Equality(QtNetwork.QNetworkProxy,QtNetwork.QNetworkProxy)">
            <summary>
                <para>Compares the value of this network proxy to other and returns true if they are equal (same proxy type, server as well as username and password)</para>
                <para>This function was introduced in Qt 4.4.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkProxyFactory">
            <summary>
            The QNetworkProxyFactory class provides fine-grained proxy selection.
            </summary>
            <remarks>
                <para>
                </para>
                <para>QNetworkProxyFactory is an extension to QNetworkProxy, allowing applications to have a more fine-grained control over which proxy servers are used, depending on the socket requesting the proxy. This allows an application to apply different settings, according to the protocol or destination hostname, for instance.</para>
                <para>QNetworkProxyFactory can be set globally for an application, in which case it will override any global proxies set with QNetworkProxy::setApplicationProxy(). If set globally, any sockets created with Qt will query the factory to determine the proxy to be used.</para>
                <para>A factory can also be set in certain frameworks that support multiple connections, such as QNetworkAccessManager. When set on such object, the factory will be queried for sockets created by that framework only.</para>
                <para>
                </para>
                <para>System Proxies</para>
                <para>You can configure a factory to use the system proxy's settings. Call the setUseSystemConfiguration() function with true to enable this behavior, or false to disable it.</para>
                <para>Similarly, you can use a factory to make queries directly to the system proxy by calling its systemProxyForQuery() function.</para>
                <para>Warning: Depending on the configuration of the user's system, the use of system proxy features on certain platforms may be subject to limitations. The systemProxyForQuery() documentation contains a list of these limitations for those platforms that are affected.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QNetworkProxyFactory.#ctor">
            <summary>
                <para>Creates a QNetworkProxyFactory object.</para>
                <para>Since QNetworkProxyFactory is an abstract class, you cannot create objects of type QNetworkProxyFactory directly.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxyFactory.ProxyForQuery(QtNetwork.QNetworkProxyQuery)">
            <summary>
                <para>This function takes the query request, query, examines the details of the type of socket or request and returns a list of QNetworkProxy objects that indicate the proxy servers to be used, in order of preference.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxyFactory.QueryProxy">
            <summary>
                <para>This function takes the query request, query, examines the details of the type of socket or request and returns a list of QNetworkProxy objects that indicate the proxy servers to be used, in order of preference.</para>
                <para>When reimplementing this class, take care to return at least one element.</para>
                <para>If you cannot determine a better proxy alternative, use QNetworkProxy::DefaultProxy, which tells the code querying for a proxy to use a higher alternative. For example, if this factory is set to a QNetworkAccessManager object, DefaultProxy will tell it to query the application-level proxy settings.</para>
                <para>If this factory is set as the application proxy factory, DefaultProxy and NoProxy will have the same meaning.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxyFactory.QueryProxy(QtNetwork.QNetworkProxyQuery)">
            <summary>
                <para>This function takes the query request, query, examines the details of the type of socket or request and returns a list of QNetworkProxy objects that indicate the proxy servers to be used, in order of preference.</para>
                <para>When reimplementing this class, take care to return at least one element.</para>
                <para>If you cannot determine a better proxy alternative, use QNetworkProxy::DefaultProxy, which tells the code querying for a proxy to use a higher alternative. For example, if this factory is set to a QNetworkAccessManager object, DefaultProxy will tell it to query the application-level proxy settings.</para>
                <para>If this factory is set as the application proxy factory, DefaultProxy and NoProxy will have the same meaning.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxyFactory.SetApplicationProxyFactory(QtNetwork.QNetworkProxyFactory)">
            <summary>
                <para>Sets the application-wide proxy factory to be factory. This function will take ownership of that object and will delete it when necessary.</para>
                <para>The application-wide proxy is used as a last-resort when all other proxy selection requests returned QNetworkProxy::DefaultProxy. For example, QTcpSocket objects can have a proxy set with QTcpSocket::setProxy, but if none is set, the proxy factory class set with this function will be queried.</para>
                <para>If you set a proxy factory with this function, any application level proxies set with QNetworkProxy::setApplicationProxy will be overridden.</para>
                <para>See also QNetworkProxy::setApplicationProxy(), QAbstractSocket::proxy(), and QAbstractSocket::setProxy().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxyFactory.SetUseSystemConfiguration(System.Boolean)">
            <summary>
                <para>Enables the use of the platform-specific proxy settings, and only those. See systemProxyForQuery() for more information.</para>
                <para>Internally, this method (when called with enable set to true) sets an application-wide proxy factory. For this reason, this method is mutually exclusive with setApplicationProxyFactory(): calling setApplicationProxyFactory() overrides the use of the system-wide proxy, and calling setUseSystemConfiguration() overrides any application proxy or proxy factory that was previously set.</para>
                <para>Note: See the systemProxyForQuery() documentation for a list of limitations related to the use of system proxies.</para>
                <para>This function was introduced in Qt 4.6.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxyFactory.SystemProxyForQuery">
            <summary>
                <para>This function takes the query request, query, examines the details of the type of socket or request and returns a list of QNetworkProxy objects that indicate the proxy servers to be used, in order of preference.</para>
                <para>This function can be used to determine the platform-specific proxy settings. This function will use the libraries provided by the operating system to determine the proxy for a given connection, if such libraries exist. If they don't, this function will just return a QNetworkProxy of type QNetworkProxy::NoProxy.</para>
                <para>On Windows, this function will use the WinHTTP DLL functions. Despite its name, Microsoft suggests using it for all applications that require network connections, not just HTTP. This will respect the proxy settings set on the registry with the proxycfg.exe tool. If those settings are not found, this function will attempt to obtain Internet Explorer's settings and use them.</para>
                <para>On MacOS X, this function will obtain the proxy settings using the SystemConfiguration framework from Apple. It will apply the FTP, HTTP and HTTPS proxy configurations for queries that contain the protocol tag "ftp", "http" and "https", respectively. If the SOCKS proxy is enabled in that configuration, this function will use the SOCKS server for all queries. If SOCKS isn't enabled, it will use the HTTPS proxy for all TcpSocket and UrlRequest queries.</para>
                <para>On other systems, this function will pick up proxy settings from the "http_proxy" environment variable. This variable must be a URL using one of the following schemes: "http", "socks5" or "socks5h".</para>
                <para>
                </para>
                <para>Limitations</para>
                <para>These are the limitations for the current version of this function. Future versions of Qt may lift some of the limitations listed here.</para>
                <para>
                </para>
                <para>On MacOS X, this function will ignore the Proxy Auto Configuration settings, since it cannot execute the associated ECMAScript code.</para>
                <para>On Windows platforms, this function may take several seconds to execute depending on the configuration of the user's system.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxyFactory.SystemProxyForQuery(QtNetwork.QNetworkProxyQuery)">
            <summary>
                <para>This function takes the query request, query, examines the details of the type of socket or request and returns a list of QNetworkProxy objects that indicate the proxy servers to be used, in order of preference.</para>
                <para>This function can be used to determine the platform-specific proxy settings. This function will use the libraries provided by the operating system to determine the proxy for a given connection, if such libraries exist. If they don't, this function will just return a QNetworkProxy of type QNetworkProxy::NoProxy.</para>
                <para>On Windows, this function will use the WinHTTP DLL functions. Despite its name, Microsoft suggests using it for all applications that require network connections, not just HTTP. This will respect the proxy settings set on the registry with the proxycfg.exe tool. If those settings are not found, this function will attempt to obtain Internet Explorer's settings and use them.</para>
                <para>On MacOS X, this function will obtain the proxy settings using the SystemConfiguration framework from Apple. It will apply the FTP, HTTP and HTTPS proxy configurations for queries that contain the protocol tag "ftp", "http" and "https", respectively. If the SOCKS proxy is enabled in that configuration, this function will use the SOCKS server for all queries. If SOCKS isn't enabled, it will use the HTTPS proxy for all TcpSocket and UrlRequest queries.</para>
                <para>On other systems, this function will pick up proxy settings from the "http_proxy" environment variable. This variable must be a URL using one of the following schemes: "http", "socks5" or "socks5h".</para>
                <para>
                </para>
                <para>Limitations</para>
                <para>These are the limitations for the current version of this function. Future versions of Qt may lift some of the limitations listed here.</para>
                <para>
                </para>
                <para>On MacOS X, this function will ignore the Proxy Auto Configuration settings, since it cannot execute the associated ECMAScript code.</para>
                <para>On Windows platforms, this function may take several seconds to execute depending on the configuration of the user's system.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxyFactory.Finalize">
            <summary>
                <para>Destroys the QNetworkProxyFactory object.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkProxyQuery">
            <summary>
            The QNetworkProxyQuery class is used to query the proxy settings for a socket
            </summary>
            <remarks>
                <para>
                </para>
                <para>QNetworkProxyQuery holds the details of a socket being created or request being made. It is used by QNetworkProxy and QNetworkProxyFactory to allow applications to have a more fine-grained control over which proxy servers are used, depending on the details of the query. This allows an application to apply different settings, according to the protocol or destination hostname, for instance.</para>
                <para>QNetworkProxyQuery supports the following criteria for selecting the proxy:</para>
                <para>
                </para>
                <para>the type of query</para>
                <para>the local port number to use</para>
                <para>the destination host name</para>
                <para>the destination port number</para>
                <para>the protocol name, such as "http" or "ftp"</para>
                <para>the URL being requested</para>
                <para>
                </para>
                <para>The destination host name is the host in the connection in the case of outgoing connection sockets. It is the hostName parameter passed to QTcpSocket::connectToHost() or the host component of a URL requested with QNetworkRequest.</para>
                <para>The destination port number is the requested port to connect to in the case of outgoing sockets, while the local port number is the port the socket wishes to use locally before attempting the external connection. In most cases, the local port number is used by listening sockets only (QTcpSocket) or by datagram sockets (QUdpSocket).</para>
                <para>The protocol name is an arbitrary string that indicates the type of connection being attempted. For example, it can match the scheme of a URL, like "http", "https" and "ftp". In most cases, the proxy selection will not change depending on the protocol, but this information is provided in case a better choice can be made, like choosing an caching HTTP proxy for HTTP-based connections, but a more powerful SOCKSv5 proxy for all others.</para>
                <para>The network configuration specifies which configuration to use, when bearer management is used. For example on a mobile phone the proxy settings are likely to be different for the cellular network vs WLAN.</para>
                <para>Some of the criteria may not make sense in all of the types of query. The following table lists the criteria that are most commonly used, according to the type of query.</para>
                <para>
                </para>
                <para>Query typeDescription</para>
                <para>TcpSocket	Normal sockets requesting a connection to a remote server, like QTcpSocket. The peer hostname and peer port match the values passed to QTcpSocket::connectToHost(). The local port is usually -1, indicating the socket has no preference in which port should be used. The URL component is not used.</para>
                <para>UdpSocket	Datagram-based sockets, which can both send and receive. The local port, remote host or remote port fields can all be used or be left unused, depending on the characteristics of the socket. The URL component is not used.</para>
                <para>TcpServer	Passive server sockets that listen on a port and await incoming connections from the network. Normally, only the local port is used, but the remote address could be used in specific circumstances, for example to indicate which remote host a connection is expected from. The URL component is not used.</para>
                <para>UrlRequest	A more high-level request, such as those coming from QNetworkAccessManager. These requests will inevitably use an outgoing TCP socket, but the this query type is provided to indicate that more detailed information is present in the URL component. For ease of implementation, the URL's host and port are set as the destination address.</para>
                <para>
                </para>
                <para>It should be noted that any of the criteria may be missing or unknown (an empty QString for the hostname or protocol name, -1 for the port numbers). If that happens, the functions executing the query should make their best guess or apply some implementation-defined default values.</para>
                <para>
                </para>
                <para>See also QNetworkProxy, QNetworkProxyFactory, QNetworkAccessManager, and QAbstractSocket::setProxy().</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QNetworkProxyQuery.#ctor">
            <summary>
                <para>Constructs a default QNetworkProxyQuery object. By default, the query type will be QNetworkProxyQuery::TcpSocket.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxyQuery.#ctor(QtNetwork.QNetworkProxyQuery)">
            <summary>
                <para>Constructs a QNetworkProxyQuery object that is a copy of other.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxyQuery.#ctor(QtNetwork.QNetworkConfiguration,QtCore.QUrl,QtNetwork.QNetworkProxyQuery.QueryType)">
            <summary>
                <para>Constructs a QNetworkProxyQuery with the URL requestUrl and sets the query type to queryType. The specified networkConfiguration is used to resolve the proxy settings.</para>
                <para>This function was introduced in Qt 4.8.</para>
                <para>See also protocolTag(), peerHostName(), peerPort(), and networkConfiguration().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxyQuery.#ctor(QtCore.QUrl,QtNetwork.QNetworkProxyQuery.QueryType)">
            <summary>
                <para>Constructs a QNetworkProxyQuery with the URL requestUrl and sets the query type to queryType.</para>
                <para>See also protocolTag(), peerHostName(), and peerPort().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxyQuery.#ctor(QtNetwork.QNetworkConfiguration,System.UInt16,System.String,QtNetwork.QNetworkProxyQuery.QueryType)">
            <summary>
                <para>Constructs a QNetworkProxyQuery of type queryType and sets the protocol tag to be protocolTag. This constructor is suitable for QNetworkProxyQuery::TcpSocket queries because it sets the local port number to bindPort. The specified networkConfiguration is used to resolve the proxy settings.</para>
                <para>Note that bindPort is of type quint16 to indicate the exact port number that is requested. The value of -1 (unknown) is not allowed in this context.</para>
                <para>This function was introduced in Qt 4.8.</para>
                <para>See also localPort() and networkConfiguration().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxyQuery.#ctor(QtNetwork.QNetworkConfiguration,System.String,System.Int32,System.String,QtNetwork.QNetworkProxyQuery.QueryType)">
            <summary>
                <para>Constructs a QNetworkProxyQuery of type queryType and sets the protocol tag to be protocolTag. This constructor is suitable for QNetworkProxyQuery::TcpSocket queries, because it sets the peer hostname to hostname and the peer's port number to port. The specified networkConfiguration is used to resolve the proxy settings.</para>
                <para>This function was introduced in Qt 4.8.</para>
                <para>See also networkConfiguration().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxyQuery.#ctor(System.UInt16,System.String,QtNetwork.QNetworkProxyQuery.QueryType)">
            <summary>
                <para>Constructs a QNetworkProxyQuery of type queryType and sets the protocol tag to be protocolTag. This constructor is suitable for QNetworkProxyQuery::TcpSocket queries because it sets the local port number to bindPort.</para>
                <para>Note that bindPort is of type quint16 to indicate the exact port number that is requested. The value of -1 (unknown) is not allowed in this context.</para>
                <para>See also localPort().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxyQuery.#ctor(System.String,System.Int32,System.String,QtNetwork.QNetworkProxyQuery.QueryType)">
            <summary>
                <para>Constructs a QNetworkProxyQuery of type queryType and sets the protocol tag to be protocolTag. This constructor is suitable for QNetworkProxyQuery::TcpSocket queries, because it sets the peer hostname to hostname and the peer's port number to port.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkProxyQuery.QueryType">
            <summary>
                <para>Describes the type of one QNetworkProxyQuery query.</para>
                <para>See also queryType() and setQueryType().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkProxyQuery.QueryType.TcpServer">
            <summary>
                <para>A TCP server that listens for incoming connections from the network</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkProxyQuery.QueryType.TcpSocket">
            <summary>
                <para>A normal, outgoing TCP socket</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkProxyQuery.QueryType.UdpSocket">
            <summary>
                <para>A datagram-based UDP socket, which could send to multiple destinations</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkProxyQuery.QueryType.UrlRequest">
            <summary>
                <para>A more complex request which involves loading of a URL</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkProxyQuery.LocalPort">
            <summary>
                <para>Returns the port number of the socket that will accept incoming packets from remote servers or -1 if the port is not known.</para>
                <para>Sets the port number that the socket wishes to use locally to accept incoming packets from remote servers to port. The local port is most often used with the QNetworkProxyQuery::TcpServer and QNetworkProxyQuery::UdpSocket query types.</para>
                <para>Valid values are 0 to 65535 (with 0 indicating that any port number will be acceptable) or -1, which means the local port number is unknown or not applicable.</para>
                <para>In some circumstances, for special protocols, it's the local port number can also be used with a query of type QNetworkProxyQuery::TcpSocket. When that happens, the socket is indicating it wishes to use the port number port when connecting to a remote host.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkProxyQuery.NetworkConfiguration">
            <summary>
                <para>Returns the network configuration of the proxy query.</para>
                <para>Sets the network configuration component of this QNetworkProxyQuery object to be networkConfiguration. The network configuration can be used to return different proxy settings based on the network in use, for example WLAN vs cellular networks on a mobile phone.</para>
                <para>In the case of "user choice" or "service network" configurations, you should first start the QNetworkSession and obtain the active configuration from its properties.</para>
                <para>This function was introduced in Qt 4.8.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkProxyQuery.PeerHostName">
            <summary>
                <para>Returns the host name or IP address being of the outgoing connection being requested, or an empty string if the remote hostname is not known.</para>
                <para>If the query type is QNetworkProxyQuery::UrlRequest, this function returns the host component of the URL being requested.</para>
                <para>Sets the hostname of the outgoing connection being requested to hostname. An empty hostname can be used to indicate that the remote host is unknown.</para>
                <para>The peer host name can also be used to indicate the expected source address of an incoming connection in the case of QNetworkProxyQuery::UdpSocket or QNetworkProxyQuery::TcpServer query types.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkProxyQuery.PeerPort">
            <summary>
                <para>Returns the port number for the outgoing request or -1 if the port number is not known.</para>
                <para>If the query type is QNetworkProxyQuery::UrlRequest, this function returns the port number of the URL being requested. In general, frameworks will fill in the port number from their default values.</para>
                <para>Sets the requested port number for the outgoing connection to be port. Valid values are 1 to 65535, or -1 to indicate that the remote port number is unknown.</para>
                <para>The peer port number can also be used to indicate the expected port number of an incoming connection in the case of QNetworkProxyQuery::UdpSocket or QNetworkProxyQuery::TcpServer query types.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkProxyQuery.ProtocolTag">
            <summary>
                <para>Returns the protocol tag for this QNetworkProxyQuery object, or an empty QString in case the protocol tag is unknown.</para>
                <para>In the case of queries of type QNetworkProxyQuery::UrlRequest, this function returns the value of the scheme component of the URL.</para>
                <para>Sets the protocol tag for this QNetworkProxyQuery object to be protocolTag.</para>
                <para>The protocol tag is an arbitrary string that indicates which protocol is being talked over the socket, such as "http", "xmpp", "telnet", etc. The protocol tag is used by the backend to return a request that is more specific to the protocol in question: for example, a HTTP connection could be use a caching HTTP proxy server, while all other connections use a more powerful SOCKSv5 proxy server.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkProxyQuery.queryType">
            <summary>
                <para>Returns the query type.</para>
                <para>Sets the query type of this object to be type.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkProxyQuery.Url">
            <summary>
                <para>Returns the URL component of this QNetworkProxyQuery object in case of a query of type QNetworkProxyQuery::UrlRequest.</para>
                <para>Sets the URL component of this QNetworkProxyQuery object to be url. Setting the URL will also set the protocol tag, the remote host name and port number. This is done so as to facilitate the implementation of the code that determines the proxy server to be used.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxyQuery.Finalize">
            <summary>
                <para>Destroys this QNetworkProxyQuery object.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxyQuery.op_Inequality(QtNetwork.QNetworkProxyQuery,QtNetwork.QNetworkProxyQuery)">
            <summary>
                <para>Returns true if this QNetworkProxyQuery object does not contain the same data as other.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxyQuery.op_Equality(QtNetwork.QNetworkProxyQuery,QtNetwork.QNetworkProxyQuery)">
            <summary>
                <para>Returns true if this QNetworkProxyQuery object contains the same data as other.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkReply">
            <summary>
            The QNetworkReply class contains the data and headers for a request sent with QNetworkAccessManager
            </summary>
            <remarks>
                <para>
                </para>
                <para>The QNetworkReply class contains the data and meta data related to a request posted with QNetworkAccessManager. Like QNetworkRequest, it contains a URL and headers (both in parsed and raw form), some information about the reply's state and the contents of the reply itself.</para>
                <para>QNetworkReply is a sequential-access QIODevice, which means that once data is read from the object, it no longer kept by the device. It is therefore the application's responsibility to keep this data if it needs to. Whenever more data is received from the network and processed, the readyRead() signal is emitted.</para>
                <para>The downloadProgress() signal is also emitted when data is received, but the number of bytes contained in it may not represent the actual bytes received, if any transformation is done to the contents (for example, decompressing and removing the protocol overhead).</para>
                <para>Even though QNetworkReply is a QIODevice connected to the contents of the reply, it also emits the uploadProgress() signal, which indicates the progress of the upload for operations that have such content.</para>
                <para>Note: Do not delete the object in the slot connected to the error() or finished() signal. Use deleteLater().</para>
                <para>
                </para>
                <para>See also QNetworkRequest and QNetworkAccessManager.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QNetworkReply.#ctor(QtCore.QObject)">
            <summary>
                <para>Creates a QNetworkReply object with parent parent.</para>
                <para>You cannot directly instantiate QNetworkReply objects. Use QNetworkAccessManager functions to do that.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkReply.NetworkError">
            <summary>
                <para>Indicates all possible error conditions found during the processing of the request.</para>
                <para>See also error().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.AuthenticationRequiredError">
            <summary>
                <para>The remote server requires authentication to serve the content but the credentials provided were not accepted (if any)</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.ConnectionRefusedError">
            <summary>
                <para>The remote server refused the connection (the server is not accepting requests)</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.ContentAccessDenied">
            <summary>
                <para>The access to the remote content was denied (similar to HTTP error 401)</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.ContentNotFoundError">
            <summary>
                <para>The remote content was not found at the server (similar to HTTP error 404)</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.ContentOperationNotPermittedError">
            <summary>
                <para>The operation requested on the remote content is not permitted</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.ContentReSendError">
            <summary>
                <para>The request needed to be sent again, but this failed for example because the upload data could not be read a second time.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.HostNotFoundError">
            <summary>
                <para>The remote host name was not found (invalid hostname)</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.NoError">
            <summary>
                <para>No error condition. Note: When the HTTP protocol returns a redirect no error will be reported. You can check if there is a redirect with the QNetworkRequest::RedirectionTargetAttribute attribute.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.OperationCanceledError">
            <summary>
                <para>The operation was canceled via calls to abort() or close() before it was finished.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.ProtocolFailure">
            <summary>
                <para>A breakdown in protocol was detected (parsing error, invalid or unexpected responses, etc.)</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.ProtocolInvalidOperationError">
            <summary>
                <para>The requested operation is invalid for this protocol</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.ProtocolUnknownError">
            <summary>
                <para>The Network Access API cannot honor the request because the protocol is not known</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.ProxyAuthenticationRequiredError">
            <summary>
                <para>The proxy requires authentication in order to honour the request but did not accept any credentials offered (if any)</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.ProxyConnectionClosedError">
            <summary>
                <para>The proxy server closed the connection prematurely, before the entire reply was received and processed</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.ProxyConnectionRefusedError">
            <summary>
                <para>The connection to the proxy server was refused (the proxy server is not accepting requests)</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.ProxyNotFoundError">
            <summary>
                <para>The proxy host name was not found (invalid proxy hostname)</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.ProxyTimeoutError">
            <summary>
                <para>The connection to the proxy timed out or the proxy did not reply in time to the request sent</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.RemoteHostClosedError">
            <summary>
                <para>The remote server closed the connection prematurely, before the entire reply was received and processed</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.SslHandshakeFailedError">
            <summary>
                <para>The SSL/TLS handshake failed and the encrypted channel could not be established. The sslErrors() signal should have been emitted.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.TemporaryNetworkFailureError">
            <summary>
                <para>The connection was broken due to disconnection from the network, however the system has initiated roaming to another access point. The request should be resubmitted and will be processed as soon as the connection is re-established.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.TimeoutError">
            <summary>
                <para>The connection to the remote server timed out</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.UnknownContentError">
            <summary>
                <para>An unknown error related to the remote content was detected</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.UnknownNetworkError">
            <summary>
                <para>An unknown network-related error was detected</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.UnknownProxyError">
            <summary>
                <para>An unknown proxy-related error was detected</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkReply.MetaDataChanged">
            <summary>
                <para>This signal is emitted whenever the metadata in this reply changes. metadata is any information that is not the content (data) itself, including the network headers. In the majority of cases, the metadata will be known fully by the time the first byte of data is received. However, it is possible to receive updates of headers or other metadata during the processing of the data.</para>
                <para>See also header(), rawHeaderList(), rawHeader(), and hasRawHeader().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkReply.Finished">
            <summary>
                <para>This signal is emitted when the reply has finished processing. After this signal is emitted, there will be no more updates to the reply's data or metadata.</para>
                <para>Unless close() has been called, the reply will be still be opened for reading, so the data can be retrieved by calls to read() or readAll(). In particular, if no calls to read() were made as a result of readyRead(), a call to readAll() will retrieve the full contents in a QByteArray.</para>
                <para>This signal is emitted in tandem with QNetworkAccessManager::finished() where that signal's reply parameter is this object.</para>
                <para>Note: Do not delete the object in the slot connected to this signal. Use deleteLater().</para>
                <para>You can also use isFinished() to check if a QNetworkReply has finished even before you receive the finished() signal.</para>
                <para>See also setFinished(), QNetworkAccessManager::finished(), and isFinished().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkReply.ErrorCode">
            <summary>
                <para>This signal is emitted when the reply detects an error in processing. The finished() signal will probably follow, indicating that the connection is over.</para>
                <para>The code parameter contains the code of the error that was detected. Call errorString() to obtain a textual representation of the error condition.</para>
                <para>Note: Do not delete the object in the slot connected to this signal. Use deleteLater().</para>
                <para>See also error() and errorString().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkReply.SslErrors">
            <summary>
                <para>This signal is emitted if the SSL/TLS session encountered errors during the set up, including certificate verification errors. The errors parameter contains the list of errors.</para>
                <para>To indicate that the errors are not fatal and that the connection should proceed, the ignoreSslErrors() function should be called from the slot connected to this signal. If it is not called, the SSL session will be torn down before any data is exchanged (including the URL).</para>
                <para>This signal can be used to display an error message to the user indicating that security may be compromised and display the SSL settings (see sslConfiguration() to obtain it). If the user decides to proceed after analyzing the remote certificate, the slot should call ignoreSslErrors().</para>
                <para>See also QSslSocket::sslErrors(), QNetworkAccessManager::sslErrors(), sslConfiguration(), and ignoreSslErrors().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkReply.UploadProgress">
            <summary>
                <para>This signal is emitted to indicate the progress of the upload part of this network request, if there's any. If there's no upload associated with this request, this signal will not be emitted.</para>
                <para>The bytesSent parameter indicates the number of bytes uploaded, while bytesTotal indicates the total number of bytes to be uploaded. If the number of bytes to be uploaded could not be determined, bytesTotal will be -1.</para>
                <para>The upload is finished when bytesSent is equal to bytesTotal. At that time, bytesTotal will not be -1.</para>
                <para>See also downloadProgress().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkReply.DownloadProgress">
            <summary>
                <para>This signal is emitted to indicate the progress of the download part of this network request, if there's any. If there's no download associated with this request, this signal will be emitted once with 0 as the value of both bytesReceived and bytesTotal.</para>
                <para>The bytesReceived parameter indicates the number of bytes received, while bytesTotal indicates the total number of bytes expected to be downloaded. If the number of bytes to be downloaded is not known, bytesTotal will be -1.</para>
                <para>The download is finished when bytesReceived is equal to bytesTotal. At that time, bytesTotal will not be -1.</para>
                <para>Note that the values of both bytesReceived and bytesTotal may be different from size(), the total number of bytes obtained through read() or readAll(), or the value of the header(ContentLengthHeader). The reason for that is that there may be protocol overhead or the data may be compressed during the download.</para>
                <para>See also uploadProgress() and bytesAvailable().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkReply.Operation">
            <summary>
                <para>Returns the operation that was posted for this reply.</para>
                <para>Sets the associated operation for this object to be operation. This value will be returned by operation().</para>
                <para>Note: the operation should be set when this object is created and not changed again.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkReply.ReadBufferSize">
            <summary>
                <para>Returns the size of the read buffer, in bytes.</para>
                <para>Sets the size of the read buffer to be size bytes. The read buffer is the buffer that holds data that is being downloaded off the network, before it is read with QIODevice::read(). Setting the buffer size to 0 will make the buffer unlimited in size.</para>
                <para>QNetworkReply will try to stop reading from the network once this buffer is full (i.e., bytesAvailable() returns size or more), thus causing the download to throttle down as well. If the buffer is not limited in size, QNetworkReply will try to download as fast as possible from the network.</para>
                <para>Unlike QAbstractSocket::setReadBufferSize(), QNetworkReply cannot guarantee precision in the read buffer size. That is, bytesAvailable() can return more than size.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkReply.Request">
            <summary>
                <para>Returns the request that was posted for this reply. In special, note that the URL for the request may be different than that of the reply.</para>
                <para>Sets the associated request for this object to be request. This value will be returned by request().</para>
                <para>Note: the request should be set when this object is created and not changed again.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkReply.SslConfiguration">
            <summary>
                <para>Returns the SSL configuration and state associated with this reply, if SSL was used. It will contain the remote server's certificate, its certificate chain leading to the Certificate Authority as well as the encryption ciphers in use.</para>
                <para>The peer's certificate and its certificate chain will be known by the time sslErrors() is emitted, if it's emitted.</para>
                <para>Sets the SSL configuration for the network connection associated with this request, if possible, to be that of config.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkReply.Url">
            <summary>
                <para>Returns the URL of the content downloaded or uploaded. Note that the URL may be different from that of the original request.</para>
                <para>Sets the URL being processed to be url. Normally, the URL matches that of the request that was posted, but for a variety of reasons it can be different (for example, a file path being made absolute or canonical).</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkReply.IsFinished">
            <summary>
                <para>Returns true when the reply has finished or was aborted.</para>
                <para>This function was introduced in Qt 4.6.</para>
                <para>See also isRunning().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkReply.IsRunning">
            <summary>
                <para>Returns true when the request is still processing and the reply has not finished or was aborted yet.</para>
                <para>This function was introduced in Qt 4.6.</para>
                <para>See also isFinished().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkReply.Manager">
            <summary>
                <para>Returns the QNetworkAccessManager that was used to create this QNetworkReply object. Initially, it is also the parent object.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkReply.RawHeaderList">
            <summary>
                <para>Returns a list of headers fields that were sent by the remote server, in the order that they were sent. Duplicate headers are merged together and take place of the latter duplicate.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkReply.Abort">
            <summary>
                <para>Aborts the operation immediately and close down any network connections still open. Uploads still in progress are also aborted.</para>
                <para>See also close().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkReply.Attribute(QtNetwork.QNetworkRequest.Attribute)">
            <summary>
                <para>Returns the attribute associated with the code code. If the attribute has not been set, it returns an invalid QVariant (type QVariant::Null).</para>
                <para>You can expect the default values listed in QNetworkRequest::Attribute to be applied to the values returned by this function.</para>
                <para>See also setAttribute() and QNetworkRequest::Attribute.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkReply.Close">
            <summary>
                <para>Reimplemented from QIODevice::close().</para>
                <para>Closes this device for reading. Unread data is discarded, but the network resources are not discarded until they are finished. In particular, if any upload is in progress, it will continue until it is done.</para>
                <para>The finished() signal is emitted when all operations are over and the network resources are freed.</para>
                <para>See also abort() and finished().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkReply.OnDownloadProgress(System.Int64,System.Int64)">
            <summary>
                <para>This signal is emitted to indicate the progress of the download part of this network request, if there's any. If there's no download associated with this request, this signal will be emitted once with 0 as the value of both bytesReceived and bytesTotal.</para>
                <para>The bytesReceived parameter indicates the number of bytes received, while bytesTotal indicates the total number of bytes expected to be downloaded. If the number of bytes to be downloaded is not known, bytesTotal will be -1.</para>
                <para>The download is finished when bytesReceived is equal to bytesTotal. At that time, bytesTotal will not be -1.</para>
                <para>Note that the values of both bytesReceived and bytesTotal may be different from size(), the total number of bytes obtained through read() or readAll(), or the value of the header(ContentLengthHeader). The reason for that is that there may be protocol overhead or the data may be compressed during the download.</para>
                <para>See also uploadProgress() and bytesAvailable().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkReply.Error">
            <summary>
                <para>Returns the error that was found during the processing of this request. If no error was found, returns NoError.</para>
                <para>See also setError().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkReply.OnError(QtNetwork.QNetworkReply.NetworkError)">
            <summary>
                <para>This signal is emitted when the reply detects an error in processing. The finished() signal will probably follow, indicating that the connection is over.</para>
                <para>The code parameter contains the code of the error that was detected. Call errorString() to obtain a textual representation of the error condition.</para>
                <para>Note: Do not delete the object in the slot connected to this signal. Use deleteLater().</para>
                <para>See also error() and errorString().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkReply.OnFinished">
            <summary>
                <para>This signal is emitted when the reply has finished processing. After this signal is emitted, there will be no more updates to the reply's data or metadata.</para>
                <para>Unless close() has been called, the reply will be still be opened for reading, so the data can be retrieved by calls to read() or readAll(). In particular, if no calls to read() were made as a result of readyRead(), a call to readAll() will retrieve the full contents in a QByteArray.</para>
                <para>This signal is emitted in tandem with QNetworkAccessManager::finished() where that signal's reply parameter is this object.</para>
                <para>Note: Do not delete the object in the slot connected to this signal. Use deleteLater().</para>
                <para>You can also use isFinished() to check if a QNetworkReply has finished even before you receive the finished() signal.</para>
                <para>See also setFinished(), QNetworkAccessManager::finished(), and isFinished().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkReply.HasRawHeader(QtCore.QByteArray)">
            <summary>
                <para>Returns true if the raw header of name headerName was sent by the remote server</para>
                <para>See also rawHeader().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkReply.Header(QtNetwork.QNetworkRequest.KnownHeaders)">
            <summary>
                <para>Returns the value of the known header header, if that header was sent by the remote server. If the header was not sent, returns an invalid QVariant.</para>
                <para>See also rawHeader(), setHeader(), and QNetworkRequest::header().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkReply.IgnoreSslErrors">
            <summary>
                <para>If this function is called, SSL errors related to network connection will be ignored, including certificate validation errors.</para>
                <para>Note that calling this function without restraint may pose a security risk for your application. Use it with care.</para>
                <para>This function can be called from the slot connected to the sslErrors() signal, which indicates which errors were found.</para>
                <para>See also sslConfiguration(), sslErrors(), and QSslSocket::ignoreSslErrors().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkReply.IgnoreSslErrors(System.Collections.Generic.List{QtNetwork.QSslError})">
            <summary>
                <para>This is an overloaded function.</para>
                <para>If this function is called, the SSL errors given in errors will be ignored.</para>
                <para>Note that you can set the expected certificate in the SSL error: If, for instance, you want to issue a request to a server that uses a self-signed certificate, consider the following snippet:</para>
                <para> QList&lt;QSslCertificate&gt; cert = QSslCertificate::fromPath(QLatin1String("server-certificate.pem"));</para>
                <para> QSslError error(QSslError::SelfSignedCertificate, cert.at(0));</para>
                <para> QList&lt;QSslError&gt; expectedSslErrors;</para>
                <para> expectedSslErrors.append(error);</para>
                <para>
                </para>
                <para> QNetworkReply *reply = manager.get(QNetworkRequest(QUrl("https://server.tld/index.html")));</para>
                <para> reply-&gt;ignoreSslErrors(expectedSslErrors);</para>
                <para> // here connect signals etc.</para>
                <para>Multiple calls to this function will replace the list of errors that were passed in previous calls. You can clear the list of errors you want to ignore by calling this function with an empty list.</para>
                <para>This function was introduced in Qt 4.6.</para>
                <para>See also sslConfiguration(), sslErrors(), and QSslSocket::ignoreSslErrors().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkReply.OnMetaDataChanged">
            <summary>
                <para>This signal is emitted whenever the metadata in this reply changes. metadata is any information that is not the content (data) itself, including the network headers. In the majority of cases, the metadata will be known fully by the time the first byte of data is received. However, it is possible to receive updates of headers or other metadata during the processing of the data.</para>
                <para>See also header(), rawHeaderList(), rawHeader(), and hasRawHeader().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkReply.RawHeader(QtCore.QByteArray)">
            <summary>
                <para>Returns the raw contents of the header headerName as sent by the remote server. If there is no such header, returns an empty byte array, which may be indistinguishable from an empty header. Use hasRawHeader() to verify if the server sent such header field.</para>
                <para>See also setRawHeader(), hasRawHeader(), and header().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkReply.SetAttribute(QtNetwork.QNetworkRequest.Attribute,System.Object)">
            <summary>
                <para>Sets the attribute code to have value value. If code was previously set, it will be overridden. If value is an invalid QVariant, the attribute will be unset.</para>
                <para>See also attribute() and QNetworkRequest::setAttribute().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkReply.SetError(QtNetwork.QNetworkReply.NetworkError,System.String)">
            <summary>
                <para>Sets the error condition to be errorCode. The human-readable message is set with errorString.</para>
                <para>Calling setError() does not emit the error(QNetworkReply::NetworkError) signal.</para>
                <para>See also error() and errorString().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkReply.SetFinished(System.Boolean)">
            <summary>
                <para>Sets the reply as finished.</para>
                <para>After having this set the replies data must not change.</para>
                <para>This function was introduced in Qt 4.8.</para>
                <para>See also finished() and isFinished().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkReply.SetHeader(QtNetwork.QNetworkRequest.KnownHeaders,System.Object)">
            <summary>
                <para>Sets the known header header to be of value value. The corresponding raw form of the header will be set as well.</para>
                <para>See also header(), setRawHeader(), and QNetworkRequest::setHeader().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkReply.SetRawHeader(QtCore.QByteArray,QtCore.QByteArray)">
            <summary>
                <para>Sets the raw header headerName to be of value value. If headerName was previously set, it is overridden. Multiple HTTP headers of the same name are functionally equivalent to one single header with the values concatenated, separated by commas.</para>
                <para>If headerName matches a known header, the value value will be parsed and the corresponding parsed form will also be set.</para>
                <para>See also rawHeader(), header(), setHeader(), and QNetworkRequest::setRawHeader().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkReply.OnSslErrors(System.Collections.Generic.List{QtNetwork.QSslError})">
            <summary>
                <para>This signal is emitted if the SSL/TLS session encountered errors during the set up, including certificate verification errors. The errors parameter contains the list of errors.</para>
                <para>To indicate that the errors are not fatal and that the connection should proceed, the ignoreSslErrors() function should be called from the slot connected to this signal. If it is not called, the SSL session will be torn down before any data is exchanged (including the URL).</para>
                <para>This signal can be used to display an error message to the user indicating that security may be compromised and display the SSL settings (see sslConfiguration() to obtain it). If the user decides to proceed after analyzing the remote certificate, the slot should call ignoreSslErrors().</para>
                <para>See also QSslSocket::sslErrors(), QNetworkAccessManager::sslErrors(), sslConfiguration(), and ignoreSslErrors().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkReply.OnUploadProgress(System.Int64,System.Int64)">
            <summary>
                <para>This signal is emitted to indicate the progress of the upload part of this network request, if there's any. If there's no upload associated with this request, this signal will not be emitted.</para>
                <para>The bytesSent parameter indicates the number of bytes uploaded, while bytesTotal indicates the total number of bytes to be uploaded. If the number of bytes to be uploaded could not be determined, bytesTotal will be -1.</para>
                <para>The upload is finished when bytesSent is equal to bytesTotal. At that time, bytesTotal will not be -1.</para>
                <para>See also downloadProgress().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkReply.Finalize">
            <summary>
                <para>Disposes of this reply and frees any resources associated with it. If any network connections are still open, they will be closed.</para>
                <para>See also abort() and close().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkRequest">
            <summary>
            The QNetworkRequest class holds a request to be sent with QNetworkAccessManager.
            </summary>
            <remarks>
                <para>
                </para>
                <para>QNetworkRequest is part of the Network Access API and is the class holding the information necessary to send a request over the network. It contains a URL and some ancillary information that can be used to modify the request.</para>
                <para>
                </para>
                <para>See also QNetworkReply and QNetworkAccessManager.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QNetworkRequest.#ctor">
            <summary>
                <para>Constructs a QNetworkRequest object with url as the URL to be requested.</para>
                <para>See also url() and setUrl().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkRequest.#ctor(QtCore.QUrl)">
            <summary>
                <para>Constructs a QNetworkRequest object with url as the URL to be requested.</para>
                <para>See also url() and setUrl().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkRequest.#ctor(QtNetwork.QNetworkRequest)">
            <summary>
                <para>Creates a copy of other.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkRequest.Attribute">
            <summary>
                <para>Attribute codes for the QNetworkRequest and QNetworkReply.</para>
                <para>Attributes are extra meta-data that are used to control the behavior of the request and to pass further information from the reply back to the application. Attributes are also extensible, allowing custom implementations to pass custom values.</para>
                <para>The following table explains what the default attribute codes are, the QVariant types associated, the default value if said attribute is missing and whether it's used in requests or replies.</para>
                <para>This enum was introduced or modified in Qt 4.7.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Attribute.AuthenticationReuseAttribute">
            <summary>
                <para>Requests only, type: QVariant::Int (default: QNetworkRequest::Automatic) Indicates whether to use cached authorization credentials in the request, if available. If this is set to QNetworkRequest::Manual and the authentication mechanism is 'Basic' or 'Digest', Qt will not send an an 'Authorization' HTTP header with any cached credentials it may have for the request's URL. This attribute is set to QNetworkRequest::Manual by QtWebKit when creating a cross-origin XMLHttpRequest where withCredentials has not been set explicitly to true by the Javascript that created the request. See here for more information. (This value was introduced in 4.7.)</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Attribute.CacheLoadControlAttribute">
            <summary>
                <para>Requests only, type: QVariant::Int (default: QNetworkRequest::PreferNetwork) Controls how the cache should be accessed. The possible values are those of QNetworkRequest::CacheLoadControl. Note that the default QNetworkAccessManager implementation does not support caching. However, this attribute may be used by certain backends to modify their requests (for example, for caching proxies).</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Attribute.CacheSaveControlAttribute">
            <summary>
                <para>Requests only, type: QVariant::Bool (default: true) Controls if the data obtained should be saved to cache for future uses. If the value is false, the data obtained will not be automatically cached. If true, data may be cached, provided it is cacheable (what is cacheable depends on the protocol being used).</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Attribute.ConnectionEncryptedAttribute">
            <summary>
                <para>Replies only, type: QVariant::Bool (default: false) Indicates whether the data was obtained through an encrypted (secure) connection.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Attribute.CookieLoadControlAttribute">
            <summary>
                <para>Requests only, type: QVariant::Int (default: QNetworkRequest::Automatic) Indicates whether to send 'Cookie' headers in the request. This attribute is set to false by QtWebKit when creating a cross-origin XMLHttpRequest where withCredentials has not been set explicitly to true by the Javascript that created the request. See here for more information. (This value was introduced in 4.7.)</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Attribute.CookieSaveControlAttribute">
            <summary>
                <para>Requests only, type: QVariant::Int (default: QNetworkRequest::Automatic) Indicates whether to save 'Cookie' headers received from the server in reply to the request. This attribute is set to false by QtWebKit when creating a cross-origin XMLHttpRequest where withCredentials has not been set explicitly to true by the Javascript that created the request. See here for more information. (This value was introduced in 4.7.)</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Attribute.CustomVerbAttribute">
            <summary>
                <para>Requests only, type: QVariant::ByteArray Holds the value for the custom HTTP verb to send (destined for usage of other verbs than GET, POST, PUT and DELETE). This verb is set when calling QNetworkAccessManager::sendCustomRequest().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Attribute.DoNotBufferUploadDataAttribute">
            <summary>
                <para>Requests only, type: QVariant::Bool (default: false) Indicates whether the QNetworkAccessManager code is allowed to buffer the upload data, e.g. when doing a HTTP POST. When using this flag with sequential upload data, the ContentLengthHeader header must be set.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Attribute.HttpPipeliningAllowedAttribute">
            <summary>
                <para>Requests only, type: QVariant::Bool (default: false) Indicates whether the QNetworkAccessManager code is allowed to use HTTP pipelining with this request.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Attribute.HttpPipeliningWasUsedAttribute">
            <summary>
                <para>Replies only, type: QVariant::Bool Indicates whether the HTTP pipelining was used for receiving this reply.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Attribute.HttpReasonPhraseAttribute">
            <summary>
                <para>Replies only, type: QVariant::ByteArray (no default) Indicates the HTTP reason phrase as received from the HTTP server (like "Ok", "Found", "Not Found", "Access Denied", etc.) This is the human-readable representation of the status code (see above). If the connection was not HTTP-based, this attribute will not be present.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Attribute.HttpStatusCodeAttribute">
            <summary>
                <para>Replies only, type: QVariant::Int (no default) Indicates the HTTP status code received from the HTTP server (like 200, 304, 404, 401, etc.). If the connection was not HTTP-based, this attribute will not be present.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Attribute.RedirectionTargetAttribute">
            <summary>
                <para>Replies only, type: QVariant::Url (no default) If present, it indicates that the server is redirecting the request to a different URL. The Network Access API does not by default follow redirections: it's up to the application to determine if the requested redirection should be allowed, according to its security policies. The returned URL might be relative. Use QUrl::resolved() to create an absolute URL out of it.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Attribute.SourceIsFromCacheAttribute">
            <summary>
                <para>Replies only, type: QVariant::Bool (default: false) Indicates whether the data was obtained from cache or not.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Attribute.User">
            <summary>
                <para>Special type. Additional information can be passed in QVariants with types ranging from User to UserMax. The default implementation of Network Access will ignore any request attributes in this range and it will not produce any attributes in this range in replies. The range is reserved for extensions of QNetworkAccessManager.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Attribute.UserMax">
            <summary>
                <para>Special type. See User.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkRequest.CacheLoadControl">
            <summary>
                <para>Controls the caching mechanism of QNetworkAccessManager.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.CacheLoadControl.AlwaysCache">
            <summary>
                <para>Only load from cache, indicating error if the item was not cached (i.e., off-line mode)</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.CacheLoadControl.AlwaysNetwork">
            <summary>
                <para>Always load from network and do not check if the cache has a valid entry (similar to the "Reload" feature in browsers)</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.CacheLoadControl.PreferCache">
            <summary>
                <para>Load from cache if available, otherwise load from network. Note that this can return possibly stale (but not expired) items from cache.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.CacheLoadControl.PreferNetwork">
            <summary>
                <para>Default value; load from the network if the cached entry is older than the network entry</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkRequest.KnownHeaders">
            <summary>
                <para>List of known header types that QNetworkRequest parses. Each known header is also represented in raw form with its full HTTP name.</para>
                <para>See also header(), setHeader(), rawHeader(), and setRawHeader().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.KnownHeaders.ContentLengthHeader">
            <summary>
                <para>Corresponds to the HTTP Content-Length header and contains the length in bytes of the data transmitted.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.KnownHeaders.ContentTypeHeader">
            <summary>
                <para>Corresponds to the HTTP Content-Type header and contains a string containing the media (MIME) type and any auxiliary data (for instance, charset)</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.KnownHeaders.CookieHeader">
            <summary>
                <para>Corresponds to the HTTP Cookie header and contains a QList&lt;QNetworkCookie&gt; representing the cookies to be sent back to the server</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.KnownHeaders.LastModifiedHeader">
            <summary>
                <para>Corresponds to the HTTP Last-Modified header and contains a QDateTime representing the last modification date of the contents</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.KnownHeaders.LocationHeader">
            <summary>
                <para>Corresponds to the HTTP Location header and contains a URL representing the actual location of the data, including the destination URL in case of redirections.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.KnownHeaders.SetCookieHeader">
            <summary>
                <para>Corresponds to the HTTP Set-Cookie header and contains a QList&lt;QNetworkCookie&gt; representing the cookies sent by the server to be stored locally</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkRequest.LoadControl">
            <summary>
                <para>Indicates if an aspect of the request's loading mechanism has been manually overridden, e.g. by QtWebKit.</para>
                <para>This enum was introduced or modified in Qt 4.7.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.LoadControl.Automatic">
            <summary>
                <para>Default value: indicates default behaviour.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.LoadControl.Manual">
            <summary>
                <para>Indicates behaviour has been manually overridden.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkRequest.Priority">
            <summary>
                <para>This enum lists the possible network request priorities.</para>
                <para>This enum was introduced or modified in Qt 4.7.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Priority.HighPriority">
            <summary>
                <para>High priority</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Priority.LowPriority">
            <summary>
                <para>Low priority</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Priority.NormalPriority">
            <summary>
                <para>Normal priority</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkRequest.OriginatingObject">
            <summary>
                <para>Returns a reference to the object that initiated this network request; returns 0 if not set or the object has been destroyed.</para>
                <para>This function was introduced in Qt 4.6.</para>
                <para>Allows setting a reference to the object initiating the request.</para>
                <para>For example QtWebKit sets the originating object to the QWebFrame that initiated the request.</para>
                <para>This function was introduced in Qt 4.6.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkRequest.priority">
            <summary>
                <para>Return the priority of this request.</para>
                <para>This function was introduced in Qt 4.7.</para>
                <para>Set the priority of this request to priority.</para>
                <para>Note: The priority is only a hint to the network access manager. It can use it or not. Currently it is used for HTTP to decide which request should be sent first to a server.</para>
                <para>This function was introduced in Qt 4.7.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkRequest.SslConfiguration">
            <summary>
                <para>Returns this network request's SSL configuration. By default, no SSL settings are specified.</para>
                <para>Sets this network request's SSL configuration to be config. The settings that apply are the private key, the local certificate, the SSL protocol (SSLv2, SSLv3, TLSv1 where applicable), the CA certificates and the ciphers that the SSL backend is allowed to use.</para>
                <para>By default, no SSL configuration is set, which allows the backends to choose freely what configuration is best for them.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkRequest.Url">
            <summary>
                <para>Returns the URL this network request is referring to.</para>
                <para>Sets the URL this network request is referring to to be url.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkRequest.RawHeaderList">
            <summary>
                <para>Returns a list of all raw headers that are set in this network request. The list is in the order that the headers were set.</para>
                <para>See also hasRawHeader() and rawHeader().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkRequest.attribute(QtNetwork.QNetworkRequest.Attribute)">
            <summary>
                <para>Returns the attribute associated with the code code. If the attribute has not been set, it returns defaultValue.</para>
                <para>Note: this function does not apply the defaults listed in QNetworkRequest::Attribute.</para>
                <para>See also setAttribute() and QNetworkRequest::Attribute.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkRequest.attribute(QtNetwork.QNetworkRequest.Attribute,System.Object)">
            <summary>
                <para>Returns the attribute associated with the code code. If the attribute has not been set, it returns defaultValue.</para>
                <para>Note: this function does not apply the defaults listed in QNetworkRequest::Attribute.</para>
                <para>See also setAttribute() and QNetworkRequest::Attribute.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkRequest.HasRawHeader(QtCore.QByteArray)">
            <summary>
                <para>Returns true if the raw header headerName is present in this network request.</para>
                <para>See also rawHeader() and setRawHeader().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkRequest.Header(QtNetwork.QNetworkRequest.KnownHeaders)">
            <summary>
                <para>Returns the value of the known network header header if it is present in this request. If it is not present, returns QVariant() (i.e., an invalid variant).</para>
                <para>See also KnownHeaders, rawHeader(), and setHeader().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkRequest.RawHeader(QtCore.QByteArray)">
            <summary>
                <para>Returns the raw form of header headerName. If no such header is present, an empty QByteArray is returned, which may be indistinguishable from a header that is present but has no content (use hasRawHeader() to find out if the header exists or not).</para>
                <para>Raw headers can be set with setRawHeader() or with setHeader().</para>
                <para>See also header() and setRawHeader().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkRequest.SetAttribute(QtNetwork.QNetworkRequest.Attribute,System.Object)">
            <summary>
                <para>Sets the attribute associated with code code to be value value. If the attribute is already set, the previous value is discarded. In special, if value is an invalid QVariant, the attribute is unset.</para>
                <para>See also attribute() and QNetworkRequest::Attribute.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkRequest.SetHeader(QtNetwork.QNetworkRequest.KnownHeaders,System.Object)">
            <summary>
                <para>Sets the value of the known header header to be value, overriding any previously set headers. This operation also sets the equivalent raw HTTP header.</para>
                <para>See also KnownHeaders, setRawHeader(), and header().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkRequest.SetRawHeader(QtCore.QByteArray,QtCore.QByteArray)">
            <summary>
                <para>Sets the header headerName to be of value headerValue. If headerName corresponds to a known header (see QNetworkRequest::KnownHeaders), the raw format will be parsed and the corresponding "cooked" header will be set as well.</para>
                <para>For example:</para>
                <para> request.setRawHeader("Last-Modified", "Sun, 06 Nov 1994 08:49:37 GMT");</para>
                <para>will also set the known header LastModifiedHeader to be the QDateTime object of the parsed date.</para>
                <para>Note: setting the same header twice overrides the previous setting. To accomplish the behaviour of multiple HTTP headers of the same name, you should concatenate the two values, separating them with a comma (",") and set one single raw header.</para>
                <para>See also KnownHeaders, setHeader(), hasRawHeader(), and rawHeader().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkRequest.Finalize">
            <summary>
                <para>Disposes of the QNetworkRequest object.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkRequest.op_Inequality(QtNetwork.QNetworkRequest,QtNetwork.QNetworkRequest)">
            <summary>
                <para>Returns false if this object is not the same as other.</para>
                <para>See also operator==().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkRequest.op_Equality(QtNetwork.QNetworkRequest,QtNetwork.QNetworkRequest)">
            <summary>
                <para>Returns true if this object is the same as other (i.e., if they have the same URL, same headers and same meta-data settings).</para>
                <para>See also operator!=().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkSession">
            <summary>
            The QNetworkSession class provides control over the system's access points and enables session management for cases when multiple clients access the same access point.
            </summary>
            <remarks>
                <para>
                </para>
                <para>A QNetworkSession enables control over the system's network interfaces. The session's configuration parameter are determined via the QNetworkConfiguration object to which it is bound. Depending on the type of the session (single access point or service network) a session may be linked to one or more network interfaces. By means of opening and closing of network sessions a developer can start and stop the systems network interfaces. If the configuration represents multiple access points (see QNetworkConfiguration::ServiceNetwork) more advanced features such as roaming may be supported.</para>
                <para>QNetworkSession supports session management within the same process and depending on the platform's capabilities may support out-of-process sessions. If the same network configuration is used by multiple open sessions the underlying network interface is only terminated once the last session has been closed.</para>
                <para>
                </para>
                <para>Roaming</para>
                <para>Applications may connect to the preferredConfigurationChanged() signal in order to receive notifications when a more suitable access point becomes available. In response to this signal the application must either initiate the roaming via migrate() or ignore() the new access point. Once the session has roamed the newConfigurationActivated() signal is emitted. The application may now test the carrier and must either accept() or reject() it. The session will return to the previous access point if the roaming was rejected. The subsequent state diagram depicts the required state transitions.</para>
                <para>Some platforms may distinguish forced roaming and application level roaming (ALR). ALR implies that the application controls (via migrate(), ignore(), accept() and reject()) whether a network session can roam from one access point to the next. Such control is useful if the application maintains stateful socket connections and wants to control the transition from one interface to the next. Forced roaming implies that the system automatically roams to the next network without consulting the application. This has the advantage that the application can make use of roaming features without actually being aware of it. It is expected that the application detects that the underlying socket is broken and automatically reconnects via the new network link.</para>
                <para>If the platform supports both modes of roaming, an application indicates its preference by connecting to the preferredConfigurationChanged() signal. Connecting to this signal means that the application wants to take control over the roaming behavior and therefore implies application level roaming. If the client does not connect to the preferredConfigurationChanged(), forced roaming is used. If forced roaming is not supported the network session will not roam by default.</para>
                <para>Some applications may want to suppress any form of roaming altogether. Possible use cases may be high priority downloads or remote services which cannot handle a roaming enabled client. Clients can suppress roaming by connecting to the preferredConfigurationChanged() signal and answer each signal emission with ignore().</para>
                <para>
                </para>
                <para>See also QNetworkConfiguration and QNetworkConfigurationManager.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QNetworkSession.#ctor(QtNetwork.QNetworkConfiguration,QtCore.QObject)">
            <summary>
                <para>Constructs a session based on connectionConfig with the given parent.</para>
                <para>See also QNetworkConfiguration.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkSession.SessionError">
            <summary>
                <para>This enum describes the session errors that can occur.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkSession.SessionError.InvalidConfigurationError">
            <summary>
                <para>The operation cannot currently be performed for the current configuration.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkSession.SessionError.OperationNotSupportedError">
            <summary>
                <para>The operation is not supported for current configuration.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkSession.SessionError.RoamingError">
            <summary>
                <para>The session cannot roam to a new configuration.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkSession.SessionError.SessionAbortedError">
            <summary>
                <para>The session was aborted by the user or system.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkSession.SessionError.UnknownSessionError">
            <summary>
                <para>An unidentified error occurred.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkSession.State">
            <summary>
                <para>This enum describes the connectivity state of the session. If the session is based on a single access point configuration the state of the session is the same as the state of the associated network interface.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkSession.State.Closing">
            <summary>
                <para>The network session is in the process of being shut down.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkSession.State.Connected">
            <summary>
                <para>The network session is connected. If the current process wishes to use this session it has to register its interest by calling open(). A network session is considered to be ready for socket operations if it isOpen() and connected.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkSession.State.Connecting">
            <summary>
                <para>The network session is being established.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkSession.State.Disconnected">
            <summary>
                <para>The network session is not connected. The associated QNetworkConfiguration has the state QNetworkConfiguration::Discovered.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkSession.State.Invalid">
            <summary>
                <para>The session is invalid due to an invalid configuration. This may happen due to a removed access point or a configuration that was invalid to begin with.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkSession.State.NotAvailable">
            <summary>
                <para>The session is based on a defined but not yet discovered QNetworkConfiguration (see QNetworkConfiguration::StateFlag).</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkSession.State.Roaming">
            <summary>
                <para>The network session is roaming from one access point to another access point.</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkSession.StateChanged">
            <summary>
                <para>This signal is emitted whenever the state of the network session changes. The state parameter is the new state.</para>
                <para>See also state().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkSession.Opened">
            <summary>
                <para>This signal is emitted when the network session has been opened.</para>
                <para>The underlying network interface will not be shut down as long as the session remains open. Note that this feature is dependent on system wide session support.</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkSession.Closed">
            <summary>
                <para>This signal is emitted when the network session has been closed.</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkSession.ErrorError">
            <summary>
                <para>This signal is emitted after an error occurred. The error parameter describes the error that occurred.</para>
                <para>See also error() and errorString().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkSession.PreferredConfigurationChanged">
            <summary>
                <para>This signal is emitted when the preferred configuration/access point for the session changes. Only sessions which are based on service network configurations may emit this signal. config can be used to determine access point specific details such as proxy settings and isSeamless indicates whether roaming will break the sessions IP address.</para>
                <para>As a consequence to this signal the application must either start the roaming process by calling migrate() or choose to ignore() the new access point.</para>
                <para>If the roaming process is non-seamless the IP address will change which means that a socket becomes invalid. However seamless mobility can ensure that the local IP address does not change. This is achieved by using a virtual IP address which is bound to the actual link address. During the roaming process the virtual address is attached to the new link address.</para>
                <para>Some platforms may support the concept of Forced Roaming and Application Level Roaming (ALR). Forced roaming implies that the platform may simply roam to a new configuration without consulting applications. It is up to the application to detect the link layer loss and reestablish its sockets. In contrast ALR provides the opportunity to prevent the system from roaming. If this session is based on a configuration that supports roaming the application can choose whether it wants to be consulted (ALR use case) by connecting to this signal. For as long as this signal connection remains the session remains registered as a roaming stakeholder; otherwise roaming will be enforced by the platform.</para>
                <para>See also migrate(), ignore(), and QNetworkConfiguration::isRoamingAvailable().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkSession.NewConfigurationActivated">
            <summary>
                <para>This signal is emitted once the session has roamed to the new access point. The application may reopen its socket and test the suitability of the new network link. Subsequently it must either accept() or reject() the new access point.</para>
                <para>See also accept() and reject().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkSession.ActiveTime">
            <summary>
                <para>Returns the number of seconds that the session has been active.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkSession.BytesReceived">
            <summary>
                <para>Returns the amount of data received in bytes; otherwise 0.</para>
                <para>This field value includes the usage across all open network sessions which use the same network interface.</para>
                <para>If the session is based on a service network configuration the number of sent bytes across all active member configurations are returned.</para>
                <para>This function may not always be supported on all platforms and returns 0. The platform capability can be detected via QNetworkConfigurationManager::DataStatistics.</para>
                <para>Note: On some platforms this function may run the main event loop.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkSession.BytesWritten">
            <summary>
                <para>Returns the amount of data sent in bytes; otherwise 0.</para>
                <para>This field value includes the usage across all open network sessions which use the same network interface.</para>
                <para>If the session is based on a service network configuration the number of sent bytes across all active member configurations are returned.</para>
                <para>This function may not always be supported on all platforms and returns 0. The platform capability can be detected via QNetworkConfigurationManager::DataStatistics.</para>
                <para>Note: On some platforms this function may run the main event loop.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkSession.Configuration">
            <summary>
                <para>Returns the QNetworkConfiguration that this network session object is based on.</para>
                <para>See also QNetworkConfiguration.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkSession.ErrorString">
            <summary>
                <para>Returns a human-readable description of the last device error that occurred.</para>
                <para>See also error().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkSession.Interface">
            <summary>
                <para>Returns the network interface that is used by this session.</para>
                <para>This function only returns a valid QNetworkInterface when this session is Connected.</para>
                <para>The returned interface may change as a result of a roaming process.</para>
                <para>Note: this function does not work in Symbian emulator due to the way the connectivity is emulated on Windows.</para>
                <para>See also state().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkSession.IsOpen">
            <summary>
                <para>Returns true if this session is open. If the number of all open sessions is greater than zero the underlying network interface will remain connected/up.</para>
                <para>The session can be controlled via open() and close().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkSession.state">
            <summary>
                <para>Returns the state of the session.</para>
                <para>If the session is based on a single access point configuration the state of the session is the same as the state of the associated network interface. Therefore a network session object can be used to monitor network interfaces.</para>
                <para>A QNetworkConfiguration::ServiceNetwork based session summarizes the state of all its children and therefore returns the Connected state if at least one of the service network's children() configurations is active.</para>
                <para>Note that it is not required to hold an open session in order to obtain the network interface state. A connected but closed session may be used to monitor network interfaces whereas an open and connected session object may prevent the network interface from being shut down.</para>
                <para>See also error() and stateChanged().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkSession.Accept">
            <summary>
                <para>Instructs the session to permanently accept the new access point. Once this function has been called the session may not return to the old access point.</para>
                <para>The old access point may be closed in the process if there are no other network sessions for it. Therefore any open socket that still uses the old access point may become unusable and should be closed before completing the migration.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkSession.Close">
            <summary>
                <para>Decreases the session counter on the associated network configuration. If the session counter reaches zero the active network interface is shut down. This also means that state() will only change from Connected to Disconnected if the current session was the last open session.</para>
                <para>If the platform does not support out-of-process sessions calling this function does not stop the interface. In this case stop() has to be used to force a shut down. The platform capabilities can be detected via QNetworkConfigurationManager::capabilities().</para>
                <para>Note that this call is asynchronous. Depending on the outcome of this call the results can be enquired by connecting to the stateChanged(), opened() or error() signals.</para>
                <para>See also open(), stop(), and isOpen().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkSession.OnClosed">
            <summary>
                <para>This signal is emitted when the network session has been closed.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkSession.Error">
            <summary>
                <para>Returns the type of error that last occurred.</para>
                <para>See also state() and errorString().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkSession.OnError(QtNetwork.QNetworkSession.SessionError)">
            <summary>
                <para>This signal is emitted after an error occurred. The error parameter describes the error that occurred.</para>
                <para>See also error() and errorString().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkSession.Ignore">
            <summary>
                <para>This function indicates that the application does not wish to roam the session.</para>
                <para>See also migrate().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkSession.Migrate">
            <summary>
                <para>Instructs the session to roam to the new access point. The old access point remains active until the application calls accept().</para>
                <para>The newConfigurationActivated() signal is emitted once roaming has been completed.</para>
                <para>See also accept().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkSession.OnNewConfigurationActivated">
            <summary>
                <para>This signal is emitted once the session has roamed to the new access point. The application may reopen its socket and test the suitability of the new network link. Subsequently it must either accept() or reject() the new access point.</para>
                <para>See also accept() and reject().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkSession.Open">
            <summary>
                <para>Creates an open session which increases the session counter on the underlying network interface. The system will not terminate a network interface until the session reference counter reaches zero. Therefore an open session allows an application to register its use of the interface.</para>
                <para>As a result of calling open() the interface will be started if it is not connected/up yet. Some platforms may not provide support for out-of-process sessions. On such platforms the session counter ignores any sessions held by another process. The platform capabilities can be detected via QNetworkConfigurationManager::capabilities().</para>
                <para>Note that this call is asynchronous. Depending on the outcome of this call the results can be enquired by connecting to the stateChanged(), opened() or error() signals.</para>
                <para>It is not a requirement to open a session in order to monitor the underlying network interface.</para>
                <para>See also close(), stop(), and isOpen().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkSession.OnOpened">
            <summary>
                <para>This signal is emitted when the network session has been opened.</para>
                <para>The underlying network interface will not be shut down as long as the session remains open. Note that this feature is dependent on system wide session support.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkSession.OnPreferredConfigurationChanged(QtNetwork.QNetworkConfiguration,System.Boolean)">
            <summary>
                <para>This signal is emitted when the preferred configuration/access point for the session changes. Only sessions which are based on service network configurations may emit this signal. config can be used to determine access point specific details such as proxy settings and isSeamless indicates whether roaming will break the sessions IP address.</para>
                <para>As a consequence to this signal the application must either start the roaming process by calling migrate() or choose to ignore() the new access point.</para>
                <para>If the roaming process is non-seamless the IP address will change which means that a socket becomes invalid. However seamless mobility can ensure that the local IP address does not change. This is achieved by using a virtual IP address which is bound to the actual link address. During the roaming process the virtual address is attached to the new link address.</para>
                <para>Some platforms may support the concept of Forced Roaming and Application Level Roaming (ALR). Forced roaming implies that the platform may simply roam to a new configuration without consulting applications. It is up to the application to detect the link layer loss and reestablish its sockets. In contrast ALR provides the opportunity to prevent the system from roaming. If this session is based on a configuration that supports roaming the application can choose whether it wants to be consulted (ALR use case) by connecting to this signal. For as long as this signal connection remains the session remains registered as a roaming stakeholder; otherwise roaming will be enforced by the platform.</para>
                <para>See also migrate(), ignore(), and QNetworkConfiguration::isRoamingAvailable().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkSession.Reject">
            <summary>
                <para>The new access point is not suitable for the application. By calling this function the session returns to the previous access point/configuration. This action may invalidate any socket that has been created via the not desired access point.</para>
                <para>See also accept().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkSession.SessionProperty(System.String)">
            <summary>
                <para>Returns the value for property key.</para>
                <para>A network session can have properties attached which may describe the session in more details. This function can be used to gain access to those properties.</para>
                <para>The following property keys are guaranteed to be specified on all platforms:</para>
                <para>
                </para>
                <para>KeyDescription</para>
                <para>ActiveConfiguration	If the session isOpen() this property returns the identifier of the QNetworkConfiguration that is used by this session; otherwise an empty string.The main purpose of this key is to determine which Internet access point is used if the session is based on a ServiceNetwork. The following code snippet highlights the difference:</para>
                <para> QNetworkConfigurationManager mgr;</para>
                <para> QNetworkConfiguration ap = mgr.defaultConfiguration();</para>
                <para> QNetworkSession *session = new QNetworkSession(ap);</para>
                <para> ... //code activates session</para>
                <para>
                </para>
                <para> QString ident = session-&gt;sessionProperty("ActiveConfiguration").toString();</para>
                <para> if ( ap.type() == QNetworkConfiguration::ServiceNetwork ) {</para>
                <para>     Q_ASSERT( ap.identifier() != ident );</para>
                <para>     Q_ASSERT( ap.children().contains( mgr.configurationFromIdentifier(ident) ) );</para>
                <para> } else if ( ap.type() == QNetworkConfiguration::InternetAccessPoint ) {</para>
                <para>     Q_ASSERT( ap.identifier() == ident );</para>
                <para> }</para>
                <para>
                </para>
                <para>UserChoiceConfiguration	If the session isOpen() and is bound to a QNetworkConfiguration of type UserChoice, this property returns the identifier of the QNetworkConfiguration that the configuration resolved to when open() was called; otherwise an empty string.The purpose of this key is to determine the real QNetworkConfiguration that the session is using. This key is different from ActiveConfiguration in that this key may return an identifier for either a service network or a Internet access points configurations, whereas ActiveConfiguration always returns identifiers to Internet access points configurations.</para>
                <para>
                </para>
                <para>ConnectInBackground	Setting this property to true before calling open() implies that the connection attempt is made but if no connection can be established, the user is not connsulted and asked to select a suitable connection. This property is not set by default and support for it depends on the platform.</para>
                <para>AutoCloseSessionTimeout	If the session requires polling to keep its state up to date, this property holds the timeout in milliseconds before the session will automatically close. If the value of this property is -1 the session will not automatically close. This property is set to -1 by default.The purpose of this property is to minimize resource use on platforms that use polling to update the state of the session. Applications can set the value of this property to the desired timeout before the session is closed. In response to the closed() signal the network session should be deleted to ensure that all polling is stopped. The session can then be recreated once it is required again. This property has no effect for sessions that do not require polling.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkSession.SetSessionProperty(System.String,System.Object)">
            <summary>
                <para>Sets the property value on the session. The property is identified using key. Removing an already set property can be achieved by passing an invalid QVariant.</para>
                <para>Note that the UserChoiceConfiguration and ActiveConfiguration properties are read only and cannot be changed using this method.</para>
                <para>See also sessionProperty().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkSession.OnStateChanged(QtNetwork.QNetworkSession.State)">
            <summary>
                <para>This signal is emitted whenever the state of the network session changes. The state parameter is the new state.</para>
                <para>See also state().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkSession.Stop">
            <summary>
                <para>Invalidates all open sessions against the network interface and therefore stops the underlying network interface. This function always changes the session's state() flag to Disconnected.</para>
                <para>On Symbian platform, a 'NetworkControl' capability is required for full interface-level stop (without the capability, only the current session is stopped).</para>
                <para>See also open() and close().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkSession.WaitForOpened(System.Int32)">
            <summary>
                <para>Waits until the session has been opened, up to msecs milliseconds. If the session has been opened, this function returns true; otherwise it returns false. In the case where it returns false, you can call error() to determine the cause of the error.</para>
                <para>The following example waits up to one second for the session to be opened:</para>
                <para> session-&gt;open();</para>
                <para> if (session-&gt;waitForOpened(1000))</para>
                <para>     qDebug("Open!");</para>
                <para>If msecs is -1, this function will not time out.</para>
                <para>See also open() and error().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkSession.Finalize">
            <summary>
                <para>Frees the resources associated with the QNetworkSession object.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QSslCertificate">
            <summary>
            The QSslCertificate class provides a convenient API for an X509 certificate.
            </summary>
            <remarks>
                <para>
                </para>
                <para>QSslCertificate stores an X509 certificate, and is commonly used to verify the identity and store information about the local host, a remotely connected peer, or a trusted third party Certificate Authority.</para>
                <para>There are many ways to construct a QSslCertificate. The most common way is to call QSslSocket::peerCertificate(), which returns a QSslCertificate object, or QSslSocket::peerCertificateChain(), which returns a list of them. You can also load certificates from a DER (binary) or PEM (Base64) encoded bundle, typically stored as one or more local files, or in a Qt Resource.</para>
                <para>You can call isNull() to check if your certificate is null. By default, QSslCertificate constructs a null certificate. To check if the certificate is valid, call isValid(). A null certificate is invalid, but an invalid certificate is not necessarily null. If you want to reset all contents in a certificate, call clear().</para>
                <para>After loading a certificate, you can find information about the certificate, its subject, and its issuer, by calling one of the many accessor functions, including version(), serialNumber(), issuerInfo() and subjectInfo(). You can call effectiveDate() and expiryDate() to check when the certificate starts being effective and when it expires. The publicKey() function returns the certificate subject's public key as a QSslKey. You can call issuerInfo() or subjectInfo() to get detailed information about the certificate issuer and its subject.</para>
                <para>Internally, QSslCertificate is stored as an X509 structure. You can access this handle by calling handle(), but the results are likely to not be portable.</para>
                <para>
                </para>
                <para>See also QSslSocket, QSslKey, QSslCipher, and QSslError.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QSslCertificate.#ctor">
            <summary>
                <para>Constructs a QSslCertificate by parsing the format encoded data and using the first available certificate found. You can later call isNull() to see if data contained a certificate, and if this certificate was loaded successfully.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCertificate.#ctor(QtNetwork.QSslCertificate)">
            <summary>
                <para>Constructs an identical copy of other.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCertificate.#ctor(QtCore.QIODevice,QSsl.EncodingFormat)">
            <summary>
                <para>Constructs a QSslCertificate by reading format encoded data from device and using the first certificate found. You can later call isNull() to see if device contained a certificate, and if this certificate was loaded successfully.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCertificate.#ctor(QtCore.QByteArray,QSsl.EncodingFormat)">
            <summary>
                <para>Constructs a QSslCertificate by parsing the format encoded data and using the first available certificate found. You can later call isNull() to see if data contained a certificate, and if this certificate was loaded successfully.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QSslCertificate.SubjectInfo">
            <summary>
                <para>Describes keys that you can pass to QSslCertificate::issuerInfo() or QSslCertificate::subjectInfo() to get information about the certificate issuer or subject.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QSslCertificate.SubjectInfo.CommonName">
            <summary>
                <para>"CN" The common name; most often this is used to store the host name.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QSslCertificate.SubjectInfo.CountryName">
            <summary>
                <para>"C" The country.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QSslCertificate.SubjectInfo.LocalityName">
            <summary>
                <para>"L" The locality.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QSslCertificate.SubjectInfo.Organization">
            <summary>
                <para>"O" The name of the organization.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QSslCertificate.SubjectInfo.OrganizationalUnitName">
            <summary>
                <para>"OU" The organizational unit name.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QSslCertificate.SubjectInfo.StateOrProvinceName">
            <summary>
                <para>"ST" The state or province.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCertificate.AlternateSubjectNames">
            <summary>
                <para>Returns the list of alternative subject names for this certificate. The alternate subject names typically contain host names, optionally with wildcards, that are valid for this certificate.</para>
                <para>These names are tested against the connected peer's host name, if either the subject information for CommonName doesn't define a valid host name, or the subject info name doesn't match the peer's host name.</para>
                <para>See also subjectInfo().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCertificate.EffectiveDate">
            <summary>
                <para>Returns the date-time that the certificate becomes valid, or an empty QDateTime if this is a null certificate.</para>
                <para>See also expiryDate().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCertificate.ExpiryDate">
            <summary>
                <para>Returns the date-time that the certificate expires, or an empty QDateTime if this is a null certificate.</para>
                <para>See also effectiveDate().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCertificate.Handle">
            <summary>
                <para>Returns a pointer to the native certificate handle, if there is one, or a null pointer otherwise.</para>
                <para>You can use this handle, together with the native API, to access extended information about the certificate.</para>
                <para>Warning: Use of this function has a high probability of being non-portable, and its return value may vary from platform to platform or change from minor release to minor release.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCertificate.IsNull">
            <summary>
                <para>Returns true if this is a null certificate (i.e., a certificate with no contents); otherwise returns false.</para>
                <para>By default, QSslCertificate constructs a null certificate.</para>
                <para>See also isValid() and clear().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCertificate.IsValid">
            <summary>
                <para>Returns true if this certificate is valid; otherwise returns false.</para>
                <para>Note: Currently, this function checks that the current data-time is within the date-time range during which the certificate is considered valid, and checks that the certificate is not in a blacklist of fraudulent certificates.</para>
                <para>See also isNull().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCertificate.PublicKey">
            <summary>
                <para>Returns the certificate subject's public key.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCertificate.SerialNumber">
            <summary>
                <para>Returns the certificate's serial number string in decimal format. In case the serial number cannot be converted to decimal format (i.e. if it is bigger than 4294967295, which means it does not fit into 4 bytes), its hexadecimal version is returned.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCertificate.Version">
            <summary>
                <para>Returns the certificate's version string.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCertificate.Clear">
            <summary>
                <para>Clears the contents of this certificate, making it a null certificate.</para>
                <para>See also isNull().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCertificate.Digest(QtCore.QCryptographicHash.Algorithm)">
            <summary>
                <para>Returns a cryptographic digest of this certificate. By default, an MD5 digest will be generated, but you can also specify a custom algorithm.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCertificate.FromData(QtCore.QByteArray,QSsl.EncodingFormat)">
            <summary>
                <para>Searches for and parses all certificates in data that are encoded in the specified format and returns them in a list of certificates.</para>
                <para>See also fromDevice().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCertificate.FromDevice(QtCore.QIODevice,QSsl.EncodingFormat)">
            <summary>
                <para>Searches for and parses all certificates in device that are encoded in the specified format and returns them in a list of certificates.</para>
                <para>See also fromData().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCertificate.FromPath(System.String,QSsl.EncodingFormat,QtCore.QRegExp.PatternSyntax)">
            <summary>
                <para>Searches all files in the path for certificates encoded in the specified format and returns them in a list. must be a file or a pattern matching one or more files, as specified by syntax.</para>
                <para>Example:</para>
                <para> foreach (const QSslCertificate &amp;cert, QSslCertificate::fromPath("C:/ssl/certificate.*.pem", QSsl::Pem,</para>
                <para>                                                          QRegExp::Wildcard)) {</para>
                <para>     qDebug() &lt;&lt; cert.issuerInfo(QSslCertificate::Organization);</para>
                <para> }</para>
                <para>See also fromData().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCertificate.IssuerInfo(QtCore.QByteArray)">
            <summary>
                <para>Returns the issuer information for tag from the certificate, or an empty string if there is no information for tag in the certificate.</para>
                <para>See also subjectInfo().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCertificate.IssuerInfo(QtNetwork.QSslCertificate.SubjectInfo)">
            <summary>
                <para>Returns the issuer information for the subject from the certificate, or an empty string if there is no information for subject in the certificate.</para>
                <para>See also subjectInfo().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCertificate.subjectInfo(QtCore.QByteArray)">
            <summary>
                <para>Returns the subject information for tag, or an empty string if there is no information for tag in the certificate.</para>
                <para>See also issuerInfo().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCertificate.subjectInfo(QtNetwork.QSslCertificate.SubjectInfo)">
            <summary>
                <para>Returns the information for the subject, or an empty string if there is no information for subject in the certificate.</para>
                <para>See also issuerInfo().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCertificate.ToDer">
            <summary>
                <para>Returns this certificate converted to a DER (binary) encoded representation.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCertificate.ToPem">
            <summary>
                <para>Returns this certificate converted to a PEM (Base64) encoded representation.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCertificate.Finalize">
            <summary>
                <para>Destroys the QSslCertificate.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCertificate.op_Inequality(QtNetwork.QSslCertificate,QtNetwork.QSslCertificate)">
            <summary>
                <para>Returns true if this certificate is not the same as other; otherwise returns false.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCertificate.op_Equality(QtNetwork.QSslCertificate,QtNetwork.QSslCertificate)">
            <summary>
                <para>Returns true if this certificate is the same as other; otherwise returns false.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QSslCipher">
            <summary>
            The QSslCipher class represents an SSL cryptographic cipher.
            </summary>
            <remarks>
                <para>
                </para>
                <para>QSslCipher stores information about one cryptographic cipher. It is most commonly used with QSslSocket, either for configuring which ciphers the socket can use, or for displaying the socket's ciphers to the user.</para>
                <para>
                </para>
                <para>See also QSslSocket and QSslKey.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QSslCipher.#ctor">
            <summary>
                <para>Constructs an empty QSslCipher object.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCipher.#ctor(QtNetwork.QSslCipher)">
            <summary>
                <para>Constructs an identical copy of the other cipher.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCipher.#ctor(System.String,QSsl.SslProtocol)">
            <summary>
                <para>Constructs a QSslCipher object for the cipher determined by name and protocol. The constructor accepts only supported ciphers (i.e., the name and protocol must identify a cipher in the list of ciphers returned by QSslSocket::supportedCiphers()).</para>
                <para>You can call isNull() after construction to check if name and protocol correctly identified a supported cipher.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCipher.AuthenticationMethod">
            <summary>
                <para>Returns the cipher's authentication method as a QString.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCipher.EncryptionMethod">
            <summary>
                <para>Returns the cipher's encryption method as a QString.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCipher.IsNull">
            <summary>
                <para>Returns true if this is a null cipher; otherwise returns false.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCipher.KeyExchangeMethod">
            <summary>
                <para>Returns the cipher's key exchange method as a QString.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCipher.Name">
            <summary>
                <para>Returns the name of the cipher, or an empty QString if this is a null cipher.</para>
                <para>See also isNull().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCipher.Protocol">
            <summary>
                <para>Returns the cipher's protocol type, or QSsl::UnknownProtocol if QSslCipher is unable to determine the protocol (protocolString() may contain more information).</para>
                <para>See also protocolString().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCipher.ProtocolString">
            <summary>
                <para>Returns the cipher's protocol as a QString.</para>
                <para>See also protocol().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCipher.SupportedBits">
            <summary>
                <para>Returns the number of bits supported by the cipher.</para>
                <para>See also usedBits().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCipher.UsedBits">
            <summary>
                <para>Returns the number of bits used by the cipher.</para>
                <para>See also supportedBits().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCipher.Finalize">
            <summary>
                <para>Destroys the QSslCipher object.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCipher.op_Inequality(QtNetwork.QSslCipher,QtNetwork.QSslCipher)">
            <summary>
                <para>Returns true if this cipher is not the same as other; otherwise, false is returned.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCipher.op_Equality(QtNetwork.QSslCipher,QtNetwork.QSslCipher)">
            <summary>
                <para>Returns true if this cipher is the same as other; otherwise, false is returned.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QSslConfiguration">
            <summary>
            The QSslConfiguration class holds the configuration and state of an SSL connection
            </summary>
            <remarks>
                <para>
                </para>
                <para>QSslConfiguration is used by Qt networking classes to relay information about an open SSL connection and to allow the application to control certain features of that connection.</para>
                <para>The settings that QSslConfiguration currently supports are:</para>
                <para>
                </para>
                <para>The SSL/TLS protocol to be used</para>
                <para>The certificate to be presented to the peer during connection and its associated private key</para>
                <para>The ciphers allowed to be used for encrypting the connection</para>
                <para>The list of Certificate Authorities certificates that are used to validate the peer's certificate</para>
                <para>
                </para>
                <para>These settings are applied only during the connection handshake. Setting them after the connection has been established has no effect.</para>
                <para>The state that QSslConfiguration supports are:</para>
                <para>
                </para>
                <para>The certificate the peer presented during handshake, along with the chain leading to a CA certificate</para>
                <para>The cipher used to encrypt this session</para>
                <para>
                </para>
                <para>The state can only be obtained once the SSL connection starts, but not necessarily before it's done. Some settings may change during the course of the SSL connection without need to restart it (for instance, the cipher can be changed over time).</para>
                <para>State in QSslConfiguration objects cannot be changed.</para>
                <para>QSslConfiguration can be used with QSslSocket and the Network Access API.</para>
                <para>Note that changing settings in QSslConfiguration is not enough to change the settings in the related SSL connection. You must call setSslConfiguration on a modified QSslConfiguration object to achieve that. The following example illustrates how to change the protocol to TLSv1 in a QSslSocket object:</para>
                <para> QSslConfiguration config = sslSocket.sslConfiguration();</para>
                <para> config.setProtocol(QSsl::TlsV1);</para>
                <para> sslSocket.setSslConfiguration(config);</para>
                <para>QSslSocket, QNetworkAccessManager, QSslSocket::sslConfiguration(), QSslSocket::setSslConfiguration()</para>
                <para>
                </para>
                <para>See also QSsl::SslProtocol, QSslCertificate, QSslCipher, and QSslKey.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QSslConfiguration.#ctor">
            <summary>
                <para>Constructs an empty SSL configuration. This configuration contains no valid settings and the state will be empty. isNull() will return true after this constructor is called.</para>
                <para>Once any setter methods are called, isNull() will return false.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslConfiguration.#ctor(QtNetwork.QSslConfiguration)">
            <summary>
                <para>Copies the configuration and state of other. If other is null, this object will be null too.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslConfiguration.CaCertificates">
            <summary>
                <para>Returns this connection's CA certificate database. The CA certificate database is used by the socket during the handshake phase to validate the peer's certificate. It can be modified prior to the handshake with setCaCertificates(), or with QSslSocket's addCaCertificate() and addCaCertificates().</para>
                <para>Sets this socket's CA certificate database to be certificates. The certificate database must be set prior to the SSL handshake. The CA certificate database is used by the socket during the handshake phase to validate the peer's certificate.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslConfiguration.Ciphers">
            <summary>
                <para>Returns this connection's current cryptographic cipher suite. This list is used during the handshake phase for choosing a session cipher. The returned list of ciphers is ordered by descending preference. (i.e., the first cipher in the list is the most preferred cipher). The session cipher will be the first one in the list that is also supported by the peer.</para>
                <para>By default, the handshake phase can choose any of the ciphers supported by this system's SSL libraries, which may vary from system to system. The list of ciphers supported by this system's SSL libraries is returned by QSslSocket::supportedCiphers(). You can restrict the list of ciphers used for choosing the session cipher for this socket by calling setCiphers() with a subset of the supported ciphers. You can revert to using the entire set by calling setCiphers() with the list returned by QSslSocket::supportedCiphers().</para>
                <para>Sets the cryptographic cipher suite for this socket to ciphers, which must contain a subset of the ciphers in the list returned by supportedCiphers().</para>
                <para>Restricting the cipher suite must be done before the handshake phase, where the session cipher is chosen.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslConfiguration.DefaultConfiguration">
            <summary>
                <para>Returns the default SSL configuration to be used in new SSL connections.</para>
                <para>The default SSL configuration consists of:</para>
                <para>
                </para>
                <para>no local certificate and no private key</para>
                <para>protocol SecureProtocols (meaning either TLS 1.0 or SSL 3 will be used)</para>
                <para>the system's default CA certificate list</para>
                <para>the cipher list equal to the list of the SSL libraries' supported SSL ciphers</para>
                <para>
                </para>
                <para>Sets the default SSL configuration to be used in new SSL connections to be configuration. Existing connections are not affected by this call.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslConfiguration.LocalCertificate">
            <summary>
                <para>Returns the certificate to be presented to the peer during the SSL handshake process.</para>
                <para>Sets the certificate to be presented to the peer during SSL handshake to be certificate.</para>
                <para>Setting the certificate once the connection has been established has no effect.</para>
                <para>A certificate is the means of identification used in the SSL process. The local certificate is used by the remote end to verify the local user's identity against its list of Certification Authorities. In most cases, such as in HTTP web browsing, only servers identify to the clients, so the client does not send a certificate.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslConfiguration.PeerVerifyDepth">
            <summary>
                <para>Returns the maximum number of certificates in the peer's certificate chain to be checked during the SSL handshake phase, or 0 (the default) if no maximum depth has been set, indicating that the whole certificate chain should be checked.</para>
                <para>The certificates are checked in issuing order, starting with the peer's own certificate, then its issuer's certificate, and so on.</para>
                <para>Sets the maximum number of certificates in the peer's certificate chain to be checked during the SSL handshake phase, to depth. Setting a depth of 0 means that no maximum depth is set, indicating that the whole certificate chain should be checked.</para>
                <para>The certificates are checked in issuing order, starting with the peer's own certificate, then its issuer's certificate, and so on.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslConfiguration.PeerVerifyMode">
            <summary>
                <para>Returns the verify mode. This mode decides whether QSslSocket should request a certificate from the peer (i.e., the client requests a certificate from the server, or a server requesting a certificate from the client), and whether it should require that this certificate is valid.</para>
                <para>The default mode is AutoVerifyPeer, which tells QSslSocket to use VerifyPeer for clients, QueryPeer for servers.</para>
                <para>Sets the verify mode to mode. This mode decides whether QSslSocket should request a certificate from the peer (i.e., the client requests a certificate from the server, or a server requesting a certificate from the client), and whether it should require that this certificate is valid.</para>
                <para>The default mode is AutoVerifyPeer, which tells QSslSocket to use VerifyPeer for clients, QueryPeer for servers.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslConfiguration.PrivateKey">
            <summary>
                <para>Returns the SSL key assigned to this connection or a null key if none has been assigned yet.</para>
                <para>Sets the connection's private key to key. The private key and the local certificate are used by clients and servers that must prove their identity to SSL peers.</para>
                <para>Both the key and the local certificate are required if you are creating an SSL server socket. If you are creating an SSL client socket, the key and local certificate are required if your client must identify itself to an SSL server.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslConfiguration.Protocol">
            <summary>
                <para>Returns the protocol setting for this SSL configuration.</para>
                <para>Sets the protocol setting for this configuration to be protocol.</para>
                <para>Setting the protocol once the connection has already been established has no effect.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslConfiguration.IsNull">
            <summary>
                <para>Returns true if this is a null QSslConfiguration object.</para>
                <para>A QSslConfiguration object is null if it has been default-constructed and no setter methods have been called.</para>
                <para>See also setProtocol(), setLocalCertificate(), setPrivateKey(), setCiphers(), and setCaCertificates().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslConfiguration.PeerCertificate">
            <summary>
                <para>Returns the peer's digital certificate (i.e., the immediate certificate of the host you are connected to), or a null certificate, if the peer has not assigned a certificate.</para>
                <para>The peer certificate is checked automatically during the handshake phase, so this function is normally used to fetch the certificate for display or for connection diagnostic purposes. It contains information about the peer, including its host name, the certificate issuer, and the peer's public key.</para>
                <para>Because the peer certificate is set during the handshake phase, it is safe to access the peer certificate from a slot connected to the QSslSocket::sslErrors() signal, QNetworkReply::sslErrors() signal, or the QSslSocket::encrypted() signal.</para>
                <para>If a null certificate is returned, it can mean the SSL handshake failed, or it can mean the host you are connected to doesn't have a certificate, or it can mean there is no connection.</para>
                <para>If you want to check the peer's complete chain of certificates, use peerCertificateChain() to get them all at once.</para>
                <para>See also peerCertificateChain(), QSslSocket::sslErrors(), QSslSocket::ignoreSslErrors(), QNetworkReply::sslErrors(), and QNetworkReply::ignoreSslErrors().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslConfiguration.PeerCertificateChain">
            <summary>
                <para>Returns the peer's chain of digital certificates, starting with the peer's immediate certificate and ending with the CA's certificate.</para>
                <para>Peer certificates are checked automatically during the handshake phase. This function is normally used to fetch certificates for display, or for performing connection diagnostics. Certificates contain information about the peer and the certificate issuers, including host name, issuer names, and issuer public keys.</para>
                <para>Because the peer certificate is set during the handshake phase, it is safe to access the peer certificate from a slot connected to the QSslSocket::sslErrors() signal, QNetworkReply::sslErrors() signal, or the QSslSocket::encrypted() signal.</para>
                <para>If an empty list is returned, it can mean the SSL handshake failed, or it can mean the host you are connected to doesn't have a certificate, or it can mean there is no connection.</para>
                <para>If you want to get only the peer's immediate certificate, use peerCertificate().</para>
                <para>See also peerCertificate(), QSslSocket::sslErrors(), QSslSocket::ignoreSslErrors(), QNetworkReply::sslErrors(), and QNetworkReply::ignoreSslErrors().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslConfiguration.SessionCipher">
            <summary>
                <para>Returns the socket's cryptographic cipher, or a null cipher if the connection isn't encrypted. The socket's cipher for the session is set during the handshake phase. The cipher is used to encrypt and decrypt data transmitted through the socket.</para>
                <para>The SSL infrastructure also provides functions for setting the ordered list of ciphers from which the handshake phase will eventually select the session cipher. This ordered list must be in place before the handshake phase begins.</para>
                <para>See also ciphers(), setCiphers(), and QSslSocket::supportedCiphers().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslConfiguration.SetSslOption(QSsl.SslOption,System.Boolean)">
            <summary>
                <para>Enables or disables an SSL compatibility option.</para>
                <para>See also testSSlOption().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslConfiguration.TestSslOption(QSsl.SslOption)">
            <summary>
                <para>Returns true if the specified SSL compatibility option is enabled.</para>
                <para>This function was introduced in Qt 4.8.</para>
                <para>See also testSSlOption().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslConfiguration.Finalize">
            <summary>
                <para>Releases any resources held by QSslConfiguration.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslConfiguration.op_Inequality(QtNetwork.QSslConfiguration,QtNetwork.QSslConfiguration)">
            <summary>
                <para>Returns true if this QSslConfiguration differs from other. Two QSslConfiguration objects are considered different if any state or setting is different.</para>
                <para>See also operator==().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslConfiguration.op_Equality(QtNetwork.QSslConfiguration,QtNetwork.QSslConfiguration)">
            <summary>
                <para>Returns true if this QSslConfiguration object is equal to other.</para>
                <para>Two QSslConfiguration objects are considered equal if they have the exact same settings and state.</para>
                <para>See also operator!=().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QSslError">
            <summary>
            The QSslError class provides an SSL error.
            </summary>
            <remarks>
                <para>
                </para>
                <para>QSslError provides a simple API for managing errors during QSslSocket's SSL handshake.</para>
                <para>
                </para>
                <para>See also QSslSocket, QSslCertificate, and QSslCipher.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QSslError.#ctor">
            <summary>
                <para>Constructs a QSslError object with no error and default certificate.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslError.#ctor(QtNetwork.QSslError)">
            <summary>
                <para>Constructs an identical copy of other.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslError.#ctor(QtNetwork.QSslError.SslError)">
            <summary>
                <para>Constructs a QSslError object. The argument specifies the error that occurred.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslError.#ctor(QtNetwork.QSslError.SslError,QtNetwork.QSslCertificate)">
            <summary>
                <para>Constructs a QSslError object. The two arguments specify the error that occurred, and which certificate the error relates to.</para>
                <para>See also QSslCertificate.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QSslError.SslError">
            <summary>
                <para>Describes all recognized errors that can occur during an SSL handshake.</para>
                <para>See also QSslError::errorString().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslError.Certificate">
            <summary>
                <para>Returns the certificate associated with this error, or a null certificate if the error does not relate to any certificate.</para>
                <para>See also error() and errorString().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslError.Error">
            <summary>
                <para>Returns the type of the error.</para>
                <para>See also errorString() and certificate().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslError.ErrorString">
            <summary>
                <para>Returns a short localized human-readable description of the error.</para>
                <para>See also error() and certificate().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslError.Finalize">
            <summary>
                <para>Destroys the QSslError object.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslError.op_Inequality(QtNetwork.QSslError,QtNetwork.QSslError)">
            <summary>
                <para>Returns true if this error is not equal to other; otherwise returns false.</para>
                <para>This function was introduced in Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslError.op_Equality(QtNetwork.QSslError,QtNetwork.QSslError)">
            <summary>
                <para>Returns true if this error is equal to other; otherwise returns false.</para>
                <para>This function was introduced in Qt 4.4.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QSslKey">
            <summary>
            The QSslKey class provides an interface for private and public keys.
            </summary>
            <remarks>
                <para>
                </para>
                <para>QSslKey provides a simple API for managing keys.</para>
                <para>
                </para>
                <para>See also QSslSocket, QSslCertificate, and QSslCipher.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QSslKey.#ctor">
            <summary>
                <para>Constructs a null key.</para>
                <para>See also isNull().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslKey.#ctor(QtNetwork.QSslKey)">
            <summary>
                <para>Constructs an identical copy of other.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslKey.#ctor(QtCore.QByteArray,QSsl.KeyAlgorithm,QSsl.EncodingFormat,QSsl.KeyType)">
            <summary>
                <para>Constructs a QSslKey by decoding the string in the byte array encoded using a specified algorithm and encoding format. If the encoded key is encrypted, passPhrase is used to decrypt it. type specifies whether the key is public or private.</para>
                <para>After construction, use isNull() to check if encoded contained a valid key.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslKey.#ctor(QtCore.QIODevice,QSsl.KeyAlgorithm,QSsl.EncodingFormat,QSsl.KeyType)">
            <summary>
                <para>Constructs a QSslKey by reading and decoding data from a device using a specified algorithm and encoding format. If the encoded key is encrypted, passPhrase is used to decrypt it. type specifies whether the key is public or private.</para>
                <para>After construction, use isNull() to check if device provided a valid key.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslKey.#ctor(QtCore.QByteArray,QSsl.KeyAlgorithm,QSsl.EncodingFormat,QSsl.KeyType,QtCore.QByteArray)">
            <summary>
                <para>Constructs a QSslKey by decoding the string in the byte array encoded using a specified algorithm and encoding format. If the encoded key is encrypted, passPhrase is used to decrypt it. type specifies whether the key is public or private.</para>
                <para>After construction, use isNull() to check if encoded contained a valid key.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslKey.#ctor(QtCore.QIODevice,QSsl.KeyAlgorithm,QSsl.EncodingFormat,QSsl.KeyType,QtCore.QByteArray)">
            <summary>
                <para>Constructs a QSslKey by reading and decoding data from a device using a specified algorithm and encoding format. If the encoded key is encrypted, passPhrase is used to decrypt it. type specifies whether the key is public or private.</para>
                <para>After construction, use isNull() to check if device provided a valid key.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslKey.Algorithm">
            <summary>
                <para>Returns the key algorithm.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslKey.Handle">
            <summary>
                <para>Returns a pointer to the native key handle, if it is available; otherwise a null pointer is returned.</para>
                <para>You can use this handle together with the native API to access extended information about the key.</para>
                <para>Warning: Use of this function has a high probability of being non-portable, and its return value may vary across platforms, and between minor Qt releases.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslKey.IsNull">
            <summary>
                <para>Returns true if this is a null key; otherwise false.</para>
                <para>See also clear().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslKey.Length">
            <summary>
                <para>Returns the length of the key in bits, or -1 if the key is null.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslKey.Type">
            <summary>
                <para>Returns the type of the key (i.e., PublicKey or PrivateKey).</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslKey.Clear">
            <summary>
                <para>Clears the contents of this key, making it a null key.</para>
                <para>See also isNull().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslKey.ToDer">
            <summary>
                <para>Returns the key in DER encoding. The result is encrypted with passPhrase if the key is a private key and passPhrase is non-empty.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslKey.ToDer(QtCore.QByteArray)">
            <summary>
                <para>Returns the key in DER encoding. The result is encrypted with passPhrase if the key is a private key and passPhrase is non-empty.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslKey.ToPem">
            <summary>
                <para>Returns the key in PEM encoding. The result is encrypted with passPhrase if the key is a private key and passPhrase is non-empty.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslKey.ToPem(QtCore.QByteArray)">
            <summary>
                <para>Returns the key in PEM encoding. The result is encrypted with passPhrase if the key is a private key and passPhrase is non-empty.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslKey.Finalize">
            <summary>
                <para>Destroys the QSslKey object.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslKey.op_Inequality(QtNetwork.QSslKey,QtNetwork.QSslKey)">
            <summary>
                <para>Returns true if this key is not equal to key other; otherwise returns false.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslKey.op_Equality(QtNetwork.QSslKey,QtNetwork.QSslKey)">
            <summary>
                <para>Returns true if this key is equal to other; otherwise returns false.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QSslSocket">
            <summary>
            The QSslSocket class provides an SSL encrypted socket for both clients and servers.
            </summary>
            <remarks>
                <para>
                </para>
                <para>QSslSocket establishes a secure, encrypted TCP connection you can use for transmitting encrypted data. It can operate in both client and server mode, and it supports modern SSL protocols, including SSLv3 and TLSv1. By default, QSslSocket uses TLSv1, but you can change the SSL protocol by calling setProtocol() as long as you do it before the handshake has started.</para>
                <para>SSL encryption operates on top of the existing TCP stream after the socket enters the ConnectedState. There are two simple ways to establish a secure connection using QSslSocket: With an immediate SSL handshake, or with a delayed SSL handshake occurring after the connection has been established in unencrypted mode.</para>
                <para>The most common way to use QSslSocket is to construct an object and start a secure connection by calling connectToHostEncrypted(). This method starts an immediate SSL handshake once the connection has been established.</para>
                <para> QSslSocket *socket = new QSslSocket(this);</para>
                <para> connect(socket, SIGNAL(encrypted()), this, SLOT(ready()));</para>
                <para>
                </para>
                <para> socket-&gt;connectToHostEncrypted("imap.example.com", 993);</para>
                <para>As with a plain QTcpSocket, QSslSocket enters the HostLookupState, ConnectingState, and finally the ConnectedState, if the connection is successful. The handshake then starts automatically, and if it succeeds, the encrypted() signal is emitted to indicate the socket has entered the encrypted state and is ready for use.</para>
                <para>Note that data can be written to the socket immediately after the return from connectToHostEncrypted() (i.e., before the encrypted() signal is emitted). The data is queued in QSslSocket until after the encrypted() signal is emitted.</para>
                <para>An example of using the delayed SSL handshake to secure an existing connection is the case where an SSL server secures an incoming connection. Suppose you create an SSL server class as a subclass of QTcpServer. You would override QTcpServer::incomingConnection() with something like the example below, which first constructs an instance of QSslSocket and then calls setSocketDescriptor() to set the new socket's descriptor to the existing one passed in. It then initiates the SSL handshake by calling startServerEncryption().</para>
                <para> void SslServer::incomingConnection(int socketDescriptor)</para>
                <para> {</para>
                <para>     QSslSocket *serverSocket = new QSslSocket;</para>
                <para>     if (serverSocket-&gt;setSocketDescriptor(socketDescriptor)) {</para>
                <para>         connect(serverSocket, SIGNAL(encrypted()), this, SLOT(ready()));</para>
                <para>         serverSocket-&gt;startServerEncryption();</para>
                <para>     } else {</para>
                <para>         delete serverSocket;</para>
                <para>     }</para>
                <para> }</para>
                <para>If an error occurs, QSslSocket emits the sslErrors() signal. In this case, if no action is taken to ignore the error(s), the connection is dropped. To continue, despite the occurrence of an error, you can call ignoreSslErrors(), either from within this slot after the error occurs, or any time after construction of the QSslSocket and before the connection is attempted. This will allow QSslSocket to ignore the errors it encounters when establishing the identity of the peer. Ignoring errors during an SSL handshake should be used with caution, since a fundamental characteristic of secure connections is that they should be established with a successful handshake.</para>
                <para>Once encrypted, you use QSslSocket as a regular QTcpSocket. When readyRead() is emitted, you can call read(), canReadLine() and readLine(), or getChar() to read decrypted data from QSslSocket's internal buffer, and you can call write() or putChar() to write data back to the peer. QSslSocket will automatically encrypt the written data for you, and emit encryptedBytesWritten() once the data has been written to the peer.</para>
                <para>As a convenience, QSslSocket supports QTcpSocket's blocking functions waitForConnected(), waitForReadyRead(), waitForBytesWritten(), and waitForDisconnected(). It also provides waitForEncrypted(), which will block the calling thread until an encrypted connection has been established.</para>
                <para> QSslSocket socket;</para>
                <para> socket.connectToHostEncrypted("http.example.com", 443);</para>
                <para> if (!socket.waitForEncrypted()) {</para>
                <para>     qDebug() &lt;&lt; socket.errorString();</para>
                <para>     return false;</para>
                <para> }</para>
                <para>
                </para>
                <para> socket.write("GET / HTTP/1.0\\r\\n\\r\\n");</para>
                <para> while (socket.waitForReadyRead())</para>
                <para>     qDebug() &lt;&lt; socket.readAll().data();</para>
                <para>QSslSocket provides an extensive, easy-to-use API for handling cryptographic ciphers, private keys, and local, peer, and Certification Authority (CA) certificates. It also provides an API for handling errors that occur during the handshake phase.</para>
                <para>The following features can also be customized:</para>
                <para>
                </para>
                <para>The socket's cryptographic cipher suite can be customized before the handshake phase with setCiphers() and setDefaultCiphers().</para>
                <para>The socket's local certificate and private key can be customized before the handshake phase with setLocalCertificate() and setPrivateKey().</para>
                <para>The CA certificate database can be extended and customized with addCaCertificate(), addCaCertificates(), setCaCertificates(), addDefaultCaCertificate(), addDefaultCaCertificates(), and setDefaultCaCertificates().</para>
                <para>
                </para>
                <para>Note: If available, root certificates on Unix (excluding Mac OS X) will be loaded on demand from the standard certificate directories. If you do not want to load root certificates on demand, you need to call either the static function setDefaultCaCertificates() before the first SSL handshake is made in your application, (e.g. via "QSslSocket::setDefaultCaCertificates(QSslSocket::systemCaCertificates());"), or call setCaCertificates() on your QSslSocket instance prior to the SSL handshake.</para>
                <para>For more information about ciphers and certificates, refer to QSslCipher and QSslCertificate.</para>
                <para>This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/).</para>
                <para>Note: Be aware of the difference between the bytesWritten() signal and the encryptedBytesWritten() signal. For a QTcpSocket, bytesWritten() will get emitted as soon as data has been written to the TCP socket. For a QSslSocket, bytesWritten() will get emitted when the data is being encrypted and encryptedBytesWritten() will get emitted as soon as data has been written to the TCP socket.</para>
                <para>
                </para>
                <para>Symbian Platform Security Requirements</para>
                <para>On Symbian, processes which use this class must have the NetworkServices platform security capability. If the client process lacks this capability, operations will fail.</para>
                <para>Platform security capabilities are added via the TARGET.CAPABILITY qmake variable.</para>
                <para>
                </para>
                <para>See also QSslCertificate, QSslCipher, and QSslError.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QSslSocket.#ctor(QtCore.QObject)">
            <summary>
                <para>Constructs a QSslSocket object. parent is passed to QObject's constructor. The new socket's cipher suite is set to the one returned by the static method defaultCiphers().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QSslSocket.PeerVerifyMode">
            <summary>
                <para>Describes the peer verification modes for QSslSocket. The default mode is AutoVerifyPeer, which selects an appropriate mode depending on the socket's QSocket::SslMode.</para>
                <para>This enum was introduced or modified in Qt 4.4.</para>
                <para>See also QSslSocket::peerVerifyMode().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QSslSocket.PeerVerifyMode.AutoVerifyPeer">
            <summary>
                <para>QSslSocket will automatically use QueryPeer for server sockets and VerifyPeer for client sockets.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QSslSocket.PeerVerifyMode.QueryPeer">
            <summary>
                <para>QSslSocket will request a certificate from the peer, but does not require this certificate to be valid. This is useful when you want to display peer certificate details to the user without affecting the actual SSL handshake. This mode is the default for servers.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QSslSocket.PeerVerifyMode.VerifyNone">
            <summary>
                <para>QSslSocket will not request a certificate from the peer. You can set this mode if you are not interested in the identity of the other side of the connection. The connection will still be encrypted, and your socket will still send its local certificate to the peer if it's requested.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QSslSocket.PeerVerifyMode.VerifyPeer">
            <summary>
                <para>QSslSocket will request a certificate from the peer during the SSL handshake phase, and requires that this certificate is valid. On failure, QSslSocket will emit the QSslSocket::sslErrors() signal. This mode is the default for clients.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QSslSocket.SslMode">
            <summary>
                <para>Describes the connection modes available for QSslSocket.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QSslSocket.SslMode.SslClientMode">
            <summary>
                <para>The socket is a client-side SSL socket. It is either alreayd encrypted, or it is in the SSL handshake phase (see QSslSocket::isEncrypted()).</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QSslSocket.SslMode.SslServerMode">
            <summary>
                <para>The socket is a server-side SSL socket. It is either already encrypted, or it is in the SSL handshake phase (see QSslSocket::isEncrypted()).</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QSslSocket.SslMode.UnencryptedMode">
            <summary>
                <para>The socket is unencrypted. Its behavior is identical to QTcpSocket.</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QSslSocket.Encrypted">
            <summary>
                <para>This signal is emitted when QSslSocket enters encrypted mode. After this signal has been emitted, QSslSocket::isEncrypted() will return true, and all further transmissions on the socket will be encrypted.</para>
                <para>See also QSslSocket::connectToHostEncrypted() and QSslSocket::isEncrypted().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QSslSocket.PeerVerifyError">
            <summary>
                <para>QSslSocket can emit this signal several times during the SSL handshake, before encryption has been established, to indicate that an error has occurred while establishing the identity of the peer. The error is usually an indication that QSslSocket is unable to securely identify the peer.</para>
                <para>This signal provides you with an early indication when something's wrong. By connecting to this signal, you can manually choose to tear down the connection from inside the connected slot before the handshake has completed. If no action is taken, QSslSocket will proceed to emitting QSslSocket::sslErrors().</para>
                <para>This function was introduced in Qt 4.4.</para>
                <para>See also sslErrors().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QSslSocket.SslErrorsErrors">
            <summary>
                <para>QSslSocket emits this signal after the SSL handshake to indicate that one or more errors have occurred while establishing the identity of the peer. The errors are usually an indication that QSslSocket is unable to securely identify the peer. Unless any action is taken, the connection will be dropped after this signal has been emitted.</para>
                <para>If you want to continue connecting despite the errors that have occurred, you must call QSslSocket::ignoreSslErrors() from inside a slot connected to this signal. If you need to access the error list at a later point, you can call sslErrors() (without arguments).</para>
                <para>errors contains one or more errors that prevent QSslSocket from verifying the identity of the peer.</para>
                <para>Note: You cannot use Qt::QueuedConnection when connecting to this signal, or calling QSslSocket::ignoreSslErrors() will have no effect.</para>
                <para>See also peerVerifyError().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QSslSocket.ModeChanged">
            <summary>
                <para>This signal is emitted when QSslSocket changes from QSslSocket::UnencryptedMode to either QSslSocket::SslClientMode or QSslSocket::SslServerMode. mode is the new mode.</para>
                <para>See also QSslSocket::mode().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QSslSocket.EncryptedBytesWritten">
            <summary>
                <para>This signal is emitted when QSslSocket writes its encrypted data to the network. The written parameter contains the number of bytes that were successfully written.</para>
                <para>This function was introduced in Qt 4.4.</para>
                <para>See also QIODevice::bytesWritten().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.CaCertificates">
            <summary>
                <para>Returns this socket's CA certificate database. The CA certificate database is used by the socket during the handshake phase to validate the peer's certificate. It can be moodified prior to the handshake with addCaCertificate(), addCaCertificates(), and setCaCertificates().</para>
                <para>Note: On Unix, this method may return an empty list if the root certificates are loaded on demand.</para>
                <para>Sets this socket's CA certificate database to be certificates. The certificate database must be set prior to the SSL handshake. The CA certificate database is used by the socket during the handshake phase to validate the peer's certificate.</para>
                <para>The CA certificate database can be reset to the current default CA certificate database by calling this function with the list of CA certificates returned by defaultCaCertificates().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.Ciphers">
            <summary>
                <para>Returns this socket's current cryptographic cipher suite. This list is used during the socket's handshake phase for choosing a session cipher. The returned list of ciphers is ordered by descending preference. (i.e., the first cipher in the list is the most preferred cipher). The session cipher will be the first one in the list that is also supported by the peer.</para>
                <para>By default, the handshake phase can choose any of the ciphers supported by this system's SSL libraries, which may vary from system to system. The list of ciphers supported by this system's SSL libraries is returned by supportedCiphers(). You can restrict the list of ciphers used for choosing the session cipher for this socket by calling setCiphers() with a subset of the supported ciphers. You can revert to using the entire set by calling setCiphers() with the list returned by supportedCiphers().</para>
                <para>You can restrict the list of ciphers used for choosing the session cipher for all sockets by calling setDefaultCiphers() with a subset of the supported ciphers. You can revert to using the entire set by calling setCiphers() with the list returned by supportedCiphers().</para>
                <para>Sets the cryptographic cipher suite for this socket to ciphers, which must contain a subset of the ciphers in the list returned by supportedCiphers().</para>
                <para>Restricting the cipher suite must be done before the handshake phase, where the session cipher is chosen.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.DefaultCaCertificates">
            <summary>
                <para>Returns the current default CA certificate database. This database is originally set to your system's default CA certificate database. If no system default database is found, an empty database will be returned. You can override the default CA certificate database with your own CA certificate database using setDefaultCaCertificates().</para>
                <para>Each SSL socket's CA certificate database is initialized to the default CA certificate database.</para>
                <para>Note: On Unix, this method may return an empty list if the root certificates are loaded on demand.</para>
                <para>Sets the default CA certificate database to certificates. The default CA certificate database is originally set to your system's default CA certificate database. You can override the default CA certificate database with your own CA certificate database using this function.</para>
                <para>Each SSL socket's CA certificate database is initialized to the default CA certificate database.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.DefaultCiphers">
            <summary>
                <para>Returns the default cryptographic cipher suite for all sockets in this application. This list is used during the socket's handshake phase when negotiating with the peer to choose a session cipher. The list is ordered by preference (i.e., the first cipher in the list is the most preferred cipher).</para>
                <para>By default, the handshake phase can choose any of the ciphers supported by this system's SSL libraries, which may vary from system to system. The list of ciphers supported by this system's SSL libraries is returned by supportedCiphers().</para>
                <para>Sets the default cryptographic cipher suite for all sockets in this application to ciphers, which must contain a subset of the ciphers in the list returned by supportedCiphers().</para>
                <para>Restricting the default cipher suite only affects SSL sockets that perform their handshake phase after the default cipher suite has been changed.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.LocalCertificate">
            <summary>
                <para>Returns the socket's local certificate, or an empty certificate if no local certificate has been assigned.</para>
                <para>Sets the socket's local certificate to certificate. The local certificate is necessary if you need to confirm your identity to the peer. It is used together with the private key; if you set the local certificate, you must also set the private key.</para>
                <para>The local certificate and private key are always necessary for server sockets, but are also rarely used by client sockets if the server requires the client to authenticate.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.PeerVerifyDepth">
            <summary>
                <para>Returns the maximum number of certificates in the peer's certificate chain to be checked during the SSL handshake phase, or 0 (the default) if no maximum depth has been set, indicating that the whole certificate chain should be checked.</para>
                <para>The certificates are checked in issuing order, starting with the peer's own certificate, then its issuer's certificate, and so on.</para>
                <para>This function was introduced in Qt 4.4.</para>
                <para>Sets the maximum number of certificates in the peer's certificate chain to be checked during the SSL handshake phase, to depth. Setting a depth of 0 means that no maximum depth is set, indicating that the whole certificate chain should be checked.</para>
                <para>The certificates are checked in issuing order, starting with the peer's own certificate, then its issuer's certificate, and so on.</para>
                <para>This function was introduced in Qt 4.4.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.peerVerifyMode">
            <summary>
                <para>Returns the socket's verify mode. This mode mode decides whether QSslSocket should request a certificate from the peer (i.e., the client requests a certificate from the server, or a server requesting a certificate from the client), and whether it should require that this certificate is valid.</para>
                <para>The default mode is AutoVerifyPeer, which tells QSslSocket to use VerifyPeer for clients and QueryPeer for servers.</para>
                <para>This function was introduced in Qt 4.4.</para>
                <para>Sets the socket's verify mode to mode. This mode decides whether QSslSocket should request a certificate from the peer (i.e., the client requests a certificate from the server, or a server requesting a certificate from the client), and whether it should require that this certificate is valid.</para>
                <para>The default mode is AutoVerifyPeer, which tells QSslSocket to use VerifyPeer for clients and QueryPeer for servers.</para>
                <para>Setting this mode after encryption has started has no effect on the current connection.</para>
                <para>This function was introduced in Qt 4.4.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.PeerVerifyName">
            <summary>
                <para>Returns the different hostname for the certificate validation, as set by setPeerVerifyName or by connectToHostEncrypted.</para>
                <para>This function was introduced in Qt 4.8.</para>
                <para>Sets a different host name, given by hostName, for the certificate validation instead of the one used for the TCP connection.</para>
                <para>This function was introduced in Qt 4.8.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.PrivateKey">
            <summary>
                <para>Returns this socket's private key.</para>
                <para>Sets the socket's private key to key. The private key and the local certificate are used by clients and servers that must prove their identity to SSL peers.</para>
                <para>Both the key and the local certificate are required if you are creating an SSL server socket. If you are creating an SSL client socket, the key and local certificate are required if your client must identify itself to an SSL server.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.Protocol">
            <summary>
                <para>Returns the socket's SSL protocol. By default, QSsl::SecureProtocols is used.</para>
                <para>Sets the socket's SSL protocol to protocol. This will affect the next initiated handshake; calling this function on an already-encrypted socket will not affect the socket's protocol.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.SslConfiguration">
            <summary>
                <para>Returns the socket's SSL configuration state. The default SSL configuration of a socket is to use the default ciphers, default CA certificates, no local private key or certificate.</para>
                <para>The SSL configuration also contains fields that can change with time without notice.</para>
                <para>This function was introduced in Qt 4.4.</para>
                <para>Sets the socket's SSL configuration to be the contents of configuration. This function sets the local certificate, the ciphers, the private key and the CA certificates to those stored in configuration.</para>
                <para>It is not possible to set the SSL-state related fields.</para>
                <para>This function was introduced in Qt 4.4.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.AtEnd">
            <summary>
                <para>Reimplemented from QIODevice::atEnd().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.BytesAvailable">
            <summary>
                <para>Reimplemented from QIODevice::bytesAvailable().</para>
                <para>Returns the number of decrypted bytes that are immediately available for reading.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.BytesToWrite">
            <summary>
                <para>Reimplemented from QIODevice::bytesToWrite().</para>
                <para>Returns the number of unencrypted bytes that are waiting to be encrypted and written to the network.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.CanReadLine">
            <summary>
                <para>Reimplemented from QIODevice::canReadLine().</para>
                <para>Returns true if you can read one while line (terminated by a single ASCII '\\n' character) of decrypted characters; otherwise, false is returned.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.EncryptedBytesAvailable">
            <summary>
                <para>Returns the number of encrypted bytes that are awaiting decryption. Normally, this function will return 0 because QSslSocket decrypts its incoming data as soon as it can.</para>
                <para>This function was introduced in Qt 4.4.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.EncryptedBytesToWrite">
            <summary>
                <para>Returns the number of encrypted bytes that are waiting to be written to the network.</para>
                <para>This function was introduced in Qt 4.4.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.Flush">
            <summary>
                <para>This function writes as much as possible from the internal write buffer to the underlying network socket, without blocking. If any data was written, this function returns true; otherwise false is returned.</para>
                <para>Call this function if you need QSslSocket to start sending buffered data immediately. The number of bytes successfully written depends on the operating system. In most cases, you do not need to call this function, because QAbstractSocket will start sending data automatically once control goes back to the event loop. In the absence of an event loop, call waitForBytesWritten() instead.</para>
                <para>See also write() and waitForBytesWritten().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.IsEncrypted">
            <summary>
                <para>Returns true if the socket is encrypted; otherwise, false is returned.</para>
                <para>An encrypted socket encrypts all data that is written by calling write() or putChar() before the data is written to the network, and decrypts all incoming data as the data is received from the network, before you call read(), readLine() or getChar().</para>
                <para>QSslSocket emits encrypted() when it enters encrypted mode.</para>
                <para>You can call sessionCipher() to find which cryptographic cipher is used to encrypt and decrypt your data.</para>
                <para>See also mode().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.Mode">
            <summary>
                <para>Returns the current mode for the socket; either UnencryptedMode, where QSslSocket behaves identially to QTcpSocket, or one of SslClientMode or SslServerMode, where the client is either negotiating or in encrypted mode.</para>
                <para>When the mode changes, QSslSocket emits modeChanged()</para>
                <para>See also SslMode.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.PeerCertificate">
            <summary>
                <para>Returns the peer's digital certificate (i.e., the immediate certificate of the host you are connected to), or a null certificate, if the peer has not assigned a certificate.</para>
                <para>The peer certificate is checked automatically during the handshake phase, so this function is normally used to fetch the certificate for display or for connection diagnostic purposes. It contains information about the peer, including its host name, the certificate issuer, and the peer's public key.</para>
                <para>Because the peer certificate is set during the handshake phase, it is safe to access the peer certificate from a slot connected to the sslErrors() signal or the encrypted() signal.</para>
                <para>If a null certificate is returned, it can mean the SSL handshake failed, or it can mean the host you are connected to doesn't have a certificate, or it can mean there is no connection.</para>
                <para>If you want to check the peer's complete chain of certificates, use peerCertificateChain() to get them all at once.</para>
                <para>See also peerCertificateChain().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.PeerCertificateChain">
            <summary>
                <para>Returns the peer's chain of digital certificates, or an empty list of certificates.</para>
                <para>Peer certificates are checked automatically during the handshake phase. This function is normally used to fetch certificates for display, or for performing connection diagnostics. Certificates contain information about the peer and the certificate issuers, including host name, issuer names, and issuer public keys.</para>
                <para>The peer certificates are set in QSslSocket during the handshake phase, so it is safe to call this function from a slot connected to the sslErrors() signal or the encrypted() signal.</para>
                <para>If an empty list is returned, it can mean the SSL handshake failed, or it can mean the host you are connected to doesn't have a certificate, or it can mean there is no connection.</para>
                <para>If you want to get only the peer's immediate certificate, use peerCertificate().</para>
                <para>See also peerCertificate().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.SessionCipher">
            <summary>
                <para>Returns the socket's cryptographic cipher, or a null cipher if the connection isn't encrypted. The socket's cipher for the session is set during the handshake phase. The cipher is used to encrypt and decrypt data transmitted through the socket.</para>
                <para>QSslSocket also provides functions for setting the ordered list of ciphers from which the handshake phase will eventually select the session cipher. This ordered list must be in place before the handshake phase begins.</para>
                <para>See also ciphers(), setCiphers(), setDefaultCiphers(), defaultCiphers(), and supportedCiphers().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.SupportedCiphers">
            <summary>
                <para>Returns the list of cryptographic ciphers supported by this system. This list is set by the system's SSL libraries and may vary from system to system.</para>
                <para>See also defaultCiphers(), ciphers(), and setCiphers().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.SupportsSsl">
            <summary>
                <para>Returns true if this platform supports SSL; otherwise, returns false. If the platform doesn't support SSL, the socket will fail in the connection phase.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.SystemCaCertificates">
            <summary>
                <para>This function provides the CA certificate database provided by the operating system. The CA certificate database returned by this function is used to initialize the database returned by defaultCaCertificates(). You can replace that database with your own with setDefaultCaCertificates().</para>
                <para>See also caCertificates(), defaultCaCertificates(), and setDefaultCaCertificates().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.Abort">
            <summary>
                <para>Aborts the current connection and resets the socket. Unlike disconnectFromHost(), this function immediately closes the socket, clearing any pending data in the write buffer.</para>
                <para>See also disconnectFromHost() and close().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.AddCaCertificate(QtNetwork.QSslCertificate)">
            <summary>
                <para>Adds the certificate to this socket's CA certificate database. The CA certificate database is used by the socket during the handshake phase to validate the peer's certificate.</para>
                <para>To add multiple certificates, use addCaCertificates().</para>
                <para>See also caCertificates() and setCaCertificates().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.AddCaCertificates(System.String,QSsl.EncodingFormat,QtCore.QRegExp.PatternSyntax)">
            <summary>
                <para>Searches all files in the path for certificates encoded in the specified format and adds them to this socket's CA certificate database. path can be explicit, or it can contain wildcards in the format specified by syntax. Returns true if one or more certificates are added to the socket's CA certificate database; otherwise returns false.</para>
                <para>The CA certificate database is used by the socket during the handshake phase to validate the peer's certificate.</para>
                <para>For more precise control, use addCaCertificate().</para>
                <para>See also addCaCertificate() and QSslCertificate::fromPath().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.AddCaCertificates(System.Collections.Generic.List{QtNetwork.QSslCertificate})">
            <summary>
                <para>Adds the certificates to this socket's CA certificate database. The CA certificate database is used by the socket during the handshake phase to validate the peer's certificate.</para>
                <para>For more precise control, use addCaCertificate().</para>
                <para>See also caCertificates() and addDefaultCaCertificate().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.AddDefaultCaCertificate(QtNetwork.QSslCertificate)">
            <summary>
                <para>Adds certificate to the default CA certificate database. Each SSL socket's CA certificate database is initialized to the default CA certificate database.</para>
                <para>See also defaultCaCertificates() and addCaCertificates().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.AddDefaultCaCertificates(System.String,QSsl.EncodingFormat,QtCore.QRegExp.PatternSyntax)">
            <summary>
                <para>Searches all files in the path for certificates with the specified encoding and adds them to the default CA certificate database. path can be an explicit file, or it can contain wildcards in the format specified by syntax. Returns true if any CA certificates are added to the default database.</para>
                <para>Each SSL socket's CA certificate database is initialized to the default CA certificate database.</para>
                <para>See also defaultCaCertificates(), addCaCertificates(), and addDefaultCaCertificate().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.AddDefaultCaCertificates(System.Collections.Generic.List{QtNetwork.QSslCertificate})">
            <summary>
                <para>Adds certificates to the default CA certificate database. Each SSL socket's CA certificate database is initialized to the default CA certificate database.</para>
                <para>See also defaultCaCertificates() and addCaCertificates().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.Close">
            <summary>
                <para>Reimplemented from QIODevice::close().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.ConnectToHostEncrypted(System.String,System.UInt16,QtCore.QIODevice.OpenModeFlag)">
            <summary>
                <para>Starts an encrypted connection to the device hostName on port, using mode as the OpenMode. This is equivalent to calling connectToHost() to establish the connection, followed by a call to startClientEncryption().</para>
                <para>QSslSocket first enters the HostLookupState. Then, after entering either the event loop or one of the waitFor...() functions, it enters the ConnectingState, emits connected(), and then initiates the SSL client handshake. At each state change, QSslSocket emits signal stateChanged().</para>
                <para>After initiating the SSL client handshake, if the identity of the peer can't be established, signal sslErrors() is emitted. If you want to ignore the errors and continue connecting, you must call ignoreSslErrors(), either from inside a slot function connected to the sslErrors() signal, or prior to entering encrypted mode. If ignoreSslErrors() is not called, the connection is dropped, signal disconnected() is emitted, and QSslSocket returns to the UnconnectedState.</para>
                <para>If the SSL handshake is successful, QSslSocket emits encrypted().</para>
                <para> QSslSocket socket;</para>
                <para> connect(&amp;socket, SIGNAL(encrypted()), receiver, SLOT(socketEncrypted()));</para>
                <para>
                </para>
                <para> socket.connectToHostEncrypted("imap", 993);</para>
                <para> socket-&gt;write("1 CAPABILITY\\r\\n");</para>
                <para>Note: The example above shows that text can be written to the socket immediately after requesting the encrypted connection, before the encrypted() signal has been emitted. In such cases, the text is queued in the object and written to the socket after the connection is established and the encrypted() signal has been emitted.</para>
                <para>The default for mode is ReadWrite.</para>
                <para>If you want to create a QSslSocket on the server side of a connection, you should instead call startServerEncryption() upon receiving the incoming connection through QTcpServer.</para>
                <para>See also connectToHost(), startClientEncryption(), waitForConnected(), and waitForEncrypted().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.ConnectToHostEncrypted(System.String,System.UInt16,System.String,QtCore.QIODevice.OpenModeFlag)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>In addition to the original behaviour of connectToHostEncrypted, this overloaded method enables the usage of a different hostname (sslPeerName) for the certificate validation instead of the one used for the TCP connection (hostName).</para>
                <para>This function was introduced in Qt 4.6.</para>
                <para>See also connectToHostEncrypted().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.OnEncrypted">
            <summary>
                <para>This signal is emitted when QSslSocket enters encrypted mode. After this signal has been emitted, QSslSocket::isEncrypted() will return true, and all further transmissions on the socket will be encrypted.</para>
                <para>See also QSslSocket::connectToHostEncrypted() and QSslSocket::isEncrypted().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.OnEncryptedBytesWritten(System.Int64)">
            <summary>
                <para>This signal is emitted when QSslSocket writes its encrypted data to the network. The written parameter contains the number of bytes that were successfully written.</para>
                <para>This function was introduced in Qt 4.4.</para>
                <para>See also QIODevice::bytesWritten().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.IgnoreSslErrors">
            <summary>
                <para>This slot tells QSslSocket to ignore errors during QSslSocket's handshake phase and continue connecting. If you want to continue with the connection even if errors occur during the handshake phase, then you must call this slot, either from a slot connected to sslErrors(), or before the handshake phase. If you don't call this slot, either in response to errors or before the handshake, the connection will be dropped after the sslErrors() signal has been emitted.</para>
                <para>If there are no errors during the SSL handshake phase (i.e., the identity of the peer is established with no problems), QSslSocket will not emit the sslErrors() signal, and it is unnecessary to call this function.</para>
                <para>Ignoring errors that occur during an SSL handshake should be done with caution. A fundamental characteristic of secure connections is that they should be established with an error free handshake.</para>
                <para>See also sslErrors().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.IgnoreSslErrors(System.Collections.Generic.List{QtNetwork.QSslError})">
            <summary>
                <para>This is an overloaded function.</para>
                <para>This method tells QSslSocket to ignore only the errors given in errors.</para>
                <para>Note that you can set the expected certificate in the SSL error: If, for instance, you want to connect to a server that uses a self-signed certificate, consider the following snippet:</para>
                <para> QList&lt;QSslCertificate&gt; cert = QSslCertificate::fromPath(QLatin1String("server-certificate.pem"));</para>
                <para> QSslError error(QSslError::SelfSignedCertificate, cert.at(0));</para>
                <para> QList&lt;QSslError&gt; expectedSslErrors;</para>
                <para> expectedSslErrors.append(error);</para>
                <para>
                </para>
                <para> QSslSocket socket;</para>
                <para> socket.ignoreSslErrors(expectedSslErrors);</para>
                <para> socket.connectToHostEncrypted("server.tld", 443);</para>
                <para>Multiple calls to this function will replace the list of errors that were passed in previous calls. You can clear the list of errors you want to ignore by calling this function with an empty list.</para>
                <para>This function was introduced in Qt 4.6.</para>
                <para>See also sslErrors().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.OnModeChanged(QtNetwork.QSslSocket.SslMode)">
            <summary>
                <para>This signal is emitted when QSslSocket changes from QSslSocket::UnencryptedMode to either QSslSocket::SslClientMode or QSslSocket::SslServerMode. mode is the new mode.</para>
                <para>See also QSslSocket::mode().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.OnPeerVerifyError(QtNetwork.QSslError)">
            <summary>
                <para>QSslSocket can emit this signal several times during the SSL handshake, before encryption has been established, to indicate that an error has occurred while establishing the identity of the peer. The error is usually an indication that QSslSocket is unable to securely identify the peer.</para>
                <para>This signal provides you with an early indication when something's wrong. By connecting to this signal, you can manually choose to tear down the connection from inside the connected slot before the handshake has completed. If no action is taken, QSslSocket will proceed to emitting QSslSocket::sslErrors().</para>
                <para>This function was introduced in Qt 4.4.</para>
                <para>See also sslErrors().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.ReadData(QtCore.Pointer{System.SByte},System.Int64)">
            <summary>
                <para>Reimplemented from QIODevice::readData().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.SetCiphers(System.String)">
            <summary>
                <para>Sets the cryptographic cipher suite for this socket to ciphers, which is a colon-separated list of cipher suite names. The ciphers are listed in order of preference, starting with the most preferred cipher. For example:</para>
                <para> QSslSocket socket;</para>
                <para> socket.setCiphers("DHE-RSA-AES256-SHA:DHE-DSS-AES256-SHA:AES256-SHA");</para>
                <para>Each cipher name in ciphers must be the name of a cipher in the list returned by supportedCiphers(). Restricting the cipher suite must be done before the handshake phase, where the session cipher is chosen.</para>
                <para>See also ciphers(), setDefaultCiphers(), and supportedCiphers().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.SetLocalCertificate(System.String,QSsl.EncodingFormat)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets the socket's local certificate to the first one found in file path, which is parsed according to the specified format.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.SetPrivateKey(System.String,QSsl.KeyAlgorithm,QSsl.EncodingFormat)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Reads the string in file fileName and decodes it using a specified algorithm and encoding format to construct an SSL key. If the encoded key is encrypted, passPhrase is used to decrypt it.</para>
                <para>The socket's private key is set to the constructed key. The private key and the local certificate are used by clients and servers that must prove their identity to SSL peers.</para>
                <para>Both the key and the local certificate are required if you are creating an SSL server socket. If you are creating an SSL client socket, the key and local certificate are required if your client must identify itself to an SSL server.</para>
                <para>See also privateKey() and setLocalCertificate().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.SetPrivateKey(System.String,QSsl.KeyAlgorithm,QSsl.EncodingFormat,QtCore.QByteArray)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Reads the string in file fileName and decodes it using a specified algorithm and encoding format to construct an SSL key. If the encoded key is encrypted, passPhrase is used to decrypt it.</para>
                <para>The socket's private key is set to the constructed key. The private key and the local certificate are used by clients and servers that must prove their identity to SSL peers.</para>
                <para>Both the key and the local certificate are required if you are creating an SSL server socket. If you are creating an SSL client socket, the key and local certificate are required if your client must identify itself to an SSL server.</para>
                <para>See also privateKey() and setLocalCertificate().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.SetReadBufferSize(System.Int64)">
            <summary>
                <para>Sets the size of QSslSocket's internal read buffer to be size bytes.</para>
                <para>This function was introduced in Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.SetSocketDescriptor(System.Int32,QtNetwork.QAbstractSocket.SocketState,QtCore.QIODevice.OpenModeFlag)">
            <summary>
                <para>Initializes QSslSocket with the native socket descriptor socketDescriptor. Returns true if socketDescriptor is accepted as a valid socket descriptor; otherwise returns false. The socket is opened in the mode specified by openMode, and enters the socket state specified by state.</para>
                <para>Note: It is not possible to initialize two sockets with the same native socket descriptor.</para>
                <para>See also socketDescriptor().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.SetSocketOption(QtNetwork.QAbstractSocket.SocketOption,System.Object)">
            <summary>
                <para>Sets the given option to the value described by value.</para>
                <para>This function was introduced in Qt 4.6.</para>
                <para>See also socketOption().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.socketOption(QtNetwork.QAbstractSocket.SocketOption)">
            <summary>
                <para>Returns the value of the option option.</para>
                <para>This function was introduced in Qt 4.6.</para>
                <para>See also setSocketOption().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.SslErrors">
            <summary>
                <para>Returns a list of the last SSL errors that occurred. This is the same list as QSslSocket passes via the sslErrors() signal. If the connection has been encrypted with no errors, this function will return an empty list.</para>
                <para>See also connectToHostEncrypted().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.OnSslErrors(System.Collections.Generic.List{QtNetwork.QSslError})">
            <summary>
                <para>QSslSocket emits this signal after the SSL handshake to indicate that one or more errors have occurred while establishing the identity of the peer. The errors are usually an indication that QSslSocket is unable to securely identify the peer. Unless any action is taken, the connection will be dropped after this signal has been emitted.</para>
                <para>If you want to continue connecting despite the errors that have occurred, you must call QSslSocket::ignoreSslErrors() from inside a slot connected to this signal. If you need to access the error list at a later point, you can call sslErrors() (without arguments).</para>
                <para>errors contains one or more errors that prevent QSslSocket from verifying the identity of the peer.</para>
                <para>Note: You cannot use Qt::QueuedConnection when connecting to this signal, or calling QSslSocket::ignoreSslErrors() will have no effect.</para>
                <para>See also peerVerifyError().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.StartClientEncryption">
            <summary>
                <para>Starts a delayed SSL handshake for a client connection. This function can be called when the socket is in the ConnectedState but still in the UnencryptedMode. If it is not yet connected, or if it is already encrypted, this function has no effect.</para>
                <para>Clients that implement STARTTLS functionality often make use of delayed SSL handshakes. Most other clients can avoid calling this function directly by using connectToHostEncrypted() instead, which automatically performs the handshake.</para>
                <para>See also connectToHostEncrypted() and startServerEncryption().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.StartServerEncryption">
            <summary>
                <para>Starts a delayed SSL handshake for a server connection. This function can be called when the socket is in the ConnectedState but still in UnencryptedMode. If it is not connected or it is already encrypted, the function has no effect.</para>
                <para>For server sockets, calling this function is the only way to initiate the SSL handshake. Most servers will call this function immediately upon receiving a connection, or as a result of having received a protocol-specific command to enter SSL mode (e.g, the server may respond to receiving the string "STARTTLS\\r\\n" by calling this function).</para>
                <para>The most common way to implement an SSL server is to create a subclass of QTcpServer and reimplement QTcpServer::incomingConnection(). The returned socket descriptor is then passed to QSslSocket::setSocketDescriptor().</para>
                <para>See also connectToHostEncrypted() and startClientEncryption().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.WaitForBytesWritten(System.Int32)">
            <summary>
                <para>Reimplemented from QIODevice::waitForBytesWritten().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.WaitForConnected(System.Int32)">
            <summary>
                <para>Waits until the socket is connected, or msecs milliseconds, whichever happens first. If the connection has been established, this function returns true; otherwise it returns false.</para>
                <para>See also QAbstractSocket::waitForConnected().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.WaitForDisconnected(System.Int32)">
            <summary>
                <para>Waits until the socket has disconnected or msecs milliseconds, whichever comes first. If the connection has been disconnected, this function returns true; otherwise it returns false.</para>
                <para>See also QAbstractSocket::waitForDisconnected().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.WaitForEncrypted(System.Int32)">
            <summary>
                <para>Waits until the socket has completed the SSL handshake and has emitted encrypted(), or msecs milliseconds, whichever comes first. If encrypted() has been emitted, this function returns true; otherwise (e.g., the socket is disconnected, or the SSL handshake fails), false is returned.</para>
                <para>The following example waits up to one second for the socket to be encrypted:</para>
                <para> socket-&gt;connectToHostEncrypted("imap", 993);</para>
                <para> if (socket-&gt;waitForEncrypted(1000))</para>
                <para>     qDebug("Encrypted!");</para>
                <para>If msecs is -1, this function will not time out.</para>
                <para>See also startClientEncryption(), startServerEncryption(), encrypted(), and isEncrypted().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.WaitForReadyRead(System.Int32)">
            <summary>
                <para>Reimplemented from QIODevice::waitForReadyRead().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.WriteData(System.String,System.Int64)">
            <summary>
                <para>Reimplemented from QIODevice::writeData().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.Finalize">
            <summary>
                <para>Destroys the QSslSocket.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QTcpServer">
            <summary>
            The QTcpServer class provides a TCP-based server.
            </summary>
            <remarks>
                <para>
                </para>
                <para>This class makes it possible to accept incoming TCP connections. You can specify the port or have QTcpServer pick one automatically. You can listen on a specific address or on all the machine's addresses.</para>
                <para>Call listen() to have the server listen for incoming connections. The newConnection() signal is then emitted each time a client connects to the server.</para>
                <para>Call nextPendingConnection() to accept the pending connection as a connected QTcpSocket. The function returns a pointer to a QTcpSocket in QAbstractSocket::ConnectedState that you can use for communicating with the client.</para>
                <para>If an error occurs, serverError() returns the type of error, and errorString() can be called to get a human readable description of what happened.</para>
                <para>When listening for connections, the address and port on which the server is listening are available as serverAddress() and serverPort().</para>
                <para>Calling close() makes QTcpServer stop listening for incoming connections.</para>
                <para>Although QTcpServer is mostly designed for use with an event loop, it's possible to use it without one. In that case, you must use waitForNewConnection(), which blocks until either a connection is available or a timeout expires.</para>
                <para>
                </para>
                <para>Symbian Platform Security Requirements</para>
                <para>On Symbian, processes which use this class must have the NetworkServices platform security capability. If the client process lacks this capability, it will lead to a panic.</para>
                <para>Platform security capabilities are added via the TARGET.CAPABILITY qmake variable.</para>
                <para>
                </para>
                <para>See also QTcpSocket, Fortune Server Example, Threaded Fortune Server Example, Loopback Example, and Torrent Example.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QTcpServer.#ctor(QtCore.QObject)">
            <summary>
                <para>Constructs a QTcpServer object.</para>
                <para>parent is passed to the QObject constructor.</para>
                <para>See also listen() and setSocketDescriptor().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QTcpServer.NewConnection">
            <summary>
                <para>This signal is emitted every time a new connection is available.</para>
                <para>See also hasPendingConnections() and nextPendingConnection().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QTcpServer.MaxPendingConnections">
            <summary>
                <para>Returns the maximum number of pending accepted connections. The default is 30.</para>
                <para>Sets the maximum number of pending accepted connections to numConnections. QTcpServer will accept no more than numConnections incoming connections before nextPendingConnection() is called. By default, the limit is 30 pending connections.</para>
                <para>Clients may still able to connect after the server has reached its maximum number of pending connections (i.e., QTcpSocket can still emit the connected() signal). QTcpServer will stop accepting the new connections, but the operating system may still keep them in queue.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QTcpServer.Proxy">
            <summary>
                <para>Returns the network proxy for this socket. By default QNetworkProxy::DefaultProxy is used.</para>
                <para>This function was introduced in Qt 4.1.</para>
                <para>Sets the explicit network proxy for this socket to networkProxy.</para>
                <para>To disable the use of a proxy for this socket, use the QNetworkProxy::NoProxy proxy type:</para>
                <para> server-&gt;setProxy(QNetworkProxy::NoProxy);</para>
                <para>This function was introduced in Qt 4.1.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QTcpServer.ErrorString">
            <summary>
                <para>Returns a human readable description of the last error that occurred.</para>
                <para>See also serverError().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QTcpServer.HasPendingConnections">
            <summary>
                <para>Returns true if the server has a pending connection; otherwise returns false.</para>
                <para>See also nextPendingConnection() and setMaxPendingConnections().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QTcpServer.IsListening">
            <summary>
                <para>Returns true if the server is currently listening for incoming connections; otherwise returns false.</para>
                <para>See also listen().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QTcpServer.NextPendingConnection">
            <summary>
                <para>Returns the next pending connection as a connected QTcpSocket object.</para>
                <para>The socket is created as a child of the server, which means that it is automatically deleted when the QTcpServer object is destroyed. It is still a good idea to delete the object explicitly when you are done with it, to avoid wasting memory.</para>
                <para>0 is returned if this function is called when there are no pending connections.</para>
                <para>Note: The returned QTcpSocket object cannot be used from another thread. If you want to use an incoming connection from another thread, you need to override incomingConnection().</para>
                <para>See also hasPendingConnections().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QTcpServer.ServerAddress">
            <summary>
                <para>Returns the server's address if the server is listening for connections; otherwise returns QHostAddress::Null.</para>
                <para>See also serverPort() and listen().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QTcpServer.ServerError">
            <summary>
                <para>Returns an error code for the last error that occurred.</para>
                <para>See also errorString().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QTcpServer.ServerPort">
            <summary>
                <para>Returns the server's port if the server is listening for connections; otherwise returns 0.</para>
                <para>See also serverAddress() and listen().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QTcpServer.SocketDescriptor">
            <summary>
                <para>Returns the native socket descriptor the server uses to listen for incoming instructions, or -1 if the server is not listening.</para>
                <para>If the server is using QNetworkProxy, the returned descriptor may not be usable with native socket functions.</para>
                <para>See also setSocketDescriptor() and isListening().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QTcpServer.AddPendingConnection(QtNetwork.QTcpSocket)">
            <summary>
                <para>This function is called by QTcpServer::incomingConnection() to add the socket to the list of pending incoming connections.</para>
                <para>Note: Don't forget to call this member from reimplemented incomingConnection() if you do not want to break the Pending Connections mechanism.</para>
                <para>This function was introduced in Qt 4.7.</para>
                <para>See also incomingConnection().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QTcpServer.Close">
            <summary>
                <para>Closes the server. The server will no longer listen for incoming connections.</para>
                <para>See also listen().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QTcpServer.IncomingConnection(System.Int32)">
            <summary>
                <para>This virtual function is called by QTcpServer when a new connection is available. The socketDescriptor argument is the native socket descriptor for the accepted connection.</para>
                <para>The base implementation creates a QTcpSocket, sets the socket descriptor and then stores the QTcpSocket in an internal list of pending connections. Finally newConnection() is emitted.</para>
                <para>Reimplement this function to alter the server's behavior when a connection is available.</para>
                <para>If this server is using QNetworkProxy then the socketDescriptor may not be usable with native socket functions, and should only be used with QTcpSocket::setSocketDescriptor().</para>
                <para>Note: If you want to handle an incoming connection as a new QTcpSocket object in another thread you have to pass the socketDescriptor to the other thread and create the QTcpSocket object there and use its setSocketDescriptor() method.</para>
                <para>See also newConnection(), nextPendingConnection(), and addPendingConnection().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QTcpServer.Listen">
            <summary>
                <para>Tells the server to listen for incoming connections on address address and port port. If port is 0, a port is chosen automatically. If address is QHostAddress::Any, the server will listen on all network interfaces.</para>
                <para>Returns true on success; otherwise returns false.</para>
                <para>See also isListening().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QTcpServer.Listen(QtNetwork.QHostAddress,System.UInt16)">
            <summary>
                <para>Tells the server to listen for incoming connections on address address and port port. If port is 0, a port is chosen automatically. If address is QHostAddress::Any, the server will listen on all network interfaces.</para>
                <para>Returns true on success; otherwise returns false.</para>
                <para>See also isListening().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QTcpServer.OnNewConnection">
            <summary>
                <para>This signal is emitted every time a new connection is available.</para>
                <para>See also hasPendingConnections() and nextPendingConnection().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QTcpServer.SetSocketDescriptor(System.Int32)">
            <summary>
                <para>Sets the socket descriptor this server should use when listening for incoming connections to socketDescriptor. Returns true if the socket is set successfully; otherwise returns false.</para>
                <para>The socket is assumed to be in listening state.</para>
                <para>See also socketDescriptor() and isListening().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QTcpServer.WaitForNewConnection(System.Int32)">
            <summary>
                <para>Waits for at most msec milliseconds or until an incoming connection is available. Returns true if a connection is available; otherwise returns false. If the operation timed out and timedOut is not 0, *timedOut will be set to true.</para>
                <para>This is a blocking function call. Its use is disadvised in a single-threaded GUI application, since the whole application will stop responding until the function returns. waitForNewConnection() is mostly useful when there is no event loop available.</para>
                <para>The non-blocking alternative is to connect to the newConnection() signal.</para>
                <para>If msec is -1, this function will not time out.</para>
                <para>See also hasPendingConnections() and nextPendingConnection().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QTcpServer.WaitForNewConnection(System.Int32,System.Boolean@)">
            <summary>
                <para>Waits for at most msec milliseconds or until an incoming connection is available. Returns true if a connection is available; otherwise returns false. If the operation timed out and timedOut is not 0, *timedOut will be set to true.</para>
                <para>This is a blocking function call. Its use is disadvised in a single-threaded GUI application, since the whole application will stop responding until the function returns. waitForNewConnection() is mostly useful when there is no event loop available.</para>
                <para>The non-blocking alternative is to connect to the newConnection() signal.</para>
                <para>If msec is -1, this function will not time out.</para>
                <para>See also hasPendingConnections() and nextPendingConnection().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QTcpServer.Finalize">
            <summary>
                <para>Destroys the QTcpServer object. If the server is listening for connections, the socket is automatically closed.</para>
                <para>Any client QTcpSockets that are still connected must either disconnect or be reparented before the server is deleted.</para>
                <para>See also close().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QTcpSocket">
            <summary>
            The QTcpSocket class provides a TCP socket.
            </summary>
            <remarks>
                <para>
                </para>
                <para>TCP (Transmission Control Protocol) is a reliable, stream-oriented, connection-oriented transport protocol. It is especially well suited for continuous transmission of data.</para>
                <para>QTcpSocket is a convenience subclass of QAbstractSocket that allows you to establish a TCP connection and transfer streams of data. See the QAbstractSocket documentation for details.</para>
                <para>Note: TCP sockets cannot be opened in QIODevice::Unbuffered mode.</para>
                <para>
                </para>
                <para>Symbian Platform Security Requirements</para>
                <para>On Symbian, processes which use this class must have the NetworkServices platform security capability. If the client process lacks this capability, it will result in a panic.</para>
                <para>Platform security capabilities are added via the TARGET.CAPABILITY qmake variable.</para>
                <para>
                </para>
                <para>See also QTcpServer, QUdpSocket, QFtp, QNetworkAccessManager, Fortune Server Example, Fortune Client Example, Threaded Fortune Server Example, Blocking Fortune Client Example, Loopback Example, and Torrent Example.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QTcpSocket.#ctor(QtCore.QObject)">
            <summary>
                <para>Creates a QTcpSocket object in state UnconnectedState.</para>
                <para>parent is passed on to the QObject constructor.</para>
                <para>See also socketType().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QTcpSocket.Finalize">
            <summary>
                <para>Destroys the socket, closing the connection if necessary.</para>
                <para>See also close().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QUdpSocket">
            <summary>
            The QUdpSocket class provides a UDP socket.
            </summary>
            <remarks>
                <para>
                </para>
                <para>UDP (User Datagram Protocol) is a lightweight, unreliable, datagram-oriented, connectionless protocol. It can be used when reliability isn't important. QUdpSocket is a subclass of QAbstractSocket that allows you to send and receive UDP datagrams.</para>
                <para>The most common way to use this class is to bind to an address and port using bind(), then call writeDatagram() and readDatagram() to transfer data. If you want to use the standard QIODevice functions read(), readLine(), write(), etc., you must first connect the socket directly to a peer by calling connectToHost().</para>
                <para>The socket emits the bytesWritten() signal every time a datagram is written to the network. If you just want to send datagrams, you don't need to call bind().</para>
                <para>The readyRead() signal is emitted whenever datagrams arrive. In that case, hasPendingDatagrams() returns true. Call pendingDatagramSize() to obtain the size of the first pending datagram, and readDatagram() to read it.</para>
                <para>Note: An incoming datagram should be read when you receive the readyRead() signal, otherwise this signal will not be emitted for the next datagram.</para>
                <para>Example:</para>
                <para> void Server::initSocket()</para>
                <para> {</para>
                <para>     udpSocket = new QUdpSocket(this);</para>
                <para>     udpSocket-&gt;bind(QHostAddress::LocalHost, 7755);</para>
                <para>
                </para>
                <para>     connect(udpSocket, SIGNAL(readyRead()),</para>
                <para>             this, SLOT(readPendingDatagrams()));</para>
                <para> }</para>
                <para>
                </para>
                <para> void Server::readPendingDatagrams()</para>
                <para> {</para>
                <para>     while (udpSocket-&gt;hasPendingDatagrams()) {</para>
                <para>         QByteArray datagram;</para>
                <para>         datagram.resize(udpSocket-&gt;pendingDatagramSize());</para>
                <para>         QHostAddress sender;</para>
                <para>         quint16 senderPort;</para>
                <para>
                </para>
                <para>         udpSocket-&gt;readDatagram(datagram.data(), datagram.size(),</para>
                <para>                                 &amp;sender, &amp;senderPort);</para>
                <para>
                </para>
                <para>         processTheDatagram(datagram);</para>
                <para>     }</para>
                <para> }</para>
                <para>QUdpSocket also supports UDP multicast. Use joinMulticastGroup() and leaveMulticastGroup() to control group membership, and QAbstractSocket::MulticastTtlOption and QAbstractSocket::MulticastLoopbackOption to set the TTL and loopback socket options. Use setMulticastInterface() to control the outgoing interface for multicast datagrams, and multicastInterface() to query it.</para>
                <para>With QUdpSocket, you can also establish a virtual connection to a UDP server using connectToHost() and then use read() and write() to exchange datagrams without specifying the receiver for each datagram.</para>
                <para>The Broadcast Sender, Broadcast Receiver, Multicast Sender, and Multicast Receiver examples illustrate how to use QUdpSocket in applications.</para>
                <para>
                </para>
                <para>Symbian Platform Security Requirements</para>
                <para>On Symbian, processes which use this class must have the NetworkServices platform security capability. If the client process lacks this capability, operations will result in a panic.</para>
                <para>Platform security capabilities are added via the TARGET.CAPABILITY qmake variable.</para>
                <para>
                </para>
                <para>See also QTcpSocket.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QUdpSocket.#ctor(QtCore.QObject)">
            <summary>
                <para>Creates a QUdpSocket object.</para>
                <para>parent is passed to the QObject constructor.</para>
                <para>See also socketType().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QUdpSocket.BindFlag">
            <summary>
                <para>This enum describes the different flags you can pass to modify the behavior of QUdpSocket::bind().</para>
                <para>Note: On Symbian OS bind flags behaviour depends on process capabilties. If process has NetworkControl capability, the bind attempt with ReuseAddressHint will always succeed even if the address and port is already bound by another socket with any flags. If process does not have NetworkControl capability, the bind attempt to address and port already bound by another socket will always fail.</para>
                <para>This enum was introduced or modified in Qt 4.1.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QUdpSocket.BindFlag.DefaultForPlatform">
            <summary>
                <para>The default option for the current platform. On Unix and Mac OS X, this is equivalent to (DontShareAddress + ReuseAddressHint), and on Windows, its equivalent to ShareAddress.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QUdpSocket.BindFlag.DontShareAddress">
            <summary>
                <para>Bind the address and port exclusively, so that no other services are allowed to rebind. By passing this option to QUdpSocket::bind(), you are guaranteed that on successs, your service is the only one that listens to the address and port. No services are allowed to rebind, even if they pass ReuseAddressHint. This option provides more security than ShareAddress, but on certain operating systems, it requires you to run the server with administrator privileges. On Unix and Mac OS X, not sharing is the default behavior for binding an address and port, so this option is ignored. On Windows, this option uses the SO_EXCLUSIVEADDRUSE socket option.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QUdpSocket.BindFlag.ReuseAddressHint">
            <summary>
                <para>Provides a hint to QUdpSocket that it should try to rebind the service even if the address and port are already bound by another socket. On Windows, this is equivalent to the SO_REUSEADDR socket option. On Unix, this option is ignored.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QUdpSocket.BindFlag.ShareAddress">
            <summary>
                <para>Allow other services to bind to the same address and port. This is useful when multiple processes share the load of a single service by listening to the same address and port (e.g., a web server with several pre-forked listeners can greatly improve response time). However, because any service is allowed to rebind, this option is subject to certain security considerations. Note that by combining this option with ReuseAddressHint, you will also allow your service to rebind an existing shared address. On Unix, this is equivalent to the SO_REUSEADDR socket option. On Windows, this option is ignored.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QUdpSocket.MulticastInterface">
            <summary>
                <para>Returns the interface for the outgoing interface for multicast datagrams. This corresponds to the IP_MULTICAST_IF socket option for IPv4 sockets and the IPV6_MULTICAST_IF socket option for IPv6 sockets. If no interface has been previously set, this function returns an invalid QNetworkInterface. The socket must be in BoundState, otherwise an invalid QNetworkInterface is returned.</para>
                <para>This function was introduced in Qt 4.8.</para>
                <para>Sets the outgoing interface for multicast datagrams to the interface iface. This corresponds to the IP_MULTICAST_IF socket option for IPv4 sockets and the IPV6_MULTICAST_IF socket option for IPv6 sockets. The socket must be in BoundState, otherwise this function does nothing.</para>
                <para>This function was introduced in Qt 4.8.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QUdpSocket.HasPendingDatagrams">
            <summary>
                <para>Returns true if at least one datagram is waiting to be read; otherwise returns false.</para>
                <para>See also pendingDatagramSize() and readDatagram().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QUdpSocket.PendingDatagramSize">
            <summary>
                <para>Returns the size of the first pending UDP datagram. If there is no datagram available, this function returns -1.</para>
                <para>See also hasPendingDatagrams() and readDatagram().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QUdpSocket.Bind(QtNetwork.QHostAddress,System.UInt16)">
            <summary>
                <para>Binds this socket to the address address and the port port. When bound, the signal readyRead() is emitted whenever a UDP datagram arrives on the specified address and port. This function is useful to write UDP servers.</para>
                <para>On success, the functions returns true and the socket enters BoundState; otherwise it returns false.</para>
                <para>The socket is bound using the DefaultForPlatform BindMode.</para>
                <para>See also readDatagram().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QUdpSocket.Bind(QtNetwork.QHostAddress,System.UInt16,QtNetwork.QUdpSocket.BindFlag)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Binds to address on port port, using the BindMode mode.</para>
                <para>This function was introduced in Qt 4.1.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QUdpSocket.Bind(System.UInt16)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Binds to QHostAddress:Any on port port.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QUdpSocket.Bind(System.UInt16,QtNetwork.QUdpSocket.BindFlag)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Binds to QHostAddress:Any on port port, using the BindMode mode.</para>
                <para>This function was introduced in Qt 4.1.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QUdpSocket.JoinMulticastGroup(QtNetwork.QHostAddress)">
            <summary>
                <para>Joins the the multicast group specified by groupAddress on the default interface chosen by the operating system. The socket must be in BoundState, otherwise an error occurs.</para>
                <para>This function returns true if successful; otherwise it returns false and sets the socket error accordingly.</para>
                <para>This function was introduced in Qt 4.8.</para>
                <para>See also leaveMulticastGroup().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QUdpSocket.JoinMulticastGroup(QtNetwork.QHostAddress,QtNetwork.QNetworkInterface)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Joins the multicast group address groupAddress on the interface iface.</para>
                <para>This function was introduced in Qt 4.8.</para>
                <para>See also leaveMulticastGroup().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QUdpSocket.LeaveMulticastGroup(QtNetwork.QHostAddress)">
            <summary>
                <para>Leaves the multicast group specified by groupAddress on the default interface chosen by the operating system. The socket must be in BoundState, otherwise an error occurs.</para>
                <para>This function returns true if successful; otherwise it returns false and sets the socket error accordingly.</para>
                <para>This function was introduced in Qt 4.8.</para>
                <para>See also joinMulticastGroup().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QUdpSocket.LeaveMulticastGroup(QtNetwork.QHostAddress,QtNetwork.QNetworkInterface)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Leaves the multicast group specified by groupAddress on the interface iface.</para>
                <para>This function was introduced in Qt 4.8.</para>
                <para>See also joinMulticastGroup().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QUdpSocket.ReadDatagram(QtCore.Pointer{System.SByte},System.Int64,QtNetwork.QHostAddress)">
            <summary>
                <para>Receives a datagram no larger than maxSize bytes and stores it in data. The sender's host address and port is stored in *address and *port (unless the pointers are 0).</para>
                <para>Returns the size of the datagram on success; otherwise returns -1.</para>
                <para>If maxSize is too small, the rest of the datagram will be lost. To avoid loss of data, call pendingDatagramSize() to determine the size of the pending datagram before attempting to read it. If maxSize is 0, the datagram will be discarded.</para>
                <para>See also writeDatagram(), hasPendingDatagrams(), and pendingDatagramSize().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QUdpSocket.ReadDatagram(QtCore.Pointer{System.SByte},System.Int64,QtNetwork.QHostAddress,System.UInt16@)">
            <summary>
                <para>Receives a datagram no larger than maxSize bytes and stores it in data. The sender's host address and port is stored in *address and *port (unless the pointers are 0).</para>
                <para>Returns the size of the datagram on success; otherwise returns -1.</para>
                <para>If maxSize is too small, the rest of the datagram will be lost. To avoid loss of data, call pendingDatagramSize() to determine the size of the pending datagram before attempting to read it. If maxSize is 0, the datagram will be discarded.</para>
                <para>See also writeDatagram(), hasPendingDatagrams(), and pendingDatagramSize().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QUdpSocket.WriteDatagram(QtCore.QByteArray,QtNetwork.QHostAddress,System.UInt16)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sends the datagram datagram to the host address host and at port port.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QUdpSocket.WriteDatagram(System.String,System.Int64,QtNetwork.QHostAddress,System.UInt16)">
            <summary>
                <para>Sends the datagram at data of size size to the host address address at port port. Returns the number of bytes sent on success; otherwise returns -1.</para>
                <para>Datagrams are always written as one block. The maximum size of a datagram is highly platform-dependent, but can be as low as 8192 bytes. If the datagram is too large, this function will return -1 and error() will return DatagramTooLargeError.</para>
                <para>Sending datagrams larger than 512 bytes is in general disadvised, as even if they are sent successfully, they are likely to be fragmented by the IP layer before arriving at their final destination.</para>
                <para>Warning: In S60 5.0 and earlier versions, the writeDatagram return value is not reliable for large datagrams.</para>
                <para>Warning: Calling this function on a connected UDP socket may result in an error and no packet being sent. If you are using a connected socket, use write() to send datagrams.</para>
                <para>See also readDatagram() and write().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QUdpSocket.Finalize">
            <summary>
                <para>Destroys the socket, closing the connection if necessary.</para>
                <para>See also close().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QUrlInfo">
            <summary>
            The QUrlInfo class stores information about URLs.
            </summary>
            <remarks>
                <para>
                </para>
                <para>The information about a URL that can be retrieved includes name(), permissions(), owner(), group(), size(), lastModified(), lastRead(), isDir(), isFile(), isSymLink(), isWritable(), isReadable() and isExecutable().</para>
                <para>You can create your own QUrlInfo objects passing in all the relevant information in the constructor, and you can modify a QUrlInfo; for each getter mentioned above there is an equivalent setter. Note that setting values does not affect the underlying resource that the QUrlInfo provides information about; for example if you call setWritable(true) on a read-only resource the only thing changed is the QUrlInfo object, not the resource.</para>
                <para>
                </para>
                <para>See also QUrl and FTP Example.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QUrlInfo.#ctor">
            <summary>
                <para>Constructs an invalid QUrlInfo object with default values.</para>
                <para>See also isValid().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QUrlInfo.#ctor(QtNetwork.QUrlInfo)">
            <summary>
                <para>Copy constructor, copies ui to this URL info object.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QUrlInfo.#ctor(QtCore.QUrl,System.Int32,System.String,System.String,System.Int64,QtCore.QDateTime,QtCore.QDateTime,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
                <para>Constructs a QUrlInfo object by specifying all the URL's information.</para>
                <para>The information that is passed is the url, file permissions, owner and group and the file's size. Also passed is the lastModified date/time and the lastRead date/time. Flags are also passed, specifically, isDir, isFile, isSymLink, isWritable, isReadable and isExecutable.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QUrlInfo.#ctor(System.String,System.Int32,System.String,System.String,System.Int64,QtCore.QDateTime,QtCore.QDateTime,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
                <para>Constructs a QUrlInfo object by specifying all the URL's information.</para>
                <para>The information that is passed is the name, file permissions, owner and group and the file's size. Also passed is the lastModified date/time and the lastRead date/time. Flags are also passed, specifically, isDir, isFile, isSymLink, isWritable, isReadable and isExecutable.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QUrlInfo.PermissionSpec">
            <summary>
                <para>This enum is used by the permissions() function to report the permissions of a file.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QUrlInfo.PermissionSpec.ExeGroup">
            <summary>
                <para>The file is executable by the group.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QUrlInfo.PermissionSpec.ExeOther">
            <summary>
                <para>The file is executable by anyone.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QUrlInfo.PermissionSpec.ExeOwner">
            <summary>
                <para>The file is executable by the owner of the file.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QUrlInfo.PermissionSpec.ReadGroup">
            <summary>
                <para>The file is readable by the group.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QUrlInfo.PermissionSpec.ReadOther">
            <summary>
                <para>The file is readable by anyone.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QUrlInfo.PermissionSpec.ReadOwner">
            <summary>
                <para>The file is readable by the owner of the file.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QUrlInfo.PermissionSpec.WriteGroup">
            <summary>
                <para>The file is writable by the group.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QUrlInfo.PermissionSpec.WriteOther">
            <summary>
                <para>The file is writable by anyone.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QUrlInfo.PermissionSpec.WriteOwner">
            <summary>
                <para>The file is writable by the owner of the file.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QUrlInfo.Group">
            <summary>
                <para>Returns the group of the URL.</para>
                <para>Specifies that the owning group of the URL is called s.</para>
                <para>If you call this function for an invalid URL info, this function turns it into a valid one.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QUrlInfo.LastModified">
            <summary>
                <para>Returns the last modification date of the URL.</para>
                <para>Specifies that the object the URL refers to was last modified at dt.</para>
                <para>If you call this function for an invalid URL info, this function turns it into a valid one.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QUrlInfo.LastRead">
            <summary>
                <para>Returns the date when the URL was last read.</para>
                <para>Specifies that the object the URL refers to was last read at dt.</para>
                <para>If you call this function for an invalid URL info, this function turns it into a valid one.</para>
                <para>This function was introduced in Qt 4.4.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QUrlInfo.Name">
            <summary>
                <para>Returns the file name of the URL.</para>
                <para>Sets the name of the URL to name. The name is the full text, for example, "http://qt.nokia.com/doc/qurlinfo.html".</para>
                <para>If you call this function for an invalid URL info, this function turns it into a valid one.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QUrlInfo.Owner">
            <summary>
                <para>Returns the owner of the URL.</para>
                <para>Specifies that the owner of the URL is called s.</para>
                <para>If you call this function for an invalid URL info, this function turns it into a valid one.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QUrlInfo.Permissions">
            <summary>
                <para>Returns the permissions of the URL. You can use the PermissionSpec flags to test for certain permissions.</para>
                <para>Specifies that the URL has access permissions p.</para>
                <para>If you call this function for an invalid URL info, this function turns it into a valid one.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QUrlInfo.Size">
            <summary>
                <para>Returns the size of the URL.</para>
                <para>Specifies the size of the URL.</para>
                <para>If you call this function for an invalid URL info, this function turns it into a valid one.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QUrlInfo.IsDir">
            <summary>
                <para>Returns true if the URL is a directory; otherwise returns false.</para>
                <para>See also isValid().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QUrlInfo.IsExecutable">
            <summary>
                <para>Returns true if the URL is executable; otherwise returns false.</para>
                <para>See also isValid().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QUrlInfo.IsFile">
            <summary>
                <para>Returns true if the URL is a file; otherwise returns false.</para>
                <para>See also isValid().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QUrlInfo.IsReadable">
            <summary>
                <para>Returns true if the URL is readable; otherwise returns false.</para>
                <para>See also isValid().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QUrlInfo.IsSymLink">
            <summary>
                <para>Returns true if the URL is a symbolic link; otherwise returns false.</para>
                <para>See also isValid().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QUrlInfo.IsValid">
            <summary>
                <para>Returns true if the URL info is valid; otherwise returns false. Valid means that the QUrlInfo contains real information.</para>
                <para>You should always check if the URL info is valid before relying on the values.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QUrlInfo.IsWritable">
            <summary>
                <para>Returns true if the URL is writable; otherwise returns false.</para>
                <para>See also isValid().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QUrlInfo.Equal(QtNetwork.QUrlInfo,QtNetwork.QUrlInfo,System.Int32)">
            <summary>
                <para>Returns true if i1 equals to i2; otherwise returns false. The objects are compared by the value, which is specified by sortBy. This must be one of QDir::Name, QDir::Time or QDir::Size.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QUrlInfo.GreaterThan(QtNetwork.QUrlInfo,QtNetwork.QUrlInfo,System.Int32)">
            <summary>
                <para>Returns true if i1 is greater than i2; otherwise returns false. The objects are compared by the value, which is specified by sortBy. This must be one of QDir::Name, QDir::Time or QDir::Size.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QUrlInfo.LessThan(QtNetwork.QUrlInfo,QtNetwork.QUrlInfo,System.Int32)">
            <summary>
                <para>Returns true if i1 is less than i2; otherwise returns false. The objects are compared by the value, which is specified by sortBy. This must be one of QDir::Name, QDir::Time or QDir::Size.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QUrlInfo.SetDir(System.Boolean)">
            <summary>
                <para>If b is true then the URL is set to be a directory; if b is false then the URL is set not to be a directory (which normally means it is a file). (Note that a URL can refer to both a file and a directory even though most file systems do not support this.)</para>
                <para>If you call this function for an invalid URL info, this function turns it into a valid one.</para>
                <para>See also isDir() and isValid().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QUrlInfo.SetFile(System.Boolean)">
            <summary>
                <para>If b is true then the URL is set to be a file; if \\b is false then the URL is set not to be a file (which normally means it is a directory). (Note that a URL can refer to both a file and a directory even though most file systems do not support this.)</para>
                <para>If you call this function for an invalid URL info, this function turns it into a valid one.</para>
                <para>See also isFile() and isValid().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QUrlInfo.SetReadable(System.Boolean)">
            <summary>
                <para>Specifies that the URL is readable if b is true and not readable if b is false.</para>
                <para>If you call this function for an invalid URL info, this function turns it into a valid one.</para>
                <para>See also isReadable() and isValid().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QUrlInfo.SetSymLink(System.Boolean)">
            <summary>
                <para>Specifies that the URL refers to a symbolic link if b is true and that it does not if b is false.</para>
                <para>If you call this function for an invalid URL info, this function turns it into a valid one.</para>
                <para>See also isSymLink() and isValid().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QUrlInfo.SetWritable(System.Boolean)">
            <summary>
                <para>Specifies that the URL is writable if b is true and not writable if b is false.</para>
                <para>If you call this function for an invalid URL info, this function turns it into a valid one.</para>
                <para>See also isWritable() and isValid().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QUrlInfo.Finalize">
            <summary>
                <para>Destroys the URL info object.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QUrlInfo.op_Inequality(QtNetwork.QUrlInfo,QtNetwork.QUrlInfo)">
            <summary>
                <para>Returns true if this QUrlInfo is not equal to other; otherwise returns false.</para>
                <para>This function was introduced in Qt 4.2.</para>
                <para>See also lessThan() and equal().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QUrlInfo.op_Equality(QtNetwork.QUrlInfo,QtNetwork.QUrlInfo)">
            <summary>
                <para>Returns true if this QUrlInfo is equal to other; otherwise returns false.</para>
                <para>See also lessThan() and equal().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QtMsgType">
            <summary>
                <para>This enum describes the messages that can be sent to a message handler (QtMsgHandler). You can use the enum to identify and associate the various message types with the appropriate actions.</para>
                <para>See also QtMsgHandler and qInstallMsgHandler().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QtMsgType.QtCriticalMsg">
            <summary>
                <para>A message generated by the qCritical() function.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QtMsgType.QtDebugMsg">
            <summary>
                <para>A message generated by the qDebug() function.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QtMsgType.QtFatalMsg">
            <summary>
                <para>A message generated by the qFatal() function.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QtMsgType.QtWarningMsg">
            <summary>
                <para>A message generated by the qWarning() function.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQAbstractSocketSignals.HostFound">
            <summary>
                <para>This signal is emitted after connectToHost() has been called and the host lookup has succeeded.</para>
                <para>Note: Since Qt 4.6.3 QAbstractSocket may emit hostFound() directly from the connectToHost() call since a DNS result could have been cached.</para>
                <para>See also connected().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQAbstractSocketSignals.Connected">
            <summary>
                <para>This signal is emitted after connectToHost() has been called and a connection has been successfully established.</para>
                <para>Note: On some operating systems the connected() signal may be directly emitted from the connectToHost() call for connections to the localhost.</para>
                <para>See also connectToHost() and disconnected().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQAbstractSocketSignals.Disconnected">
            <summary>
                <para>This signal is emitted when the socket has been disconnected.</para>
                <para>Warning: If you need to delete the sender() of this signal in a slot connected to it, use the deleteLater() function.</para>
                <para>See also connectToHost(), disconnectFromHost(), and abort().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQAbstractSocketSignals.StateChanged(QtNetwork.QAbstractSocket.SocketState)">
            <summary>
                <para>This signal is emitted whenever QAbstractSocket's state changes. The socketState parameter is the new state.</para>
                <para>QAbstractSocket::SocketState is not a registered metatype, so for queued connections, you will have to register it with Q_REGISTER_METATYPE() and qRegisterMetaType().</para>
                <para>See also state() and Creating Custom Qt Types.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQAbstractSocketSignals.Error(QtNetwork.QAbstractSocket.SocketError)">
            <summary>
                <para>This signal is emitted after an error occurred. The socketError parameter describes the type of error that occurred.</para>
                <para>QAbstractSocket::SocketError is not a registered metatype, so for queued connections, you will have to register it with Q_DECLARE_METATYPE() and qRegisterMetaType().</para>
                <para>See also error(), errorString(), and Creating Custom Qt Types.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQAbstractSocketSignals.ProxyAuthenticationRequired(QtNetwork.QNetworkProxy,QtNetwork.QAuthenticator)">
            <summary>
                <para>This signal can be emitted when a proxy that requires authentication is used. The authenticator object can then be filled in with the required details to allow authentication and continue the connection.</para>
                <para>Note: It is not possible to use a QueuedConnection to connect to this signal, as the connection will fail if the authenticator has not been filled in with new information when the signal returns.</para>
                <para>This function was introduced in Qt 4.3.</para>
                <para>See also QAuthenticator and QNetworkProxy.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQFtpSignals.StateChanged(System.Int32)">
            <summary>
                <para>This signal is emitted when the state of the connection changes. The argument state is the new state of the connection; it is one of the State values.</para>
                <para>It is usually emitted in response to a connectToHost() or close() command, but it can also be emitted "spontaneously", e.g. when the server closes the connection unexpectedly.</para>
                <para>See also connectToHost(), close(), state(), and State.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQFtpSignals.ListInfo(QtNetwork.QUrlInfo)">
            <summary>
                <para>This signal is emitted for each directory entry the list() command finds. The details of the entry are stored in i.</para>
                <para>See also list().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQFtpSignals.ReadyRead">
            <summary>
                <para>This signal is emitted in response to a get() command when there is new data to read.</para>
                <para>If you specify a device as the second argument in the get() command, this signal is not emitted; instead the data is written directly to the device.</para>
                <para>You can read the data with the readAll() or read() functions.</para>
                <para>This signal is useful if you want to process the data in chunks as soon as it becomes available. If you are only interested in the complete data, just connect to the commandFinished() signal and read the data then instead.</para>
                <para>See also get(), read(), readAll(), and bytesAvailable().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQFtpSignals.DataTransferProgress(System.Int64,System.Int64)">
            <summary>
                <para>This signal is emitted in response to a get() or put() request to indicate the current progress of the download or upload.</para>
                <para>done is the amount of data that has already been transferred and total is the total amount of data to be read or written. It is possible that the QFtp class is not able to determine the total amount of data that should be transferred, in which case total is 0. (If you connect this signal to a QProgressBar, the progress bar shows a busy indicator if the total is 0).</para>
                <para>Warning: done and total are not necessarily the size in bytes, since for large files these values might need to be "scaled" to avoid overflow.</para>
                <para>See also get(), put(), and QProgressBar.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQFtpSignals.RawCommandReply(System.Int32,System.String)">
            <summary>
                <para>This signal is emitted in response to the rawCommand() function. replyCode is the 3 digit reply code and detail is the text that follows the reply code.</para>
                <para>See also rawCommand().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQFtpSignals.CommandStarted(System.Int32)">
            <summary>
                <para>This signal is emitted when processing the command identified by id starts.</para>
                <para>See also commandFinished() and done().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQFtpSignals.CommandFinished(System.Int32,System.Boolean)">
            <summary>
                <para>This signal is emitted when processing the command identified by id has finished. error is true if an error occurred during the processing; otherwise error is false.</para>
                <para>See also commandStarted(), done(), error(), and errorString().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQFtpSignals.Done(System.Boolean)">
            <summary>
                <para>This signal is emitted when the last pending command has finished; (it is emitted after the last command's commandFinished() signal). error is true if an error occurred during the processing; otherwise error is false.</para>
                <para>See also commandFinished(), error(), and errorString().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQHttpSignals.StateChanged(System.Int32)">
            <summary>
                <para>This signal is emitted when the state of the QHttp object changes. The argument state is the new state of the connection; it is one of the State values.</para>
                <para>This usually happens when a request is started, but it can also happen when the server closes the connection or when a call to close() succeeded.</para>
                <para>See also get(), post(), head(), request(), close(), state(), and State.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQHttpSignals.ResponseHeaderReceived(QtNetwork.QHttpResponseHeader)">
            <summary>
                <para>This signal is emitted when the HTTP header of a server response is available. The header is passed in resp.</para>
                <para>See also get(), post(), head(), request(), and readyRead().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQHttpSignals.ReadyRead(QtNetwork.QHttpResponseHeader)">
            <summary>
                <para>This signal is emitted when there is new response data to read.</para>
                <para>If you specified a device in the request where the data should be written to, then this signal is not emitted; instead the data is written directly to the device.</para>
                <para>The response header is passed in resp.</para>
                <para>You can read the data with the readAll() or read() functions</para>
                <para>This signal is useful if you want to process the data in chunks as soon as it becomes available. If you are only interested in the complete data, just connect to the requestFinished() signal and read the data then instead.</para>
                <para>See also get(), post(), request(), readAll(), read(), and bytesAvailable().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQHttpSignals.DataSendProgress(System.Int32,System.Int32)">
            <summary>
                <para>This signal is emitted when this object sends data to a HTTP server to inform it about the progress of the upload.</para>
                <para>done is the amount of data that has already arrived and total is the total amount of data. It is possible that the total amount of data that should be transferred cannot be determined, in which case total is 0.(If you connect to a QProgressBar, the progress bar shows a busy indicator if the total is 0).</para>
                <para>Warning: done and total are not necessarily the size in bytes, since for large files these values might need to be "scaled" to avoid overflow.</para>
                <para>See also dataReadProgress(), post(), request(), and QProgressBar.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQHttpSignals.DataReadProgress(System.Int32,System.Int32)">
            <summary>
                <para>This signal is emitted when this object reads data from a HTTP server to indicate the current progress of the download.</para>
                <para>done is the amount of data that has already arrived and total is the total amount of data. It is possible that the total amount of data that should be transferred cannot be determined, in which case total is 0.(If you connect to a QProgressBar, the progress bar shows a busy indicator if the total is 0).</para>
                <para>Warning: done and total are not necessarily the size in bytes, since for large files these values might need to be "scaled" to avoid overflow.</para>
                <para>See also dataSendProgress(), get(), post(), request(), and QProgressBar.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQHttpSignals.RequestStarted(System.Int32)">
            <summary>
                <para>This signal is emitted when processing the request identified by id starts.</para>
                <para>See also requestFinished() and done().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQHttpSignals.RequestFinished(System.Int32,System.Boolean)">
            <summary>
                <para>This signal is emitted when processing the request identified by id has finished. error is true if an error occurred during the processing; otherwise error is false.</para>
                <para>See also requestStarted(), done(), error(), and errorString().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQHttpSignals.Done(System.Boolean)">
            <summary>
                <para>This signal is emitted when the last pending request has finished; (it is emitted after the last request's requestFinished() signal). error is true if an error occurred during the processing; otherwise error is false.</para>
                <para>See also requestFinished(), error(), and errorString().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQHttpSignals.ProxyAuthenticationRequired(QtNetwork.QNetworkProxy,QtNetwork.QAuthenticator)">
            <summary>
                <para>This signal can be emitted when a proxy that requires authentication is used. The authenticator object can then be filled in with the required details to allow authentication and continue the connection.</para>
                <para>Note: It is not possible to use a QueuedConnection to connect to this signal, as the connection will fail if the authenticator has not been filled in with new information when the signal returns.</para>
                <para>This function was introduced in Qt 4.3.</para>
                <para>See also QAuthenticator and QNetworkProxy.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQHttpSignals.AuthenticationRequired(System.String,System.UInt16,QtNetwork.QAuthenticator)">
            <summary>
                <para>This signal can be emitted when a web server on a given hostname and port requires authentication. The authenticator object can then be filled in with the required details to allow authentication and continue the connection.</para>
                <para>Note: It is not possible to use a QueuedConnection to connect to this signal, as the connection will fail if the authenticator has not been filled in with new information when the signal returns.</para>
                <para>This function was introduced in Qt 4.3.</para>
                <para>See also QAuthenticator and QNetworkProxy.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQHttpSignals.SslErrors(System.Collections.Generic.List{QtNetwork.QSslError})">
            <summary>
                <para>Forwards the sslErrors signal from the QSslSocket used in QHttp. errors is the list of errors that occurred during the SSL handshake. Unless you call ignoreSslErrors() from within a slot connected to this signal when an error occurs, QHttp will tear down the connection immediately after emitting the signal.</para>
                <para>This function was introduced in Qt 4.3.</para>
                <para>See also QSslSocket and QSslSocket::ignoreSslErrors().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQLocalServerSignals.NewConnection">
            <summary>
                <para>This signal is emitted every time a new connection is available.</para>
                <para>See also hasPendingConnections() and nextPendingConnection().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQLocalSocketSignals.Connected">
            <summary>
                <para>This signal is emitted after connectToServer() has been called and a connection has been successfully established.</para>
                <para>See also connectToServer() and disconnected().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQLocalSocketSignals.Disconnected">
            <summary>
                <para>This signal is emitted when the socket has been disconnected.</para>
                <para>See also connectToServer(), disconnectFromServer(), abort(), and connected().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQLocalSocketSignals.Error(QtNetwork.QLocalSocket.LocalSocketError)">
            <summary>
                <para>This signal is emitted after an error occurred. The socketError parameter describes the type of error that occurred.</para>
                <para>QLocalSocket::LocalSocketError is not a registered metatype, so for queued connections, you will have to register it with Q_DECLARE_METATYPE() and qRegisterMetaType().</para>
                <para>See also error(), errorString(), and Creating Custom Qt Types.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQLocalSocketSignals.StateChanged(QtNetwork.QLocalSocket.LocalSocketState)">
            <summary>
                <para>This signal is emitted whenever QLocalSocket's state changes. The socketState parameter is the new state.</para>
                <para>QLocalSocket::SocketState is not a registered metatype, so for queued connections, you will have to register it with Q_DECLARE_METATYPE() and qRegisterMetaType().</para>
                <para>See also state() and Creating Custom Qt Types.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQNetworkAccessManagerSignals.ProxyAuthenticationRequired(QtNetwork.QNetworkProxy,QtNetwork.QAuthenticator)">
            <summary>
                <para>This signal is emitted whenever a proxy requests authentication and QNetworkAccessManager cannot find a valid, cached credential. The slot connected to this signal should fill in the credentials for the proxy proxy in the authenticator object.</para>
                <para>QNetworkAccessManager will cache the credentials internally. The next time the proxy requests authentication, QNetworkAccessManager will automatically send the same credential without emitting the proxyAuthenticationRequired signal again.</para>
                <para>If the proxy rejects the credentials, QNetworkAccessManager will emit the signal again.</para>
                <para>See also proxy(), setProxy(), and authenticationRequired().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQNetworkAccessManagerSignals.AuthenticationRequired(QtNetwork.QNetworkReply,QtNetwork.QAuthenticator)">
            <summary>
                <para>This signal is emitted whenever a final server requests authentication before it delivers the requested contents. The slot connected to this signal should fill the credentials for the contents (which can be determined by inspecting the reply object) in the authenticator object.</para>
                <para>QNetworkAccessManager will cache the credentials internally and will send the same values if the server requires authentication again, without emitting the authenticationRequired() signal. If it rejects the credentials, this signal will be emitted again.</para>
                <para>Note: It is not possible to use a QueuedConnection to connect to this signal, as the connection will fail if the authenticator has not been filled in with new information when the signal returns.</para>
                <para>See also proxyAuthenticationRequired().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQNetworkAccessManagerSignals.Finished(QtNetwork.QNetworkReply)">
            <summary>
                <para>This signal is emitted whenever a pending network reply is finished. The reply parameter will contain a pointer to the reply that has just finished. This signal is emitted in tandem with the QNetworkReply::finished() signal.</para>
                <para>See QNetworkReply::finished() for information on the status that the object will be in.</para>
                <para>Note: Do not delete the reply object in the slot connected to this signal. Use deleteLater().</para>
                <para>See also QNetworkReply::finished() and QNetworkReply::error().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQNetworkAccessManagerSignals.SslErrors(QtNetwork.QNetworkReply,System.Collections.Generic.List{QtNetwork.QSslError})">
            <summary>
                <para>This signal is emitted if the SSL/TLS session encountered errors during the set up, including certificate verification errors. The errors parameter contains the list of errors and reply is the QNetworkReply that is encountering these errors.</para>
                <para>To indicate that the errors are not fatal and that the connection should proceed, the QNetworkReply::ignoreSslErrors() function should be called from the slot connected to this signal. If it is not called, the SSL session will be torn down before any data is exchanged (including the URL).</para>
                <para>This signal can be used to display an error message to the user indicating that security may be compromised and display the SSL settings (see sslConfiguration() to obtain it). If the user decides to proceed after analyzing the remote certificate, the slot should call ignoreSslErrors().</para>
                <para>See also QSslSocket::sslErrors(), QNetworkReply::sslErrors(), QNetworkReply::sslConfiguration(), and QNetworkReply::ignoreSslErrors().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQNetworkAccessManagerSignals.NetworkAccessibleChanged(QtNetwork.QNetworkAccessManager.NetworkAccessibility)">
            <summary>
                <para>This signal is emitted when the value of the networkAccessible property changes. accessible is the new network accessibility.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQNetworkConfigurationManagerSignals.ConfigurationAdded(QtNetwork.QNetworkConfiguration)">
            <summary>
                <para>This signal is emitted whenever a new network configuration is added to the system. The new configuration is specified by config.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQNetworkConfigurationManagerSignals.ConfigurationRemoved(QtNetwork.QNetworkConfiguration)">
            <summary>
                <para>This signal is emitted when a configuration is about to be removed from the system. The removed configuration, specified by config, is invalid but retains name and identifier.</para>
                <para>This function was introduced in Qt 4.8.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQNetworkConfigurationManagerSignals.ConfigurationChanged(QtNetwork.QNetworkConfiguration)">
            <summary>
                <para>This signal is emitted when the state of config changes.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQNetworkConfigurationManagerSignals.OnlineStateChanged(System.Boolean)">
            <summary>
                <para>This signal is emitted when the device changes from online to offline mode or vice versa. isOnline represents the new state of the device.</para>
                <para>The state is considered to be online for as long as allConfigurations(QNetworkConfiguration::Active) returns a list with at least one entry.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQNetworkConfigurationManagerSignals.UpdateCompleted">
            <summary>
                <para>This signal is emitted when the configuration update has been completed. Such an update can be initiated via updateConfigurations().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQNetworkReplySignals.MetaDataChanged">
            <summary>
                <para>This signal is emitted whenever the metadata in this reply changes. metadata is any information that is not the content (data) itself, including the network headers. In the majority of cases, the metadata will be known fully by the time the first byte of data is received. However, it is possible to receive updates of headers or other metadata during the processing of the data.</para>
                <para>See also header(), rawHeaderList(), rawHeader(), and hasRawHeader().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQNetworkReplySignals.Finished">
            <summary>
                <para>This signal is emitted when the reply has finished processing. After this signal is emitted, there will be no more updates to the reply's data or metadata.</para>
                <para>Unless close() has been called, the reply will be still be opened for reading, so the data can be retrieved by calls to read() or readAll(). In particular, if no calls to read() were made as a result of readyRead(), a call to readAll() will retrieve the full contents in a QByteArray.</para>
                <para>This signal is emitted in tandem with QNetworkAccessManager::finished() where that signal's reply parameter is this object.</para>
                <para>Note: Do not delete the object in the slot connected to this signal. Use deleteLater().</para>
                <para>You can also use isFinished() to check if a QNetworkReply has finished even before you receive the finished() signal.</para>
                <para>See also setFinished(), QNetworkAccessManager::finished(), and isFinished().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQNetworkReplySignals.Error(QtNetwork.QNetworkReply.NetworkError)">
            <summary>
                <para>This signal is emitted when the reply detects an error in processing. The finished() signal will probably follow, indicating that the connection is over.</para>
                <para>The code parameter contains the code of the error that was detected. Call errorString() to obtain a textual representation of the error condition.</para>
                <para>Note: Do not delete the object in the slot connected to this signal. Use deleteLater().</para>
                <para>See also error() and errorString().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQNetworkReplySignals.SslErrors(System.Collections.Generic.List{QtNetwork.QSslError})">
            <summary>
                <para>This signal is emitted if the SSL/TLS session encountered errors during the set up, including certificate verification errors. The errors parameter contains the list of errors.</para>
                <para>To indicate that the errors are not fatal and that the connection should proceed, the ignoreSslErrors() function should be called from the slot connected to this signal. If it is not called, the SSL session will be torn down before any data is exchanged (including the URL).</para>
                <para>This signal can be used to display an error message to the user indicating that security may be compromised and display the SSL settings (see sslConfiguration() to obtain it). If the user decides to proceed after analyzing the remote certificate, the slot should call ignoreSslErrors().</para>
                <para>See also QSslSocket::sslErrors(), QNetworkAccessManager::sslErrors(), sslConfiguration(), and ignoreSslErrors().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQNetworkReplySignals.UploadProgress(System.Int64,System.Int64)">
            <summary>
                <para>This signal is emitted to indicate the progress of the upload part of this network request, if there's any. If there's no upload associated with this request, this signal will not be emitted.</para>
                <para>The bytesSent parameter indicates the number of bytes uploaded, while bytesTotal indicates the total number of bytes to be uploaded. If the number of bytes to be uploaded could not be determined, bytesTotal will be -1.</para>
                <para>The upload is finished when bytesSent is equal to bytesTotal. At that time, bytesTotal will not be -1.</para>
                <para>See also downloadProgress().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQNetworkReplySignals.DownloadProgress(System.Int64,System.Int64)">
            <summary>
                <para>This signal is emitted to indicate the progress of the download part of this network request, if there's any. If there's no download associated with this request, this signal will be emitted once with 0 as the value of both bytesReceived and bytesTotal.</para>
                <para>The bytesReceived parameter indicates the number of bytes received, while bytesTotal indicates the total number of bytes expected to be downloaded. If the number of bytes to be downloaded is not known, bytesTotal will be -1.</para>
                <para>The download is finished when bytesReceived is equal to bytesTotal. At that time, bytesTotal will not be -1.</para>
                <para>Note that the values of both bytesReceived and bytesTotal may be different from size(), the total number of bytes obtained through read() or readAll(), or the value of the header(ContentLengthHeader). The reason for that is that there may be protocol overhead or the data may be compressed during the download.</para>
                <para>See also uploadProgress() and bytesAvailable().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQNetworkSessionSignals.StateChanged(QtNetwork.QNetworkSession.State)">
            <summary>
                <para>This signal is emitted whenever the state of the network session changes. The state parameter is the new state.</para>
                <para>See also state().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQNetworkSessionSignals.Opened">
            <summary>
                <para>This signal is emitted when the network session has been opened.</para>
                <para>The underlying network interface will not be shut down as long as the session remains open. Note that this feature is dependent on system wide session support.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQNetworkSessionSignals.Closed">
            <summary>
                <para>This signal is emitted when the network session has been closed.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQNetworkSessionSignals.Error(QtNetwork.QNetworkSession.SessionError)">
            <summary>
                <para>This signal is emitted after an error occurred. The error parameter describes the error that occurred.</para>
                <para>See also error() and errorString().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQNetworkSessionSignals.PreferredConfigurationChanged(QtNetwork.QNetworkConfiguration,System.Boolean)">
            <summary>
                <para>This signal is emitted when the preferred configuration/access point for the session changes. Only sessions which are based on service network configurations may emit this signal. config can be used to determine access point specific details such as proxy settings and isSeamless indicates whether roaming will break the sessions IP address.</para>
                <para>As a consequence to this signal the application must either start the roaming process by calling migrate() or choose to ignore() the new access point.</para>
                <para>If the roaming process is non-seamless the IP address will change which means that a socket becomes invalid. However seamless mobility can ensure that the local IP address does not change. This is achieved by using a virtual IP address which is bound to the actual link address. During the roaming process the virtual address is attached to the new link address.</para>
                <para>Some platforms may support the concept of Forced Roaming and Application Level Roaming (ALR). Forced roaming implies that the platform may simply roam to a new configuration without consulting applications. It is up to the application to detect the link layer loss and reestablish its sockets. In contrast ALR provides the opportunity to prevent the system from roaming. If this session is based on a configuration that supports roaming the application can choose whether it wants to be consulted (ALR use case) by connecting to this signal. For as long as this signal connection remains the session remains registered as a roaming stakeholder; otherwise roaming will be enforced by the platform.</para>
                <para>See also migrate(), ignore(), and QNetworkConfiguration::isRoamingAvailable().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQNetworkSessionSignals.NewConfigurationActivated">
            <summary>
                <para>This signal is emitted once the session has roamed to the new access point. The application may reopen its socket and test the suitability of the new network link. Subsequently it must either accept() or reject() the new access point.</para>
                <para>See also accept() and reject().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQSslSocketSignals.Encrypted">
            <summary>
                <para>This signal is emitted when QSslSocket enters encrypted mode. After this signal has been emitted, QSslSocket::isEncrypted() will return true, and all further transmissions on the socket will be encrypted.</para>
                <para>See also QSslSocket::connectToHostEncrypted() and QSslSocket::isEncrypted().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQSslSocketSignals.PeerVerifyError(QtNetwork.QSslError)">
            <summary>
                <para>QSslSocket can emit this signal several times during the SSL handshake, before encryption has been established, to indicate that an error has occurred while establishing the identity of the peer. The error is usually an indication that QSslSocket is unable to securely identify the peer.</para>
                <para>This signal provides you with an early indication when something's wrong. By connecting to this signal, you can manually choose to tear down the connection from inside the connected slot before the handshake has completed. If no action is taken, QSslSocket will proceed to emitting QSslSocket::sslErrors().</para>
                <para>This function was introduced in Qt 4.4.</para>
                <para>See also sslErrors().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQSslSocketSignals.SslErrors(System.Collections.Generic.List{QtNetwork.QSslError})">
            <summary>
                <para>QSslSocket emits this signal after the SSL handshake to indicate that one or more errors have occurred while establishing the identity of the peer. The errors are usually an indication that QSslSocket is unable to securely identify the peer. Unless any action is taken, the connection will be dropped after this signal has been emitted.</para>
                <para>If you want to continue connecting despite the errors that have occurred, you must call QSslSocket::ignoreSslErrors() from inside a slot connected to this signal. If you need to access the error list at a later point, you can call sslErrors() (without arguments).</para>
                <para>errors contains one or more errors that prevent QSslSocket from verifying the identity of the peer.</para>
                <para>Note: You cannot use Qt::QueuedConnection when connecting to this signal, or calling QSslSocket::ignoreSslErrors() will have no effect.</para>
                <para>See also peerVerifyError().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQSslSocketSignals.ModeChanged(QtNetwork.QSslSocket.SslMode)">
            <summary>
                <para>This signal is emitted when QSslSocket changes from QSslSocket::UnencryptedMode to either QSslSocket::SslClientMode or QSslSocket::SslServerMode. mode is the new mode.</para>
                <para>See also QSslSocket::mode().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQSslSocketSignals.EncryptedBytesWritten(System.Int64)">
            <summary>
                <para>This signal is emitted when QSslSocket writes its encrypted data to the network. The written parameter contains the number of bytes that were successfully written.</para>
                <para>This function was introduced in Qt 4.4.</para>
                <para>See also QIODevice::bytesWritten().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.IQTcpServerSignals.NewConnection">
            <summary>
                <para>This signal is emitted every time a new connection is available.</para>
                <para>See also hasPendingConnections() and nextPendingConnection().</para>
            </summary>
        </member>
    </members>
</doc>
